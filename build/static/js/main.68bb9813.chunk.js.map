{"version":3,"sources":["js/util.js","Leap.js","App.js","serviceWorker.js","index.js","js/board.js"],"names":["module","exports","cellType","row","col","type","inBounds","util","require","BOARD_SIZE","playerOne","playerTwo","PLAYERS","name","class","CELL_COLORS","Piece","props","classes","p","board","pieces","piece","player","cloned","selected","className","Cell","this","column","highlight","onClick","selectCell","val","Component","Row","selectedCol","selectedPiece","cells","map","cell","i","key","who","ri","move","GameBoard","selectedRow","rows","Winner","id","restart","Leap","state","Board","turn","continuedMove","winner","prevProps","prevState","movesLeft","console","log","setState","nextPlayer","validMove","handleMove","updateBoard","canSelectPiece","setPiece","moveDirection","sel","pi","isCloneSpawn","makeClone","doMove","canContinueMove","getMoves","rowIncr","colIncr","s","bind","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","size","p1","p2","initBoard","piecesSeparator","initPieces","prototype","newPiece","j","alive","push","Array","fill","whitePieces","blackPieces","c","concat","insertAtSeparationIndex","length","clone","splice","canClone","getPlayer","isLeap","isPhase","cellAdj","bypassCondition","destinationCell","phaseAdj","phaseFar","capt","isJump","getCloneSpawns","getMovesInDirection","r","caught","cellAdjStartPos","Math","abs","cellAdjEndPos","sign","samePhase","from","to","isDestinationPhase","dir","hasMoves"],"mappings":"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","file":"static/js/main.68bb9813.chunk.js","sourcesContent":["\nmodule.exports.cellType = function (row, col) {\n\tlet type;\n\tswitch (true) {\n\t\tcase (col === 1 && row === 2) || (col === 6 && row === 5):\n\t\t\ttype = 2;\n\t\t\tbreak;\n\t\tcase (col === 3 && row === 2) || (col === 4 && row === 5):\n\t\t\ttype = 3;\n\t\t\tbreak;\n\t\tcase (col === 4 && row === 2) || (col === 3 && row === 5):\n\t\t\ttype = 4;\n\t\t\tbreak;\n\t\tcase (col === 5 && row === 3) || (col === 2 && row === 4):\n\t\t\ttype = 5;\n\t\t\tbreak;\n\t\tcase (col === 5 && row === 4) || (col === 2 && row === 3):\n\t\t\ttype = 6;\n\t\t\tbreak;\n\t\tcase (col === 6 && row === 2) || (col === 1 && row === 5):\n\t\t\ttype = 7;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = (row + col) % 2 === 0 ? 0 : 1;\n\t\t\tbreak;\n\t}\n\treturn type;\n}\n\nmodule.exports.inBounds = function (row, col) {\n\treturn ((row > -1 && row < 8) && (col > -1 && col < 8));\n}\n","import React, { Component } from 'react';\nimport './css/ui.css';\nimport Board from './js/board.js';\nimport Countdown from 'react-countdown-now';\nvar util = require('./js/util.js');\n\n/*\nTODO:\nhighlight pieces\n\nGame description:\n\n\n\"How to Play\":\n-directions\n-tutorial?\n*/\n\nconst BOARD_SIZE = 8;\nconst playerOne = 1;\nconst playerTwo = 2;\nconst PLAYERS = {\n  [playerOne]: {\n    name: \"Player One\",\n    class: \"player-one\"\n  },\n  [playerTwo]: {\n    name: \"Player Two\",\n    class: \"player-two\"\n  }\n}\n\nconst CELL_COLORS = [ \"gray1\", \"gray2\", \"pink\", \"red\", \"orange\", \"yellow\", \"green\", \"blue\"];\n\n/*\nTODO:\n- Make continue button (?)\n\n- AI player\n\n- Allow multiplayer\n    Random match making\n    invites (link or username (if integrated with Google Play))\n\n- Pieces are draggable and snap to grid\n    (if center of dragging piece is strictly within calc(cell-margin + cell-height/2) on drop, then select cell where piece dropped)\n    disable animations for all but phase and clone moves.\n\n- Make animations\n    If clone, we animate the original piece and newly created piece with cloning animation\n    If phase, piece fades in/out from center to edges on adj phase  and on far phase\n    if piece has caught:\n      If jump,\n        piece does a small hop to the destinationCell\n        captured bursts into little circles and fades away\n      If leap,\n        piece gets sucked into portal, (SVG points all transform to center of adj phase, timing ease-in-out), and pushed out (reverse animation)\n        if captured on adj phase:\n          captured shakes and does first part of phase animation while piece being sucked in, but then comes out as little circles on other side\n        else:\n          captured bursts into little circles and fades away\n    else:\n      piece does small hop to destination cell\n\nHow can we handle animations?\n> Translate moving piece p, where p is a child of the destination cell component,\n> from ( startingCell.center.x , startingCell.center.y ) to ( destinationCell.x, destinationCell.y)\n\n\nANIMATION PIPELINE:\n  In function Board.doMove:\n  - get move details\n      moving piece: p,\n      startingCell = {who: board[p.row][p.col].who, move_type: ye, row: p.row, col: p.col}, -- defined first in do move\n      moveDirection,\n      captured piece (if applicable)\n\n  Upon doMove or makeClone:\n  - Find Cell components of startingCell and, if applicable, captured piece\n      (starting cell) get Cell component c such that: c.row === startingCell.row && c.col === startingCell.col\n      (captured piece) get\n\n  -\n\n\n*/\n\nfunction Piece(props) {\n  //\n\n  let classes = \"\";\n  let p = props.board.pieces[props.piece];\n  if (props.piece !== null) {\n    classes += PLAYERS[p.player].class;\n    if (p.cloned) classes += \" cloned\";\n    if (props.selected) {\n      classes += \" selected\";\n      //props.board.getMoves(props.piece);\n    }\n  }\n  return (<div className={classes}></div>)\n}\n\nclass Cell extends Component {\n\n  render() {\n    let color = CELL_COLORS[util.cellType(this.props.row, this.props.column)];\n\n    //let selection = this.props.selected ? \" selected\" : \"\";\n    let highlight = this.props.highlight ? \" highlight\" : \"\";\n    let classes = \"cell \" + color + highlight;\n    return (\n      <div className={classes} onClick={ () => this.props.selectCell(this.props.row, this.props.column) }>\n        {this.props.val !== null\n        && <Piece piece={this.props.val}\n                  board={this.props.board}\n                  selected={this.props.selected ? true : false}/>}\n      </div>\n    )\n  }\n}\n\nclass Row extends Component {\n  render() {\n    let selectedCol = this.props.selectedPiece ? this.props.selectedPiece.col : null;\n    let cells = this.props.row.map((cell, i) => {\n      return <Cell key={i}\n              val={cell.who} //so this.board[row][col] = {who: p.player | null, highlight: true | false -> if selectedCol then this.board[row][col].highlight\n              board={this.props.board}\n              row={this.props.ri}\n              column={i}\n              highlight={cell.move !== false ? true : false}\n              selected={i === selectedCol ? true : false}\n              selectCell={this.props.selectCell} />\n    });\n    return (<span className=\"row\"> {cells} </span>)\n  }\n}\n\nclass GameBoard extends Component {\n  render() {\n    let selectedRow = this.props.selectedPiece ? this.props.selectedPiece.row : null;\n    let rows = this.props.board.board.map((row, i) => {\n      return <Row key={i}\n              board={this.props.board}\n              row={row} //board[row]\n              selectedPiece={i === selectedRow ? this.props.selectedPiece : null}\n              ri={i}\n              pieces={this.props.board.pieces}\n              selectCell={this.props.selectCell} />;\n    });\n    return (<div className=\"board\"> {rows} </div>)\n  }\n}\n\nfunction Winner(props) {\n  let player = PLAYERS[props.player].name;\n  return (\n    <div id=\"winner\">\n      <div>\n        <p>{player} has won the game!</p>\n        <button onClick={props.restart}>Play again?</button>\n      </div>\n    </div>\n  );\n}\n\nclass Leap extends Component {\n  constructor() {\n    super();\n    this.state = { board: new Board(BOARD_SIZE, playerOne, playerTwo),\n                  turn: playerOne,\n                  continuedMove: false,\n                  selectedPiece: null, winner: null };\n  }\n\n  //React update method\n  componentDidUpdate(prevProps, prevState) {\n    //this.state.board.updateBoard();\n    if (prevState.turn !== this.state.turn) {\n      let board = this.state.board;\n      if (!board.movesLeft(this.state.turn)) {\n        console.log(\"${this.state.turn} has no more moves!\");\n        this.setState({winner: this.nextPlayer()});\n      }\n    } else if (this.state.selectedPiece){\n      //if is a move continuation and Counter hasn't started, start the timer\n      //if (this.state.contined_move) {}\n    }\n  }\n\n  selectCell(row, col) {\n    //If a move is not a continuation, default case,\n    if (!this.state.continuedMove) {\n      if (this.canSelectPiece(row, col)) this.setPiece(row, col);\n      else if (this.state.selectedPiece)  this.handleMove(row, col);\n    } else { //if continuation\n      //check if move = true..\n      let board = this.state.board;\n      if (board.validMove(row, col)) this.handleMove(row, col)\n      else {\n        //TODO: prompt \"end turn?\" option.\n        //right now, let's just end the turn otherwise\n        this.setState({board: board, turn: this.nextPlayer(this.state.turn), continuedMove: false, selectedPiece: null});\n        board.updateBoard();\n      }\n    }\n  }\n\n  handleMove(row, col) { //row, col of destination\n    let board = this.state.board;\n    if (!board.validMove(row, col)) {\n      console.log(\"Invalid move!\");\n      return;\n    }\n    console.log(\"handling move...\");\n    let sel = this.state.selectedPiece;\n    let pi = board.board[sel.row][sel.col].who;\n\n    let moveDirection;\n    //Check if move is a clone move; If it is, we need not call doMove\n    if(board.isCloneSpawn(pi,row, col)) board.makeClone(pi, row, col);\n    else moveDirection = board.doMove(pi, row, col);\n    //all highlights gone\n\n    //If we can jump or leap, or phase (if move prior was not a phase)\n    if (board.canContinueMove(pi, moveDirection)) {\n      board.getMoves(pi, 3, moveDirection.rowIncr, moveDirection.colIncr); //highlight continuable moves\n      this.setState( {board: board, turn: this.state.turn, continuedMove: moveDirection, selectedPiece: {row: row, col: col}});\n    } else this.setState({board: board, turn: this.nextPlayer(this.state.turn), continuedMove: false, selectedPiece: null});\n  }\n\n  canSelectPiece(row, col) {\n    let s = this.state;\n    let cell = s.board.board[row][col].who;\n    if (cell === null) return false;\n    let player = s.board.pieces[cell].player;\n    return player === s.turn;\n  }\n\n  setPiece(row, col) {\n    let board = this.state.board;\n    board.updateBoard();\n    board.getMoves(board.board[row][col].who);\n    this.setState({selectedPiece: {row: row, col: col}});\n      //console.log(\"selected piece: \" + this.state.board.board[row][col].who);\n  }\n\n  nextPlayer() {\n    return (this.state.turn === playerOne ? playerTwo : playerOne);\n  }\n\n  restart() {\n    this.setState({ board: new Board(BOARD_SIZE, playerOne, playerTwo),\n                    continuedMove: false, turn: playerOne,\n                    selectedPiece: null, winner: null });\n  }\n\n  render() {\n    return (\n      <div className=\"Leap\">\n        <div className=\"Leap-header\">\n          <h2>Leap</h2>\n        </div>\n        { this.state.winner && <Winner player={this.state.winner} restart={this.restart.bind(this)} /> }\n        <h3>Current turn: {PLAYERS[this.state.turn].name}<span className={PLAYERS[this.state.turn].class+\"-token\"}></span></h3>\n\n\n        <div className=\"game-container\">\n          <div className=\"game-options\"></div>\n          <GameBoard board={this.state.board}\n                     selectedPiece={this.state.selectedPiece}\n                     selectCell={this.selectCell.bind(this)} />\n          <div className=\"game-menu\"></div>\n        </div>\n      </div>\n    );\n  }\n}\n/*\n<Countdown date={Date.now() + 10000}\n           intervalDelay={0}\n           precision={3}\n           autoStart={this.state.continuedMove}\n           renderer={d => <div>\n              <span className=\"countdown-s\">{d.seconds}</span>\n              <span className=\"countdown-ms\">:{d.milliseconds}</span>\n           </div>}/>\n*/\n\nexport default Leap;\n","import React from 'react';\nimport './css/App.css';\nimport Menu from './Leap';\nimport Leap from './Leap';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n    <Menu/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\nserviceWorker.unregister();\n","var util = require('./util.js');\n//single, phase, jump, super-jump\n/*\nadj: adjacent\nphase: change portal side\nleap: capture piece while jumping through a portal\njitch: jump, then phase\nswump: switch, then jump\n}\n*/\n/*\nLEGEND\npi = piece index in Board.pieces\np = piece Board.pieces[pi]\n*/\n\n/*\nPreviously, I assumed that if a uncloned piece reaches the end of the other player's side,\nthen that piece must duplicate before continuing the game. However, my assumption fails\nif the player's spawn row is full and hence I will give the player the option to choose.\n\nThis realization got me thinking about adding different game modes that\nmodify things like the board size, and side-wrapping.\n\nboard size: If board were 9x9, we can put a clone phaser in the center\nthat duplicates any non-clone pieces at most once.\n\nside wrapping: columns are cyclic: make board[row] = cyclic linked List?\n\n\n\nSpeaking of linked lists... Why am I not using them now?\nMaybe this is what I needed to store highlight;\n represent each of this.state.selectedPiece's moves as a boolean for 'highlight' in\n this.board[row][col] = {who: p.player | null, highlight: true | false :: added in Board.getMoves(pi)}\n for some row,col,  and p = this.piece[pi]\n to Leap.setPiece(), add this.state.board.updateBoard()\n\n*/\n\n\nfunction Board(size, p1, p2) {\n\tthis.p1 = p1;\n\tthis.p2 = p2;\n\tthis.board = this.initBoard(size);\n\tthis.piecesSeparator = 8;\n\tthis.pieces = this.initPieces(size, p1, p2);\n\tthis.updateBoard(); //add pieces to board\n}\n\n//TODO:\n//this.board[row][col] = {who: p.player | null, highlight: {row: some_row, col: some_col} | null:: added in Board.getMoves(pi)}\n//update occurs when (1) piece is cloned (pieces index may change)\n// and when (2) setPiece is called\n//To make highlight function properly, I'll have to call this.getMoves() from here.\n//It follows that I will have to remove other calls to this.getMoves()\nBoard.prototype.updateBoard = function (newPiece) {\n\tif (newPiece) {\n\t\tthis.board = this.board.map(row => row.map((cell, j) => {\n\t\t\tif (cell.who != null) { //increment all pi in board after piecesSeparator by one\n\t\t\t\tif (cell.who >= this.piecesSeparator) cell.who++;\n\t\t\t\t//if piece alive, keep on board\n\t\t\t\treturn this.pieces[cell.who].alive ? {who: cell.who, move:false} : {who: null, move:false};\n\t\t\t} else return {who: null, move: false};\n\t\t}));\n\t} else {\n\t\tthis.board = this.board.map(row => row.map((cell, j) =>\n\t\t\t(cell.who != null)\n\t\t\t? (this.pieces[cell.who].alive\n\t\t\t\t? {who: cell.who, move:false}\n\t\t\t\t: {who: null, move:false})\n\t\t\t: {who: null, move: false}\n\t\t));\n\t}\n}\n\nBoard.prototype.initBoard = function (size) {\n    let board = [], playerTwo = [], playerOne = [];\n\t\t//TODO: fill as {who: pi (this.pieces index), highlight: null}\n\t\tfor (let i = 0; i < size; i++) {\n\t\t\tplayerTwo.push({who: i, move: false});\n\t\t\tplayerOne.push({who: i+8, move: false});\n\t\t}\n\t\tboard.push(playerTwo);\n\t\tfor (let i = 1; i < size-1; i++) board.push(Array(size).fill({who: null, move: false}));\n\t\tboard.push(playerOne);\n\n    return board;\n}\n\nBoard.prototype.initPieces = function (size) {\n\tlet whitePieces = [];\n\tlet blackPieces = [];\n\tfor (let c = 0; c < size; c++) {\n\t\twhitePieces.push({player: this.p1, cloned: false, row: 7, col: c, alive: true});\n\t\tblackPieces.push({player: this.p2, cloned: false, row: 0, col: c, alive: true});\n\t}\n    return blackPieces.concat(whitePieces);\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n//Calls every time a clone is made\nBoard.prototype.insertAtSeparationIndex = function () {\n\tfor(let pi=this.piecesSeparator; pi<this.pieces.length; pi++) {\n\t\t//Finds index that separates p1 and p2 pieces\n\t\tif(this.pieces[pi].player !== this.p2) {\n\t\t\tthis.piecesSeparator = pi; //update\n\t\t\treturn pi;\n\t\t}\n\t}\n}\n\nBoard.prototype.makeClone = function (pi, row, col) {\n\tlet p = this.pieces[pi];\n\tp.cloned = true;\n\tlet clone = {player: p.player, cloned: true, row: row, col: col, alive: true};\n\tthis.pieces.splice(this.insertAtSeparationIndex(),0, clone); //add clone to pieces Array\n\tthis.updateBoard(true);\n\tthis.board[row][col].who = this.piecesSeparator;\n\treturn true;\n}\n\nBoard.prototype.canClone = function (pi) {\n\tlet p = this.pieces[pi];\n\treturn (!p.cloned && p.col < 7 && p.col > 0 && ( (p.player === this.p1 && !p.row) || (p.player === this.p2 && p.row === 7) ));\n}\n\nBoard.prototype.isCloneSpawn = function (pi, row, col) {\n\treturn this.canClone(pi) && this.board[row][col].who === null;\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\nBoard.prototype.getPlayer = function (pi) {\n\treturn this.pieces[pi].player;\n}\n\nBoard.prototype.isLeap = function (p, rowIncr, colIncr, isPhase, cellAdj, bypassCondition) {\n\t//if neighbor cell is a phase, leap_cell clear, and (enemy piece on phaseAdj XOR enemy piece on phaseFar)\n\tlet destinationCell = this.board[7 - p.row][7 - p.col];\n\tif(isPhase && !destinationCell.who) {\n\t\tlet phaseAdj = cellAdj.who;\n\t\tlet phaseFar = this.board[7 - (p.row + rowIncr)][7 - (p.col + colIncr)].who;\n\t\tif((phaseAdj || phaseFar) && !(phaseAdj && phaseFar)) { //xor filter. Only one may be true\n\t\t\tlet capt = phaseAdj ? phaseAdj : phaseFar;\n\t\t\t//if 0, add to destinationCell.move, if 1,\n\t\t\tif (bypassCondition) return true;\n\t\t\telse destinationCell.move = capt;\n\t\t}\n\t}\n}\n\nBoard.prototype.isJump = function (p, rowIncr, colIncr, cellAdj, bypassCondition) {\n\t//if adj cell occupied, jumpCell in bounds, jumpCell clear, and jumpCell has enemy piece\n\tif(util.inBounds(p.row + rowIncr*2, p.col + colIncr*2)) {\n\t\tlet destinationCell = this.board[p.row + rowIncr*2][p.col + colIncr*2];\n\t\tif (this.getPlayer(cellAdj.who) !== p.player && destinationCell.who === null) {\n\t\t\tif(bypassCondition%3) return true;\n\t\t\telse destinationCell.move = cellAdj.who;\n\t\t}\n\t}\n}\n\nBoard.prototype.isPhase = function (p, bypassCondition) {\n\tlet isPhase = util.cellType(p.row, p.col) > 1;\n\tlet destinationCell = this.board[7 - p.row][7 - p.col];\n\tif(isPhase && destinationCell.who === null) {\n\t\tif (bypassCondition%3) return true;\n\t\telse destinationCell.move = true;\n\t}\n}\n\nBoard.prototype.getCloneSpawns = function (p, bypassCondition) {\n\tlet row = p.player === this.p1 ? 7 : 0;\n\tfor(let col=1; col<7;col++) {\n\t\tlet destinationCell = this.board[row][col];\n\t\tif (destinationCell.who === null) {\n\t\t\tif (bypassCondition%3) return true;\n\t\t\telse destinationCell.move = true;\n\t\t}\n\t}\n}\n\nBoard.prototype.getMovesInDirection = function (p, bypassCondition, r, c) {\n\t//check adjacent cells of piece p wrt the boundary\n\tif(util.inBounds(p.row + r, p.col + c) && (r || c)) {\n\t\tlet cellAdj = this.board[p.row + r][p.col + c];\n\t\tlet isPhase = util.cellType(p.row + r, p.col + c) > 1;\n\n\t\tif (this.isLeap(p, r, c, isPhase, cellAdj, bypassCondition)) return true;\n\t\tif (cellAdj.who !== null) {\n\t\t\tif (this.isJump(p, r, c, cellAdj, bypassCondition)) return true;\n\t\t}\n\t\telse if (bypassCondition%3%2) return true;\t//adjacent moves\n\t\telse if (!bypassCondition) cellAdj.move = true;\n\t}\n\treturn false;\n}\n\n//bypassCondition (HIGHLIGHT BYPASS CONDITION): undefined - default (Store all), 1 - bypass all, 2 - bypass continuable moves, 3 - store continuable moves\nBoard.prototype.getMoves = function (pi, bypassCondition, r, c) {\n\n\tlet p = this.pieces[pi];\n\t//TODO: ref this.board[p.row + r][p.col + r].who, and set highlight = true for every destination\n\tif (this.isPhase(p, bypassCondition)) return true;\n\tif (this.canClone(pi) && this.getCloneSpawns(p, bypassCondition)) return true;\n\n\tif (r != null && c != null) {\n\t\tif (this.getMovesInDirection(p, bypassCondition, r, c)) return true;\n\t} else {\n\t\tfor(r=-1;r<2;r++) for(c=-1;c<2; c++) {\n\t\t\tif (this.getMovesInDirection(p, bypassCondition, r, c)) return true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n//Performs move. returns true if caught piece in process, else false\nBoard.prototype.doMove = function (pi, row, col) {\n\tlet p = this.pieces[pi];\n\t//begin move\n\tthis.board[p.row][p.col].who = null;\n\n\tlet destinationCell = this.board[row][col];\n\tlet caught = typeof(destinationCell.move) === \"number\" ? destinationCell.move : false; //caught piece index\n\t// moveDirection is defined if and only if any of the following is true (for moving piece p):\n\tlet moveDirection;\n\t\t// (1) p caught a piece\n\tif (caught) {\n\t\tlet c = this.pieces[caught];\n\t\tc.alive = false;\n\t\tthis.board[c.row][c.col].who = null;\n\t\t//return direction of move\n\t\t//If leap, then c adjacent at start XOR c adjacent at end\n\t\t//Check adjacency of moving piece to captured piece on starting position and ending position\n\t\tlet cellAdjStartPos = Math.abs(c.row - p.row) < 2 && Math.abs(c.col - p.col) < 2;\n\t\tlet cellAdjEndPos = Math.abs(row - c.row) < 2 && Math.abs(col - c.col) < 2;\n\n\t\tmoveDirection = (cellAdjStartPos && cellAdjEndPos)\n\t\t\t? {rowIncr: Math.sign(row-c.row), colIncr: Math.sign(col-c.col)}\t//jump\n\t\t\t: (cellAdjStartPos\n\t\t\t\t? {rowIncr: Math.sign(c.row-p.row), colIncr: Math.sign(c.col-p.row)}\t//leap-> piece adj to capture on start\n\t\t\t\t: {rowIncr: Math.sign(row-c.row), colIncr: Math.sign(col-c.col)});\n\t}\t// (2) p LANDS on a phase cell. That is, this move is not a phase.\n\telse if (!this.samePhase(p,{row: row, col: col}))\tmoveDirection = {rowIncr: 0, colIncr: 0};\n\n\t//end move\n\tthis.board[row][col].who = pi;\n\tp.row = row;\n\tp.col = col;\n\n\t\t// (3) p is able to be cloned\n\tif (this.canClone(pi)) moveDirection = {rowIncr: 0, colIncr:0};\n\tthis.updateBoard();\n\treturn moveDirection;\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tINTEGRITY\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\nBoard.prototype.samePhase = function (from, to) {\n\tlet isDestinationPhase = util.cellType(to.row, to.col);\n\treturn isDestinationPhase > 1 && isDestinationPhase === util.cellType(from.row, from.col);\n}\n\nBoard.prototype.canContinueMove = function (pi, dir) {\n\n\treturn dir ? this.getMoves(pi, 2, dir.rowIncr, dir.colIncr) : false;\n}\n\nBoard.prototype.hasMoves = function (pi) {\n\treturn this.getMoves(pi, 1);\n}\n\n//Player has no more moves when (1): all player's pieces are dead (2): every piece has no moves\nBoard.prototype.movesLeft = function (player) {\n\tfor(let pi=0; pi < this.pieces.length; pi++) {\n\t\tlet p = this.pieces[pi];\n\t\tif(p.alive && p.player === player) {\n\t\t\tif(this.hasMoves(pi)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nBoard.prototype.validMove = function (row, col) {\n\treturn this.board[row][col].move;\n}\n\nmodule.exports = Board;\n"],"sourceRoot":""}