{"ast":null,"code":"//single, phase, jump, super-jump\n\n/*\nadj: adjacent\nphase: change portal side\nleap: capture piece while jumping through a portal\njitch: jump, then phase\nswump: switch, then jump\n}\n*/\n\n/*\nLEGEND\npi = piece index in Board.pieces\np = piece Board.pieces[pi]\n\n\n\n\n*/\nfunction cell_type(row, col) {\n  let type;\n\n  switch (true) {\n    case row == 1 && col == 2 || row == 6 && col == 5:\n      type = 2;\n      break;\n\n    case row == 3 && col == 2 || row == 4 && col == 5:\n      type = 3;\n      break;\n\n    case row == 4 && col == 2 || row == 3 && col == 5:\n      type = 4;\n      break;\n\n    case row == 5 && col == 3 || row == 2 && col == 4:\n      type = 5;\n      break;\n\n    case row == 5 && col == 4 || row == 2 && col == 3:\n      type = 6;\n      break;\n\n    case row == 6 && col == 2 || row == 1 && col == 5:\n      type = 7;\n      break;\n\n    default:\n      type = (row + col) % 2 == 0 ? 0 : 1;\n      break;\n  }\n\n  return type;\n}\n\nfunction in_bounds(row, col) {\n  return (row > -1 || row < 8) && (col > -1 || col < 8);\n}\n\nfunction Board(size, p1, p2) {\n  this.board = this.init_board(size);\n  this.p1 = p1;\n  this.p2 = p2;\n  this.pieces_separator = 8;\n  this.pieces = this.init_pieces(size, p1, p2);\n} //TODO:\n//this.board[row][col] = {who: p.player | null, highlight: {row: some_row, col: some_col} | null:: added in Board.get_moves(pi)}\n//update occurs when (1) piece is cloned (pieces index may change)\n// and when (2) set_piece is called\n//To make highlight function properly, I'll have to call this.get_moves() from here.\n//It follows that I will have to remove other calls to this.get_moves()\n\n\nBoard.prototype.update_board = function () {\n  this.board.map(row => row.map((cell, j) => cell !== null ? this.pieces[cell].alive ? this.pieces[cell] : null : null));\n};\n\nBoard.prototype.init_board = function (size) {\n  let b = [];\n\n  for (let i = 0; i < size; i++) b.push(Array(size).fill(null));\n\n  return b;\n};\n\nBoard.prototype.init_pieces = function (size) {\n  let white_pieces = [];\n  let black_pieces = [];\n\n  for (let i = 0; i < size; i++) {\n    white_pieces.push({\n      player: this.p1,\n      cloned: false,\n      row: 7,\n      col: 1,\n      alive: true\n    });\n    black_pieces.push({\n      player: this.p2,\n      cloned: false,\n      row: 0,\n      col: 1,\n      alive: true\n    });\n  }\n\n  i;\n  this.update_board(); //add pieces to board\n\n  return white_pieces.concat(black_pieces);\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n//Calls every time a clone is made\n\n\nBoard.prototype.insert_at_separation_index = function () {\n  for (let pi = this.pieces_separator; pi < this.pieces.length; pi++) {\n    //Finds index that separates p1 and p2 pieces\n    if (this.pieces[pi].player != this.p1) {\n      this.pieces_separator = pi; //update\n\n      return pi;\n    }\n  }\n};\n\nBoard.prototype.make_clone = function (pi, row, col) {\n  this.pieces[pi].cloned = true; //row will only be 0 or 7, so we can use this to determine player and placement\n\n  let player = row ? this.p1 : this.p2;\n  let clone = {\n    player: player,\n    cloned: true,\n    row: row,\n    col: col,\n    alive: true\n  };\n  return this.pieces.splice(this.insert_at_separation_index(), 0, clone);\n};\n\nBoard.prototype.can_clone = function (pi) {\n  let p = this.pieces[pi];\n  return !p.cloned && (p.player == this.p1 && !p.row || p.player == this.p2 && p.row == 7);\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n\nBoard.prototype.get_player = function (pi) {\n  return this.pieces[pi].player;\n};\n\nBoard.prototype.is_leap = function (p, row_incr, col_incr) {\n  //if neighbor cell is a phase, leap_cell clear, and (enemy piece on phase_adj XOR enemy piece on phase_far)\n  if (is_phase && !this.board[7 - p.row][7 - p.col]) {\n    let phase_adj = cell_adj;\n    let phase_far = this.board[7 - (p.row + row_incr)][7 - (p.col + col_incr)];\n\n    if ((phase_adj || phase_far) && !(phase_adj && phase_far)) {\n      //xor filter. Only one may be true\n      let capt = phase_adj ? phase_adj : phase_far;\n      return {\n        row: 7 - p.row,\n        col: 7 - p.col,\n        captured_pi: capt\n      };\n    }\n  }\n};\n\nBoard.prototype.is_jump = function (p, row_incr, col_incr) {\n  //if adj cell occupied, jump_cell in bounds, jump_cell clear, and jump_cell has enemy piece\n  if (in_bounds(p.row + row_incr * 2, p.col + col_incr * 2)) {\n    if (this.get_player(cell_adj) != p.player && !this.board[p.row + row_incr * 2][p.col + col_incr * 2]) {\n      return {\n        row: row + row_incr * 2,\n        col: p.col + col_incr * 2,\n        captured_pi: cell_adj\n      };\n    }\n  }\n};\n\nBoard.prototype.is_phase = function (p) {\n  let is_phase = cell_type(p.row, p.col) > 1;\n  if (is_phase && !this.board[7 - p.row][7 - p.col]) return {\n    row: 7 - p.row,\n    col: 7 - p.col\n  };\n};\n\nBoard.prototype.is_clone_spawn = function (p) {\n  let spawn_row = p.player == this.p1 ? this.board[0] : this.board[7];\n  let clone_spawns = [];\n\n  for (let cell = 1; cell < 7; cell++) {\n    if (spawn_row[cell] === null) clone_spawns.push(spawn_row[cell]);\n  }\n\n  return clone_spawns;\n};\n\nBoard.prototype.get_moves = function (pi) {\n  let adjs = [],\n      jumps = [],\n      leaps = [];\n  let p = this.pieces[pi];\n  /*\n  Previously, I assumed that if a uncloned piece reaches the end of the other player's side,\n  then that piece must duplicate before continuing the game. However, my assumption fails\n  if the player's spawn row is full and hence I will give the player the option to choose.\n  \tThis realization got me thinking about adding different game modes that\n  modify things like the board size, and side-wrapping.\n  \tboard size: If board were 9x9, we can put a clone phaser in the center\n  that duplicates any non-clone pieces at most once.\n  \tside wrapping: columns are cyclic: make board[row] = cyclic linked List?\n  \n  \tSpeaking of linked lists... Why am I not using them now?\n  Maybe this is what I needed to store highlight;\n   represent each of this.state.selected_piece's moves as a boolean for 'highlight' in\n   this.board[row][col] = {who: p.player | null, highlight: {row: some_row, col: some_col} | null:: added in Board.get_moves(pi)}\n   for some row,col,  and p = this.piece[pi]\n   to Leap.set_piece(), add this.state.board.update_board()\n  \t*/\n\n  let phase, jump, leap;\n\n  for (let r = -1; r < 2; r++) {\n    for (let c = -1; c < 2; c++) {\n      //check adjacent cells of piece p wrt the boundary\n      if (in_bounds(p.row + r, p.col + c) && (r || c)) {\n        let cell_adj = this.board[p.row + r][p.col + r];\n        let is_phase = cell_type(p.row + r, p.col + c) > 1;\n        leap = this.can_leap(p, r, c);\n        if (cell_adj) jump = this.can_jump(p, r, c);else adjs.push({\n          row: row + r,\n          col: col + c\n        }); //adjacent moves\n        //add key: clone_spawn for ANY move resulting in can_clone == true\n\n        if (leap !== undefined) leaps.push(leap);\n        if (jump !== undefined) jumps.push(jump);\n        if (phase !== undefined) phase = this.can_phase(p);\n      }\n    }\n  }\n\n  let piece_moves = {\n    phase: phase,\n    adjs: adjs,\n    jumps: jumps,\n    leaps: leaps\n  };\n\n  if (this.can_clone(pi)) {\n    let clone_spawns = this.is_clone_spawn(p);\n    if (clone_spawns.length) piece_moves.clone_spawns = clone_spawns;\n  }\n\n  return piece_moves;\n}; //Performs move. returns true if captured piece in process, else false\n\n\nBoard.prototype.do_move = function (pi, row, col) {\n  let p = this.pieces[pi];\n  this.board[p.row][p.col] = null;\n  this.board[row][col] = pi;\n  p.row = row;\n  p.col = col; //if piece p contains captured piece\n\n  let c = p.captured_pi !== undefined ? this.pieces[p.captured_pi] : null;\n\n  if (c) {\n    c.alive = false;\n    this.board[c.row][c.col] = null;\n    return true;\n  }\n\n  return false;\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tINTEGRITY\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n\nBoard.prototype.can_continue_turn = function (pi) {\n  let moves = this.get_moves(pi);\n  let capturing_moves = {\n    jumps: moves.jumps,\n    leaps: moves.leaps,\n    clone_spawns: moves.clone_spawns\n  }; //return !parseInt(Object.values(a).reduce( (j,i) => i.length !== undefined ? i.length + j: j));\n\n  return !capturing_moves.every(t => t == [] || t == {} || t == null);\n};\n\nBoard.prototype.can_continue = function (pi) {\n  let moves = this.get_moves(pi); //return !parseInt(Object.values(a).reduce( (j,i) => i.length !== undefined ? i.length + j: j));\n\n  return !moves.every(t => t == [] || t == {} || t == null);\n}; //Player has no more moves when (1): all player's pieces are dead (2): every piece has no moves\n\n\nBoard.prototype.has_moves = function (player) {\n  for (let pi = 0; pi < this.pieces.length; pi++) {\n    let p = this.pieces[pi];\n\n    if (p.alive && p.player == player) {\n      if (this.can_continue(pi)) return true;\n    }\n  }\n\n  return false;\n};\n\nBoard.prototype.valid_move = function (pi, row, col) {\n  let m = this.get_moves(pi); //** this.board[row][col].highlight\n\n  let moves = [];\n  moves = moves.concat(m.phase, m.adjs, m.jumps, m.leaps);\n\n  for (let type in moves) {\n    for (let move of type) {\n      if (move.row == row && move.col == col) return true;\n    }\n  }\n\n  return false;\n};\n\nmodule.exports = Board;","map":{"version":3,"sources":["/Users/bacchus/git/Leap/src/js/board.js"],"names":["cell_type","row","col","type","in_bounds","Board","size","p1","p2","board","init_board","pieces_separator","pieces","init_pieces","prototype","update_board","map","cell","j","alive","b","i","push","Array","fill","white_pieces","black_pieces","player","cloned","concat","insert_at_separation_index","pi","length","make_clone","clone","splice","can_clone","p","get_player","is_leap","row_incr","col_incr","is_phase","phase_adj","cell_adj","phase_far","capt","captured_pi","is_jump","is_clone_spawn","spawn_row","clone_spawns","get_moves","adjs","jumps","leaps","phase","jump","leap","r","c","can_leap","can_jump","undefined","can_phase","piece_moves","do_move","can_continue_turn","moves","capturing_moves","every","t","can_continue","has_moves","valid_move","m","move","module","exports"],"mappings":"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","sourcesContent":["//single, phase, jump, super-jump\n/*\nadj: adjacent\nphase: change portal side\nleap: capture piece while jumping through a portal\njitch: jump, then phase\nswump: switch, then jump\n}\n*/\n/*\nLEGEND\npi = piece index in Board.pieces\np = piece Board.pieces[pi]\n\n\n\n\n*/\n\nfunction cell_type(row, col) {\n\tlet type;\n\tswitch (true) {\n\t\tcase (row == 1 && col == 2) || (row == 6 && col == 5):\n\t\t\ttype = 2;\n\t\t\tbreak;\n\t\tcase (row == 3 && col == 2) || (row == 4 && col == 5):\n\t\t\ttype = 3;\n\t\t\tbreak;\n\t\tcase (row == 4 && col == 2) || (row == 3 && col == 5):\n\t\t\ttype = 4;\n\t\t\tbreak;\n\t\tcase (row == 5 && col == 3) || (row == 2 && col == 4):\n\t\t\ttype = 5;\n\t\t\tbreak;\n\t\tcase (row == 5 && col == 4) || (row == 2 && col == 3):\n\t\t\ttype = 6;\n\t\t\tbreak;\n\t\tcase (row == 6 && col == 2) || (row == 1 && col == 5):\n\t\t\ttype = 7;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = (row + col) % 2 == 0 ? 0 : 1;\n\t\t\tbreak;\n\t}\n\treturn type;\n}\n\nfunction in_bounds(row, col) {\n\treturn ((row > -1 || row < 8) && (col > -1 || col < 8));\n}\n\nfunction Board(size, p1, p2) {\n\tthis.board = this.init_board(size);\n\tthis.p1 = p1;\n\tthis.p2 = p2;\n\tthis.pieces_separator = 8;\n\tthis.pieces = this.init_pieces(size, p1, p2);\n}\n\n//TODO:\n//this.board[row][col] = {who: p.player | null, highlight: {row: some_row, col: some_col} | null:: added in Board.get_moves(pi)}\n//update occurs when (1) piece is cloned (pieces index may change)\n// and when (2) set_piece is called\n//To make highlight function properly, I'll have to call this.get_moves() from here.\n//It follows that I will have to remove other calls to this.get_moves()\nBoard.prototype.update_board = function () {\n\tthis.board.map(row => row.map((cell, j) =>\n\t\tcell !== null ? (this.pieces[cell].alive ? this.pieces[cell] : null) : null ));\n}\n\nBoard.prototype.init_board = function (size) {\n    let b = [];\n    for (let i = 0; i < size; i++) b.push(Array(size).fill(null));\n    return b;\n}\n\nBoard.prototype.init_pieces = function (size) {\n\tlet white_pieces = [];\n\tlet black_pieces = [];\n\tfor (let i = 0; i < size; i++) {\n\t\twhite_pieces.push({player: this.p1, cloned: false, row: 7, col: 1, alive: true});\n\t\tblack_pieces.push({player: this.p2, cloned: false, row: 0, col: 1, alive: true});\n\t}i\n\t\tthis.update_board(); //add pieces to board\n    return white_pieces.concat(black_pieces);\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n//Calls every time a clone is made\nBoard.prototype.insert_at_separation_index = function () {\n\tfor(let pi=this.pieces_separator; pi<this.pieces.length; pi++) {\n\t\t//Finds index that separates p1 and p2 pieces\n\t\tif(this.pieces[pi].player != this.p1) {\n\t\t\tthis.pieces_separator = pi; //update\n\t\t\treturn pi;\n\t\t}\n\t}\n}\n\nBoard.prototype.make_clone = function (pi, row, col) {\n\tthis.pieces[pi].cloned = true;\n\t//row will only be 0 or 7, so we can use this to determine player and placement\n\tlet player = row ? this.p1 : this.p2;\n\tlet clone = {player: player, cloned: true, row: row, col: col, alive: true};\n\treturn this.pieces.splice(this.insert_at_separation_index(),0, clone);\n}\n\nBoard.prototype.can_clone = function (pi) {\n\tlet p = this.pieces[pi];\n\treturn (!p.cloned && ( (p.player == this.p1 && !p.row) || (p.player == this.p2 && p.row == 7) ));\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\nBoard.prototype.get_player = function (pi) {\n\treturn this.pieces[pi].player;\n}\n\nBoard.prototype.is_leap = function (p, row_incr, col_incr) {\n\t//if neighbor cell is a phase, leap_cell clear, and (enemy piece on phase_adj XOR enemy piece on phase_far)\n\tif(is_phase && !this.board[7 - p.row][7 - p.col]) {\n\t\tlet phase_adj = cell_adj;\n\t\tlet phase_far = this.board[7 - (p.row + row_incr)][7 - (p.col + col_incr)];\n\t\tif((phase_adj || phase_far) && !(phase_adj && phase_far)) { //xor filter. Only one may be true\n\t\t\tlet capt = phase_adj ? phase_adj : phase_far;\n\t\t\treturn {row: 7 - p.row, col: 7 - p.col, captured_pi: capt};\n\t\t}\n\t}\n}\n\nBoard.prototype.is_jump = function (p, row_incr, col_incr) {\n\t//if adj cell occupied, jump_cell in bounds, jump_cell clear, and jump_cell has enemy piece\n\tif(in_bounds(p.row + row_incr*2, p.col + col_incr*2)) {\n\t\tif (this.get_player(cell_adj) != p.player && !this.board[p.row + row_incr*2][p.col + col_incr*2]) {\n\t\t\t\treturn {row: row  + row_incr*2, col: p.col + col_incr*2, captured_pi: cell_adj};\n\t\t}\n\t}\n}\n\nBoard.prototype.is_phase = function (p) {\n\tlet is_phase = cell_type(p.row, p.col) > 1;\n\tif(is_phase && !this.board[7 - p.row][7 - p.col]) return {row: 7 - p.row, col: 7 - p.col};\n}\n\nBoard.prototype.is_clone_spawn = function (p) {\n\tlet spawn_row = p.player == this.p1 ? this.board[0] : this.board[7];\n\n\tlet clone_spawns = [];\n\tfor(let cell=1; cell<7;cell++) {\n\t\tif (spawn_row[cell] === null) clone_spawns.push(spawn_row[cell]);\n\t}\n\treturn clone_spawns;\n}\n\nBoard.prototype.get_moves = function (pi) {\n\tlet adjs = [], jumps = [], leaps = [];\n\tlet p = this.pieces[pi];\n\n\t/*\n\tPreviously, I assumed that if a uncloned piece reaches the end of the other player's side,\n\tthen that piece must duplicate before continuing the game. However, my assumption fails\n\tif the player's spawn row is full and hence I will give the player the option to choose.\n\n\tThis realization got me thinking about adding different game modes that\n\tmodify things like the board size, and side-wrapping.\n\n\tboard size: If board were 9x9, we can put a clone phaser in the center\n\tthat duplicates any non-clone pieces at most once.\n\n\tside wrapping: columns are cyclic: make board[row] = cyclic linked List?\n\n\n\n\tSpeaking of linked lists... Why am I not using them now?\n\tMaybe this is what I needed to store highlight;\n\t represent each of this.state.selected_piece's moves as a boolean for 'highlight' in\n\t this.board[row][col] = {who: p.player | null, highlight: {row: some_row, col: some_col} | null:: added in Board.get_moves(pi)}\n\t for some row,col,  and p = this.piece[pi]\n\t to Leap.set_piece(), add this.state.board.update_board()\n\n\t*/\n\n\tlet phase, jump, leap;\n\tfor(let r=-1;r<2;r++) {\n\t\tfor(let c=-1;c<2; c++) {\n\t\t\t//check adjacent cells of piece p wrt the boundary\n\t\t\tif(in_bounds(p.row + r, p.col + c) && (r || c)) {\n\t\t\t\tlet cell_adj = this.board[p.row + r][p.col + r];\n\t\t\t\tlet is_phase = cell_type(p.row + r, p.col + c) > 1;\n\n\t\t\t\tleap = this.can_leap(p, r, c);\n\t\t\t\tif(cell_adj) jump = this.can_jump(p, r, c);\n\t\t\t\telse adjs.push({row: row + r, col: col + c});\t//adjacent moves\n\n\t\t\t\t//add key: clone_spawn for ANY move resulting in can_clone == true\n\n\n\t\t\t\tif (leap !== undefined) leaps.push(leap);\n\t\t\t\tif (jump !== undefined) jumps.push(jump);\n\t\t\t\tif (phase !== undefined) phase = this.can_phase(p);\n\t\t\t}\n\t\t}\n\t}\n\n\tlet piece_moves = {phase: phase, adjs: adjs, jumps: jumps, leaps: leaps};\n\tif (this.can_clone(pi)) {\n\t\tlet clone_spawns = this.is_clone_spawn(p);\n\t\tif (clone_spawns.length) piece_moves.clone_spawns = clone_spawns;\n\t}\n\treturn piece_moves;\n}\n\n//Performs move. returns true if captured piece in process, else false\nBoard.prototype.do_move = function (pi, row, col) {\n\tlet p = this.pieces[pi];\n\tthis.board[p.row][p.col] = null;\n\tthis.board[row][col] = pi;\n\tp.row = row;\n\tp.col = col;\n\n\t//if piece p contains captured piece\n\tlet c = p.captured_pi !== undefined ? this.pieces[p.captured_pi] : null;\n\tif (c) {\n\t\tc.alive = false;\n\t\tthis.board[c.row][c.col] = null;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tINTEGRITY\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\nBoard.prototype.can_continue_turn = function (pi) {\n\tlet moves = this.get_moves(pi);\n\tlet capturing_moves = { jumps: moves.jumps, leaps: moves.leaps, clone_spawns: moves.clone_spawns};\n\t//return !parseInt(Object.values(a).reduce( (j,i) => i.length !== undefined ? i.length + j: j));\n\treturn !capturing_moves.every(t => t == [] || t == {} || t == null);\n}\n\nBoard.prototype.can_continue = function (pi) {\n\tlet moves = this.get_moves(pi);\n\t//return !parseInt(Object.values(a).reduce( (j,i) => i.length !== undefined ? i.length + j: j));\n\treturn !moves.every(t => t == [] || t == {} || t == null);\n}\n\n//Player has no more moves when (1): all player's pieces are dead (2): every piece has no moves\nBoard.prototype.has_moves = function (player) {\n\tfor(let pi=0; pi < this.pieces.length; pi++) {\n\t\tlet p = this.pieces[pi];\n\t\tif(p.alive && p.player == player) {\n\t\t\tif(this.can_continue(pi)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nBoard.prototype.valid_move = function (pi, row, col) {\n\tlet m = this.get_moves(pi); //** this.board[row][col].highlight\n\tlet moves = [];\n\tmoves = moves.concat(m.phase, m.adjs, m.jumps, m.leaps);\n\t\tfor (let type in moves) {\n\t\t\tfor (let move of type) {\n\t\t\t\tif (move.row == row && move.col == col) return true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\n\nmodule.exports = Board;\n"]},"metadata":{},"sourceType":"module"}