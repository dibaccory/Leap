{"ast":null,"code":"import { cellType, phaseLayouts } from './util';\n/*\n\nREFACTOR CHANGES:\nLeap.js -> Game.js\n\t<Leap> -> <GameController>\nboard.js -> leap.js\n\n\nBITWISE:\n\nBOARD:\nbit\t\t\t\titem\n0-1\t\t\t\tcellType\t{regular, phase} x {highlight, no highlight}\n2-3\t\t\tcellState\t\t{00: empty, 10: SPECIAL, 01: p1, 11: p2, }   NOTE, if '10' for bits 1 and 2, then it should be a SPECIAL THING???  lmao what if a piece can be moved by either player for a few turns?\n4\t\t\t\t\tisCloned\n5-9\t\t\t\tkey\t\t\t\tIf piece on cell, this is index to reach it\n\nboard[i] = (key << 4 | isCloned << 3 | cellState << 1 | cellType);\nfor i = row * SIZE + col \t\twhere row, col wtr a given piece\n\nPIECE INDEX:\nbit \t\t\titem\n0-2\t\t\t\tcol\n3-(5,6)\t\trow\n\nboard[i] = (row << 4 | col);\nfor i = SIZE*SIZE + key\t\t\twhere\n\n\nhow to store moves\nmoves[i] = [ 0 <= board_index < SIZE*SIZE, ... , ... ] all possible moves for associated piece.\nfor i = SIZE*SIZE\n\n\nindex = cell number\nkey = piece index\n\n*/\n\nvar BOARD_SIZE, BOARD_AREA, BIT_SIZE, BIT_MAX_PI, BIT_INDEX_SHIFT, BIT_AREA;\n\nfunction getBitShift(b) {\n  return b >> 1 ? 1 + getBitShift(b >> 1) : 1;\n}\n\nfunction Board(len, phaseLayout) {\n  this.p1 = 4;\n  this.p2 = 12;\n  BOARD_SIZE = len;\n  BOARD_AREA = BOARD_SIZE ** 2;\n  BIT_SIZE = 2 ** getBitShift(BOARD_SIZE - 1);\n  BIT_MAX_PI = 2 * BIT_SIZE;\n  BIT_INDEX_SHIFT = getBitShift(BOARD_AREA - 1);\n  BIT_AREA = 2 ** BIT_INDEX_SHIFT;\n  (this.board = []).length = BOARD_AREA + 4 * len;\n  (this.moves = []).length = 4 * len;\n  this.board.fill(0, 0, BOARD_AREA - 1);\n  this.bufferSize = 1; //how many rows between the pieces' starting location and the nearest phases\n\n  this.init(phaseLayout); //this.update();\n}\n\nBoard.prototype.init = function (layout) {\n  let pi = 0; //piece Index (ID)\n\n  const len = BOARD_SIZE;\n\n  const calcPhases = index => {\n    let k = 0;\n\n    while (k < phaseLayouts[layout].length) {\n      if ((index ^ phaseLayouts[layout][k]) === 0) return 1;\n      k++;\n    }\n\n    return 0;\n  };\n\n  this.clearMoves();\n\n  for (let i = 0; i < len; i++) {\n    this.board[i] = pi << 5 | this.p1; //00000 0 01 00\n\n    this.initPiece(pi, i);\n    this.board[i + (len - 1) * len] = pi + BIT_MAX_PI << 5 | this.p2; //100000 0 11 00\n\n    this.initPiece(pi + BIT_MAX_PI, i + (len - 1) * len);\n    pi++;\n\n    for (let j = 1 + this.bufferSize; j < len - 1 - this.bufferSize; j++) {\n      this.board[i + j * len] |= calcPhases(i + j * len);\n    }\n  }\n};\n\nBoard.prototype.initPiece = function (pi, index) {\n  this.board[BOARD_AREA + pi] = index;\n};\n\nBoard.prototype.clearMoves = function (pi) {\n  if (pi !== undefined) {\n    this.moves[pi] = [];\n    return;\n  }\n\n  for (let i = 0; i < 4 * BOARD_SIZE; i++) this.moves[i] = [];\n}; // moves[pi] = [0000000 0000000] --> [board index of captured piece + board index of destination cell]\n\n\nBoard.prototype.addMove = function (from, to, captured) {\n  captured = captured || 0;\n  const pi = this.board[from] >> 5;\n  this.moves[pi].push((captured << BIT_INDEX_SHIFT) + to);\n};\n\nBoard.prototype.isRedundantMove = function (from, to) {\n  const pi = this.board[from] >> 5;\n  const n = this.moves[pi].length;\n\n  for (let i = 0; i < n; i++) {\n    if ((this.moves[pi][i] & BIT_AREA - 1) === to) return true;\n  }\n\n  return false;\n};\n\nBoard.prototype.getPlayer = function (index) {\n  const pid = this.board[index] & 12;\n\n  switch (pid) {\n    case 12:\n      return this.p2;\n\n    case 4:\n      return this.p1;\n\n    default:\n      return 0;\n  } //return ( (this.board[index] & 12) < 12 ) ? this.p1 : this.p2;\n\n};\n\nBoard.prototype.getCapturedPiece = function (pid, to) {\n  let nMoves = this.moves[pid].length;\n\n  for (let i = 0; i < nMoves; i++) {\n    let move = this.moves[pid][i];\n    let capturedPiece = move >> BIT_INDEX_SHIFT;\n    if ((move & BIT_AREA - 1) === to && capturedPiece) return capturedPiece;\n  }\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n//Assume special tiles won't appear on spawn rows\n\n\nBoard.prototype.makeClone = function (from, to) {\n  const player = this.getPlayer(from);\n  const c = player === 12 ? BIT_MAX_PI : 0;\n  let ci; //Find first empty slot\n\n  for (ci = BOARD_SIZE + c; ci < 2 * BOARD_SIZE + c; ci++) {\n    if (this.board[BOARD_AREA + ci] === undefined) {\n      this.board[BOARD_AREA + ci] = to;\n      this.board[to] = ci << 5 | player | 16;\n      this.board[from] |= 16;\n      break;\n    }\n  }\n};\n\nBoard.prototype.onCloningCell = function (from) {\n  const onRow = from / BOARD_SIZE,\n        piece = this.board[from];\n  const onBoundaryColumn = (from + 1) % BOARD_SIZE < 2;\n  const onBoundaryRow = (onRow + 1) % BOARD_SIZE < 2; //To clone: NOT be on boundary column, BE on boundary row, NOT be cloned yet\n\n  if (onBoundaryColumn || !onBoundaryRow || piece & 16) return false;\n  const spawnRow = piece >> 5 & BIT_MAX_PI ? BOARD_SIZE - 1 : 0;\n  return onRow ^ spawnRow;\n}; //Assumes valid move\n\n\nBoard.prototype.isCloneMove = function (from, to) {\n  //if on cloning cell, suffice to show if destination is on spawn row\n  const spawnRow = this.board[from] >> 5 & BIT_MAX_PI ? BOARD_SIZE - 1 : 0;\n  return this.onCloningCell(from) && Math.floor(to / BOARD_SIZE) === spawnRow;\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVE LOGIC\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n// Board.prototype.getPlayer = function (pi) {\n// \treturn this.pieces[pi].player;\n// }\n\n\nBoard.prototype.canLeap = function (from, adj, isPhase, bypassCondition) {\n  let to = this.getInverseIndex(from);\n\n  if (!this.getPlayer(to)) {\n    let inv = this.getInverseIndex(adj);\n    let phaseAdj = this.getPlayer(adj) & 4;\n    let phaseFar = this.getPlayer(inv) & 4;\n\n    if (phaseAdj ^ phaseFar) {\n      if (bypassCondition % 3) return true;\n      let captured = phaseAdj ? adj : inv;\n      this.addMove(from, to, captured);\n    }\n  } //if neighbor cell is a phase, leap_cell clear, and (enemy piece on phaseAdj XOR enemy piece on phaseFar)\n\n};\n\nBoard.prototype.isJump = function (from, adj, direction, bypassCondition) {\n  //if adj cell occupied, jumpCell in bounds, jumpCell clear, and jumpCell has enemy piece\n  let to = adj + direction;\n\n  if (this.inBounds(to)) {\n    if (!this.getPlayer(to)) {\n      if (bypassCondition % 3) return true;else this.addMove(from, to, adj);\n    }\n  }\n};\n\nBoard.prototype.canPhase = function (from, to, bypassCondition) {\n  let isPhase = this.board[to] & 1;\n  let isDestinationEmpty = this.board[from] & 3; //1 if player piece\n\n  if (isPhase && isDestinationEmpty) {\n    if (bypassCondition % 3) return true;else this.addMove(from, to);\n  }\n}; //reaching this function implies selected piece can be cloned, so piece is on a bounding row\n\n\nBoard.prototype.getSpawnCells = function (from, bypassCondition) {\n  const spawnRow = from / BOARD_SIZE ^ BOARD_SIZE - 1;\n\n  for (let col = 1; col < BOARD_SIZE - 1; col++) {\n    let to = spawnRow * BOARD_SIZE + col;\n    let spawnCellEmpty = !(this.board[to] & 4); //if spawnCell doesn't have a player on it\n\n    if (spawnCellEmpty) {\n      if (bypassCondition % 3) return true;else this.addMove(from, to);\n    }\n  }\n};\n\nBoard.prototype.getMovesInDirection = function (from, adj, bypassCondition) {\n  //check adjacent cells of piece p wrt the boundary\n  let direction = adj - from;\n  let isPhase = this.board[adj] & 1;\n  if (isPhase && this.canLeap(from, adj, isPhase, bypassCondition)) return true;\n\n  if (this.getPlayer(adj)) {\n    if (this.isJump(from, adj, direction, bypassCondition)) return true;\n  } else if (bypassCondition % 3 % 2) return bypassCondition % 2; //adjacent moves\n  else if (!bypassCondition) this.addMove(from, adj);\n\n  return false;\n};\n/* bypassCondition (HIGHLIGHT BYPASS CONDITION):\n\t\tundefined - default (Store all),\n\t\t1 - bypass any,\n\t\t2 - bypass continuable moves,\n\t\t3 - store continuable moves\n*/\n\n\nBoard.prototype.getMoves = function (from, bypassCondition, direction) {\n  // move continuation AND has a move in specified direction\n  if (direction && this.inBounds(from + direction)) {\n    if (this.getMovesInDirection(from, from + direction, bypassCondition)) return true;\n  } else if (bypassCondition === undefined || bypassCondition % 3) {\n    //step, jump, leap\n    for (let r = -1; r < 2; r++) for (let c = -1; c < 2; c++) {\n      //from + (-8) + (-1) ... from + (8) + 1\n      let adj = from + r * BOARD_SIZE + c;\n      let validDirection = this.getPlayer(adj) ^ this.getPlayer(from) && //enemy or empty cell\n      this.inBounds(adj) && adj - from;\n      if (validDirection && this.getMovesInDirection(from, adj, bypassCondition)) return true;\n    }\n  } // on a phase\n\n\n  if (!this.isRedundantMove(from, this.getInverseIndex(from)) && this.canPhase(from, this.getInverseIndex(from), bypassCondition)) return true; // able to clone\n\n  if (!(this.board[from] & 16) && this.onCloningCell(from) && this.getSpawnCells(from, bypassCondition)) return true;\n  return false;\n}; //Performs move. returns true if caught piece in process, else false\n//NOTE: it is impossible to capture a piece at board index 0\n\n\nBoard.prototype.doMove = function (from, to) {\n  if (this.isCloneMove(from, to)) {\n    this.makeClone(from, to);\n    this.removeHighlight();\n    this.clearMoves();\n    return;\n  }\n\n  const pi = this.board[from] >> 5;\n  const piece = pi << 5 | this.board[from] & 16 | this.getPlayer(from);\n\n  if ((this.board[to] & 12) === 8) {\n    //SPECIAL PIECE *any player can move.... but how is TODO*\n    this.board[to] |= pi << 5;\n  } else {\n    //We can assume this cell is empty\n    this.board[to] |= piece;\n  }\n\n  const capturedPiece = this.getCapturedPiece(pi, to);\n  let direction;\n\n  if (capturedPiece) {\n    const ci = this.board[capturedPiece] >> 5;\n    this.board[capturedPiece] &= 3;\n    this.board[BOARD_AREA + ci] = ~this.board[BOARD_AREA + ci]; //He DED\n\n    const capturedDirection = this.inBounds(to - captured, -9, 9) ? to - captured : captured - from; //if can continue move in direction\n\n    if (this.inBounds(capturedDirection) && this.getMovesInDirection(to, capturedDirection, 2)) {\n      direction = to - capturedPiece;\n    }\n  }\n\n  const onPhase = this.board[to] & 1;\n  const phased = this.isPhaseMove(from, to);\n  const isLeap = capturedPiece && phased;\n  const yetToPhase = onPhase && !phased;\n  const canClone = this.onCloningCell(to) && !this.onCloningCell(from) && this.getSpawnCells(to, 2); //If can clone or is on phase that piece hasn't just travelled through\n\n  if (!direction && (canClone || isLeap || yetToPhase)) direction = 0;\n  this.board[from] &= 3; //keep only cell data\n\n  this.board[BOARD_AREA + pi] = to;\n  this.removeHighlight();\n  this.clearMoves();\n  return direction;\n};\n\nBoard.prototype.highlightMoves = function (piece) {\n  const nMoves = this.moves[piece].length;\n\n  for (let i = 0; i < nMoves; i++) {\n    let to = this.moves[piece][i] & BIT_AREA - 1;\n    this.board[to] |= 2;\n  }\n};\n\nBoard.prototype.isPhaseMove = function (from, to) {\n  const bothPhases = this.board[from] & this.board[to] & 1;\n  return bothPhases && this.getInverseIndex(from) === to;\n};\n\nBoard.prototype.removeHighlight = function () {\n  for (let i = 0; i < BOARD_AREA; i++) {\n    if (this.board[i] & 2) this.board[i] = this.board[i] ^ 2;\n  }\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tINTEGRITY\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n//ONLY WORKS on NxN boards and phase group orders of 2\n\n\nBoard.prototype.getInverseIndex = function (index) {\n  return BOARD_AREA - 1 - index;\n};\n\nBoard.prototype.inBounds = function (index, start, end) {\n  start = start || 0;\n  end = end || BOARD_AREA;\n  return start <= index && index < end;\n};\n\nBoard.prototype.canContinueMove = function (from, direction) {\n  return direction !== undefined ? this.getMoves(from, 2, from + direction) : false;\n};\n\nBoard.prototype.hasMoves = function (piece) {\n  return this.getMoves(piece, 1);\n}; //Player has no more moves when (1): all player's pieces are dead (2): every piece has no moves\n\n\nBoard.prototype.movesLeft = function (player) {\n  const c = player === 12 ? BIT_MAX_PI : 0;\n\n  for (let pi = c; pi < 2 * BOARD_SIZE + c; pi++) {\n    let piece = this.board[BOARD_AREA + pi];\n    if (!(piece < 0 || piece === undefined) && this.getMoves(piece, 1)) return true;\n  }\n\n  return false;\n};\n\nBoard.prototype.validMove = function (piece, index) {\n  const n = this.moves[piece].length;\n  let isAvailableMove = 0;\n\n  for (let i = 0; i < n; i++) {\n    if ((this.moves[piece][i] & BIT_AREA - 1) === index) isAvailableMove++;\n  }\n\n  return !!isAvailableMove;\n};\n\nexport default Board;","map":{"version":3,"sources":["/Users/bacchus/git/Leap/src/js/board.js"],"names":["cellType","phaseLayouts","BOARD_SIZE","BOARD_AREA","BIT_SIZE","BIT_MAX_PI","BIT_INDEX_SHIFT","BIT_AREA","getBitShift","b","Board","len","phaseLayout","p1","p2","board","length","moves","fill","bufferSize","init","prototype","layout","pi","calcPhases","index","k","clearMoves","i","initPiece","j","undefined","addMove","from","to","captured","push","isRedundantMove","n","getPlayer","pid","getCapturedPiece","nMoves","move","capturedPiece","makeClone","player","c","ci","onCloningCell","onRow","piece","onBoundaryColumn","onBoundaryRow","spawnRow","isCloneMove","Math","floor","canLeap","adj","isPhase","bypassCondition","getInverseIndex","inv","phaseAdj","phaseFar","isJump","direction","inBounds","canPhase","isDestinationEmpty","getSpawnCells","col","spawnCellEmpty","getMovesInDirection","getMoves","r","validDirection","doMove","removeHighlight","capturedDirection","onPhase","phased","isPhaseMove","isLeap","yetToPhase","canClone","highlightMoves","bothPhases","start","end","canContinueMove","hasMoves","movesLeft","validMove","isAvailableMove"],"mappings":"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","sourcesContent":["import {cellType, phaseLayouts} from './util';\n/*\n\nREFACTOR CHANGES:\nLeap.js -> Game.js\n\t<Leap> -> <GameController>\nboard.js -> leap.js\n\n\nBITWISE:\n\nBOARD:\nbit\t\t\t\titem\n0-1\t\t\t\tcellType\t{regular, phase} x {highlight, no highlight}\n2-3\t\t\tcellState\t\t{00: empty, 10: SPECIAL, 01: p1, 11: p2, }   NOTE, if '10' for bits 1 and 2, then it should be a SPECIAL THING???  lmao what if a piece can be moved by either player for a few turns?\n4\t\t\t\t\tisCloned\n5-9\t\t\t\tkey\t\t\t\tIf piece on cell, this is index to reach it\n\nboard[i] = (key << 4 | isCloned << 3 | cellState << 1 | cellType);\nfor i = row * SIZE + col \t\twhere row, col wtr a given piece\n\nPIECE INDEX:\nbit \t\t\titem\n0-2\t\t\t\tcol\n3-(5,6)\t\trow\n\nboard[i] = (row << 4 | col);\nfor i = SIZE*SIZE + key\t\t\twhere\n\n\nhow to store moves\nmoves[i] = [ 0 <= board_index < SIZE*SIZE, ... , ... ] all possible moves for associated piece.\nfor i = SIZE*SIZE\n\n\nindex = cell number\nkey = piece index\n\n*/\nvar BOARD_SIZE, BOARD_AREA, BIT_SIZE, BIT_MAX_PI, BIT_INDEX_SHIFT, BIT_AREA;\n\nfunction getBitShift(b) {\n  return (b >> 1) ? (1 + getBitShift(b >> 1)) : 1;\n}\n\n\nfunction Board(len, phaseLayout) {\n\n\tthis.p1 = 4;\n\tthis.p2 = 12;\n\n\tBOARD_SIZE = len;\n\tBOARD_AREA = BOARD_SIZE**2;\n\tBIT_SIZE = 2**getBitShift(BOARD_SIZE-1);\n\tBIT_MAX_PI = 2*BIT_SIZE;\n\tBIT_INDEX_SHIFT = getBitShift(BOARD_AREA-1);\n\tBIT_AREA = 2**BIT_INDEX_SHIFT;\n\n\n\n\t(this.board = []).length = BOARD_AREA + 4*len;\n\t(this.moves = []).length = 4*len;\n\tthis.board.fill(0, 0, BOARD_AREA-1);\n\tthis.bufferSize = 1;\t//how many rows between the pieces' starting location and the nearest phases\n\tthis.init(phaseLayout);\n\t//this.update();\n}\n\n\n\nBoard.prototype.init = function (layout) {\n    let pi=0; //piece Index (ID)\n\t\tconst len = BOARD_SIZE;\n\n\t\tconst calcPhases = (index) => {\n\t\t\tlet k = 0;\n\t\t\twhile(k<phaseLayouts[layout].length) {\n\t\t\t\tif ( (index^phaseLayouts[layout][k]) === 0 ) return 1;\n\t\t\t\tk++;\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\t\tthis.clearMoves();\n\t\tfor(let i=0; i<len; i++) {\n\t\t\tthis.board[i] = ( (pi << 5) | this.p1); //00000 0 01 00\n\t\t\tthis.initPiece(pi, i);\n\n\t\t\tthis.board[i + (len-1)*len] = ( (pi + BIT_MAX_PI << 5) | this.p2); //100000 0 11 00\n\t\t\tthis.initPiece(pi + BIT_MAX_PI, i + (len-1)*len);\n\n\n\t\t\tpi++;\n\n\t\t\tfor(let j=1+this.bufferSize; j<len-1-this.bufferSize; j++) {\n\t\t\t\tthis.board[i + j*len] |= calcPhases(i+j*len);\n\t\t\t}\n\t\t}\n}\n\nBoard.prototype.initPiece = function (pi, index) {\n\tthis.board[BOARD_AREA + pi] = index;\n}\n\nBoard.prototype.clearMoves = function (pi) {\n\tif(pi !== undefined) {\n\t\tthis.moves[pi] = [];\n\t\treturn;\n\t}\n\tfor(let i=0; i<4*BOARD_SIZE; i++) this.moves[i] = [];\n}\n\n// moves[pi] = [0000000 0000000] --> [board index of captured piece + board index of destination cell]\nBoard.prototype.addMove = function (from, to, captured) {\n\tcaptured = captured || 0;\n\tconst pi = (this.board[from] >> 5);\n\tthis.moves[pi].push( (captured << (BIT_INDEX_SHIFT) ) + to );\n}\n\nBoard.prototype.isRedundantMove = function (from, to) {\n\tconst pi = (this.board[from] >> 5);\n\tconst n = this.moves[pi].length;\n\tfor(let i=0; i<n; i++) {\n\t\tif ( (this.moves[pi][i] & (BIT_AREA-1)) === to ) return true;\n\t}\n\treturn false;\n}\n\nBoard.prototype.getPlayer = function (index) {\n\tconst pid = (this.board[index] & 12);\n\tswitch (pid) {\n\t\tcase 12:\n\t\t\treturn this.p2;\n\t\tcase 4:\n\t\t\treturn this.p1;\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n\t//return ( (this.board[index] & 12) < 12 ) ? this.p1 : this.p2;\n}\n\nBoard.prototype.getCapturedPiece = function (pid, to) {\n\tlet nMoves = this.moves[pid].length;\n\tfor(let i=0; i< nMoves; i++) {\n\t\tlet move = this.moves[pid][i];\n\t\tlet capturedPiece = move >> (BIT_INDEX_SHIFT);\n\t\tif( (move & (BIT_AREA - 1)) === to  && capturedPiece) return capturedPiece;\n\t}\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n//Assume special tiles won't appear on spawn rows\nBoard.prototype.makeClone = function (from, to) {\n\tconst player = this.getPlayer(from);\n\tconst c = (player === 12) ? BIT_MAX_PI : 0;\n\tlet ci;\n\t//Find first empty slot\n\tfor(ci= BOARD_SIZE+c; ci< 2*BOARD_SIZE+c; ci++) {\n\t\tif(this.board[BOARD_AREA + ci] === undefined) {\n\t\t\tthis.board[BOARD_AREA + ci] = to;\n\t\t\tthis.board[to] = (ci << 5) | player | 16;\n\t\t\tthis.board[from] |= 16;\n\t\t\tbreak;\n\t\t}\n\t}\n\n}\n\n\nBoard.prototype.onCloningCell = function (from) {\n\tconst onRow = from/BOARD_SIZE, piece = this.board[from];\n\tconst onBoundaryColumn = (from+1)%BOARD_SIZE < 2;\n\tconst onBoundaryRow = (onRow + 1)%BOARD_SIZE < 2;\n\n\t//To clone: NOT be on boundary column, BE on boundary row, NOT be cloned yet\n\tif(onBoundaryColumn || !onBoundaryRow || (piece & 16) ) return false;\n\n\tconst spawnRow = ( (piece >> 5) & BIT_MAX_PI ) ? (BOARD_SIZE-1) : 0;\n\treturn (onRow ^ spawnRow);\n}\n//Assumes valid move\nBoard.prototype.isCloneMove = function (from, to) {\n\t//if on cloning cell, suffice to show if destination is on spawn row\n\tconst spawnRow = ( (this.board[from] >> 5) & BIT_MAX_PI ) ? (BOARD_SIZE - 1) : 0;\n\treturn this.onCloningCell(from) && (Math.floor(to/BOARD_SIZE) === spawnRow);\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVE LOGIC\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n// Board.prototype.getPlayer = function (pi) {\n// \treturn this.pieces[pi].player;\n// }\n\nBoard.prototype.canLeap = function (from, adj, isPhase, bypassCondition) {\n\tlet to = this.getInverseIndex(from);\n\tif( !(this.getPlayer(to)) ) {\n\t\tlet inv = this.getInverseIndex(adj);\n\t\tlet phaseAdj = this.getPlayer(adj) & 4;\n\t\tlet phaseFar = this.getPlayer(inv) & 4;\n\n\t\tif( (phaseAdj ^ phaseFar) ) {\n\t\t\tif (bypassCondition%3) return true;\n\t\t\tlet captured = phaseAdj ? adj : inv;\n\t\t\tthis.addMove(from, to, captured);\n\t\t}\n\t}\n\t//if neighbor cell is a phase, leap_cell clear, and (enemy piece on phaseAdj XOR enemy piece on phaseFar)\n}\n\nBoard.prototype.isJump = function (from, adj, direction, bypassCondition) {\n\t//if adj cell occupied, jumpCell in bounds, jumpCell clear, and jumpCell has enemy piece\n\tlet to = adj+direction;\n\tif(this.inBounds(to)) {\n\t\tif (!this.getPlayer(to)) {\n\t\t\tif(bypassCondition%3) return true;\n\t\t\telse this.addMove(from, to, adj);\n\t\t}\n\t}\n}\n\nBoard.prototype.canPhase = function (from, to, bypassCondition) {\n\tlet isPhase = (this.board[to] & 1);\n\tlet isDestinationEmpty = (this.board[from] & 3); //1 if player piece\n\tif(isPhase && isDestinationEmpty) {\n\t\tif (bypassCondition%3) return true;\n\t\telse this.addMove(from, to);\n\t}\n}\n\n//reaching this function implies selected piece can be cloned, so piece is on a bounding row\nBoard.prototype.getSpawnCells = function (from, bypassCondition) {\n\tconst spawnRow = ( from/BOARD_SIZE ^ (BOARD_SIZE-1) );\n\tfor(let col=1; col<BOARD_SIZE-1;col++) {\n\t\tlet to = spawnRow*BOARD_SIZE + col;\n\t\tlet spawnCellEmpty = !(this.board[to] & 4);\n\n\t\t//if spawnCell doesn't have a player on it\n\t\tif (spawnCellEmpty) {\n\t\t\tif (bypassCondition%3) return true;\n\t\t\telse this.addMove(from, to);\n\t\t}\n\t}\n}\n\nBoard.prototype.getMovesInDirection = function (from, adj, bypassCondition) {\n\t//check adjacent cells of piece p wrt the boundary\n\tlet direction = adj - from;\n\tlet isPhase = this.board[adj] & 1;\n\n\tif (isPhase && this.canLeap(from, adj, isPhase, bypassCondition)) return true;\n\n\tif( this.getPlayer(adj) ) {\n\t\tif (this.isJump(from, adj, direction, bypassCondition)) return true;\n\t}\n\telse if (bypassCondition%3%2) return bypassCondition%2;\t//adjacent moves\n\telse if (!bypassCondition) this.addMove(from, adj);\n\treturn false;\n}\n\n/* bypassCondition (HIGHLIGHT BYPASS CONDITION):\n\t\tundefined - default (Store all),\n\t\t1 - bypass any,\n\t\t2 - bypass continuable moves,\n\t\t3 - store continuable moves\n*/\nBoard.prototype.getMoves = function (from, bypassCondition, direction) {\n\t// move continuation AND has a move in specified direction\n\tif (direction && this.inBounds(from+direction)) {\n\t\tif( this.getMovesInDirection(from, from+direction, bypassCondition) ) return true;\n\t} else if(bypassCondition === undefined || bypassCondition%3){\n\t\t//step, jump, leap\n\t\tfor(let r=-1;r<2;r++) for(let c=-1;c<2; c++) { //from + (-8) + (-1) ... from + (8) + 1\n\t\t\tlet adj = from + (r*BOARD_SIZE) + c;\n\t\t\tlet validDirection = ( this.getPlayer(adj) ^ this.getPlayer(from) ) //enemy or empty cell\n\t\t\t\t&& this.inBounds(adj) && (adj-from);\n\t\t\tif (validDirection && this.getMovesInDirection(from, adj, bypassCondition)) return true;\n\t\t}\n\t}\n\t// on a phase\n\tif (!this.isRedundantMove(from, this.getInverseIndex(from))\n\t&& this.canPhase(from, this.getInverseIndex(from), bypassCondition)) return true;\n\t// able to clone\n\tif (!(this.board[from] & 16) && this.onCloningCell(from)\n\t&& this.getSpawnCells(from, bypassCondition)) return true;\n\n\treturn false;\n}\n\n//Performs move. returns true if caught piece in process, else false\n//NOTE: it is impossible to capture a piece at board index 0\nBoard.prototype.doMove = function (from, to) {\n\n\tif(this.isCloneMove(from, to)) {\n\t\tthis.makeClone(from, to);\n\t\tthis.removeHighlight();\n\t\tthis.clearMoves();\n\t\treturn;\n\t}\n\n\tconst pi = this.board[from] >> 5;\n\tconst piece = (pi << 5) | (this.board[from] & 16) | this.getPlayer(from);\n\n\tif( (this.board[to] & 12) === 8 ) {\n\t\t//SPECIAL PIECE *any player can move.... but how is TODO*\n\t\tthis.board[to] |= (pi << 5);\n\t} else {\n\t\t//We can assume this cell is empty\n\t\tthis.board[to] |= piece;\n\t}\n\n\n\tconst capturedPiece = this.getCapturedPiece(pi, to);\n\tlet direction;\n\tif(capturedPiece) {\n\t\tconst ci = this.board[capturedPiece] >> 5;\n\t\tthis.board[capturedPiece] &= 3;\n\t\tthis.board[BOARD_AREA + ci] = ~this.board[BOARD_AREA + ci]; //He DED\n\n\t\tconst capturedDirection = this.inBounds(to - captured, -9, 9) ? to - captured : captured - from;\n\t\t//if can continue move in direction\n\t\tif( this.inBounds(capturedDirection) && this.getMovesInDirection(to, capturedDirection, 2) ) {\n\t\t\tdirection = to - capturedPiece;\n\t\t}\n\t}\n\tconst onPhase = this.board[to] & 1;\n\tconst phased = this.isPhaseMove(from, to);\n\tconst isLeap = capturedPiece && phased;\n\tconst yetToPhase = onPhase && !phased;\n\tconst canClone = (this.onCloningCell(to) && !this.onCloningCell(from) && this.getSpawnCells(to, 2));\n\t//If can clone or is on phase that piece hasn't just travelled through\n\tif ( !direction && ( canClone || isLeap || yetToPhase ) ) direction = 0;\n\n\tthis.board[from] &= 3; //keep only cell data\n\tthis.board[BOARD_AREA + pi] = to;\n\n\tthis.removeHighlight();\n\tthis.clearMoves();\n\n\treturn direction;\n}\n\nBoard.prototype.highlightMoves = function (piece) {\n\tconst nMoves = this.moves[piece].length;\n\tfor(let i=0; i<nMoves; i++) {\n\t\tlet to = ( this.moves[piece][i] & (BIT_AREA - 1) );\n\t\tthis.board[to] |= 2;\n\t}\n}\n\nBoard.prototype.isPhaseMove = function (from, to) {\n\tconst bothPhases = (this.board[from] & this.board[to]) & 1;\n\treturn (bothPhases) && this.getInverseIndex(from) === to;\n}\n\n\nBoard.prototype.removeHighlight = function () {\n\tfor(let i=0; i<BOARD_AREA; i++) {\n\t\tif(this.board[i] & 2) (this.board[i] = this.board[i] ^ 2);\n\t}\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tINTEGRITY\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n//ONLY WORKS on NxN boards and phase group orders of 2\nBoard.prototype.getInverseIndex = function (index) {\n\treturn (BOARD_AREA - 1) - index;\n}\n\nBoard.prototype.inBounds = function (index, start, end) {\n\tstart = start || 0;\n\tend = end || BOARD_AREA;\n\treturn start <= index && index < end;\n}\n\nBoard.prototype.canContinueMove = function (from, direction) {\n\treturn direction !== undefined ? this.getMoves(from, 2, from+direction) : false;\n}\n\nBoard.prototype.hasMoves = function (piece) {\n\treturn this.getMoves(piece, 1);\n}\n\n//Player has no more moves when (1): all player's pieces are dead (2): every piece has no moves\nBoard.prototype.movesLeft = function (player) {\n\tconst c = (player === 12) ? BIT_MAX_PI : 0;\n\tfor(let pi=c; pi < 2*BOARD_SIZE + c; pi++) {\n\n\t\tlet piece = this.board[BOARD_AREA + pi];\n\t\tif ( !(piece < 0 || piece === undefined) && this.getMoves(piece, 1)) return true;\n\t}\n\treturn false;\n}\n\nBoard.prototype.validMove = function (piece, index) {\n\tconst n = this.moves[piece].length;\n\tlet isAvailableMove = 0;\n\tfor(let i=0; i<n; i++) {\n\t\tif ( (this.moves[piece][i] & (BIT_AREA - 1)) === index ) isAvailableMove++;\n\t}\n\treturn !!(isAvailableMove);\n}\n\nexport default Board;\n"]},"metadata":{},"sourceType":"module"}