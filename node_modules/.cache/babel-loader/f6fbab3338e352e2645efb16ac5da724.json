{"ast":null,"code":"import _objectSpread from \"/Users/bacchus/git/Leap/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\n//'use strict';\nimport { phaseLayouts } from './util';\nvar BOARD_SIZE, BOARD_AREA, BIT_SIZE, BIT_MAX_PI, BIT_INDEX_SHIFT, BIT_AREA;\nconst PLAYER_ONE = 4;\nconst PLAYER_TWO = 12;\n\nfunction getBitShift(b) {\n  return b >> 1 ? 1 + getBitShift(b >> 1) : 1;\n}\n\nfunction Leap(player, len, phaseLayout) {\n  //no args passed mean it will be a copy.\n  if (player) {\n    this.turn = player;\n    BOARD_SIZE = len;\n    BOARD_AREA = BOARD_SIZE ** 2;\n    BIT_SIZE = 2 ** getBitShift(BOARD_SIZE - 1);\n    BIT_MAX_PI = 2 * BIT_SIZE;\n    BIT_INDEX_SHIFT = getBitShift(BOARD_AREA - 1);\n    BIT_AREA = 2 ** BIT_INDEX_SHIFT;\n    this.init(phaseLayout);\n  }\n}\n\nLeap.prototype.init = function (layout) {\n  this.pAmount = {\n    [PLAYER_ONE]: BOARD_SIZE,\n    [PLAYER_TWO]: BOARD_SIZE\n  };\n  this.continuedMove = false;\n  (this.board = []).length = BOARD_AREA + 4 * BOARD_SIZE;\n  (this.moves = []).length = 4 * BOARD_SIZE;\n  this.board.fill(0, 0, BOARD_AREA - 1);\n  this.bufferSize = 1; //how many rows between the pieces' starting location and the nearest phases\n\n  let pi = 0; //piece Index (ID)\n\n  const lastRow = (BOARD_SIZE - 1) * BOARD_SIZE;\n\n  const calcPhases = index => {\n    let k = 0;\n\n    while (k < phaseLayouts[layout].length) {\n      if (index === phaseLayouts[layout][k]) return 1;\n      k++;\n    }\n\n    return 0;\n  };\n\n  this.clearMoves();\n\n  for (let i = 0; i < BOARD_SIZE; i++) {\n    this.board[i] = pi << 5 | PLAYER_ONE; //00000 0 01 00\n\n    this.initPiece(pi, i);\n    this.board[i + lastRow] = pi + BIT_MAX_PI << 5 | PLAYER_TWO; //100000 0 11 00\n\n    this.initPiece(pi + BIT_MAX_PI, i + lastRow);\n    pi++;\n\n    for (let j = 1 + this.bufferSize; j < BOARD_SIZE - 1 - this.bufferSize; j++) {\n      this.board[i + j * BOARD_SIZE] |= calcPhases(i + j * BOARD_SIZE);\n    }\n  }\n};\n\nLeap.prototype.initPiece = function (key, index) {\n  this.board[BOARD_AREA + key] = index;\n};\n\nLeap.prototype.copy = function () {\n  const board = new Leap();\n  const n = BOARD_AREA + 4 * BOARD_SIZE;\n  (board.board = []).length = n;\n  (board.moves = []).length = this.moves.length; //copy over the board info (including piece directory)\n\n  board.board = [...this.board];\n  board.turn = this.turn;\n  board.continuedMove = this.continuedMove;\n  board.pAmount = _objectSpread({}, this.pAmount);\n  board.clearMoves();\n  return board;\n};\n\nLeap.prototype.set = function (board) {\n  this.board = board.board;\n  this.turn = board.turn;\n  this.continuedMove = board.continuedMove;\n  this.pAmount = board.pAmount;\n  this.moves = board.moves;\n  return this;\n}; // moves[pi] = [0000000 0000000] --> [board index of captured piece + board index of destination cell]\n\n\nLeap.prototype.addMove = function (from, to, captured) {\n  captured = captured || 0;\n  const pi = this.board[from] >> 5;\n  this.moves[pi].push((captured << BIT_INDEX_SHIFT) + to);\n};\n\nLeap.prototype.clearMoves = function (pi) {\n  if (pi !== undefined) {\n    this.moves[pi] = [];\n    return;\n  }\n\n  for (let i = 0; i < 4 * BOARD_SIZE; i++) this.moves[i] = [];\n};\n\nLeap.prototype.highlightMoves = function (piece) {\n  const nMoves = this.moves[piece].length;\n\n  for (let i = 0; i < nMoves; i++) {\n    let to = this.moves[piece][i] & BIT_AREA - 1;\n    this.board[to] |= 2;\n  }\n};\n\nLeap.prototype.removeHighlight = function () {\n  for (let i = 0; i < BOARD_AREA; i++) {\n    if (this.board[i] & 2) this.board[i] = this.board[i] ^ 2;\n  }\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n//Assume special tiles won't appear on spawn rows\n\n\nLeap.prototype.makeClone = function (from, to) {\n  const player = this.turn;\n  this.pAmount[player]++;\n  const c = player === 12 ? BIT_MAX_PI : 0;\n  let key; //Find first empty slot\n\n  for (key = BOARD_SIZE + c; key < 2 * BOARD_SIZE + c; key++) {\n    if (this.board[BOARD_AREA + key] === undefined) {\n      this.board[BOARD_AREA + key] = to;\n      this.board[to] = key << 5 | player | 16;\n      this.board[from] |= 16;\n      break;\n    }\n  }\n};\n\nLeap.prototype.onCloningCell = function (from) {\n  const onRow = from / BOARD_SIZE;\n  const piece = this.board[from];\n  const onBoundaryColumn = (from + 1) % BOARD_SIZE < 2;\n  const onBoundaryRow = (onRow + 1) % BOARD_SIZE < 2; //To clone: NOT be on boundary column, BE on boundary row, NOT be cloned yet\n\n  if (onBoundaryColumn || !onBoundaryRow || piece & 16) return false;\n  const spawnRow = piece >> 5 & BIT_MAX_PI ? BOARD_SIZE - 1 : 0;\n  return onRow ^ spawnRow;\n}; //Assumes valid move\n\n\nLeap.prototype.isCloneMove = function (from, to) {\n  //if on cloning cell, suffice to show if destination is on spawn row\n  const spawnRow = this.board[from] >> 5 & BIT_MAX_PI ? BOARD_SIZE - 1 : 0;\n  return this.onCloningCell(from) && Math.floor(to / BOARD_SIZE) === spawnRow;\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVE LOGIC\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n\nLeap.prototype.canLeap = function (from, adj) {\n  const to = this.getInverseIndex(from); //DOES NOT CONSIDER SPECIAL PIECE '10'\n\n  if (this.getPlayer(to)) return;\n  const inv = this.getInverseIndex(adj);\n  const phaseAdj = this.getPlayer(adj);\n  const phaseFar = this.getPlayer(inv);\n\n  if ((phaseAdj ^ phaseFar ^ this.turn) === 8) {\n    this.addMove(from, to, phaseAdj ? adj : inv);\n  } //if neighbor cell is a phase, leap_cell clear, and (enemy piece on phaseAdj XOR enemy piece on phaseFar)\n\n};\n\nLeap.prototype.canJump = function (from, direction) {\n  //if adj cell occupied, jumpCell in bounds, jumpCell clear, and jumpCell has enemy piece\n  const adj = from + direction;\n  const to = adj + direction;\n\n  if (this.inBounds(to) && !this.getPlayer(to)) {\n    this.addMove(from, to, adj);\n  }\n};\n\nLeap.prototype.isPhaseMove = function (from, to, captured) {\n  const bothPhases = this.board[from] & this.board[to] & 1;\n  return !captured && bothPhases && this.getInverseIndex(from) === to;\n};\n\nLeap.prototype.canPhase = function (from, to) {\n  const isPhase = this.board[from] & 1;\n  const isDestinationEmpty = !(this.board[to] & 4); //1 if player piece\n\n  if (isPhase && isDestinationEmpty) {\n    this.addMove(from, to);\n  }\n}; //reaching this function implies selected piece can be cloned, so piece is on a bounding row\n\n\nLeap.prototype.getSpawnCells = function (from) {\n  const spawnRow = from / BOARD_SIZE ^ BOARD_SIZE - 1;\n\n  for (let col = 1; col < BOARD_SIZE - 1; col++) {\n    let to = spawnRow * BOARD_SIZE + col;\n    let spawnCellEmpty = !(this.board[to] & 4); //if spawnCell doesn't have a player on it\n\n    if (spawnCellEmpty) this.addMove(from, to);\n  }\n};\n\nLeap.prototype.getMovesInDirection = function (from, direction) {\n  //check adjacent cells of piece p wrt the boundary\n  const adj = from + direction;\n  const isPhase = this.board[adj] & 1;\n  const jumpWithinBounds = Math.abs((adj + direction) % BOARD_SIZE - from % BOARD_SIZE) < 3;\n  if (isPhase) this.canLeap(from, adj);\n\n  if ((this.getPlayer(adj) ^ this.turn) === 8) {\n    if (jumpWithinBounds) this.canJump(from, direction);\n  } else this.addMove(from, adj);\n};\n\nLeap.prototype.getMoves = function (from) {\n  const bCol = (from + 1) % BOARD_SIZE < 2 ? (from + 1) % BOARD_SIZE : undefined;\n\n  for (let r = -1; r < 2; r++) {\n    for (let c = -1 + (bCol === 1 ? 1 : 0); c < 2 - (bCol === 0 ? 1 : 0); c++) {\n      let direction = r * BOARD_SIZE + c;\n      let adj = from + direction;\n      let validDirection = direction && this.getPlayer(adj) ^ this.turn && this.inBounds(adj);\n      if (validDirection) this.getMovesInDirection(from, direction);\n    }\n  }\n\n  const inv = this.getInverseIndex(from); // phase condition\n\n  if (!this.isRedundantMove(from, inv)) this.canPhase(from, inv); // clone condition\n\n  if (!(this.board[from] & 16) && this.onCloningCell(from)) this.getSpawnCells(from);\n};\n\nLeap.prototype.getAllMoves = function (player) {\n  const c = player === 12 ? BIT_MAX_PI : 0;\n  var hasMoves = 0;\n\n  for (let key = c; key < 2 * BOARD_SIZE + c; key++) {\n    let from = this.board[BOARD_AREA + key];\n\n    if (!(from === undefined || from < 0)) {\n      hasMoves++;\n      this.getMoves(from);\n    }\n  }\n\n  return hasMoves;\n}; //Performs move. returns true if enemy runs out of pieces\n\n\nLeap.prototype.doMove = function (from, to) {\n  //CACHE this.board HERE. ITS A VERY HOT FUNCTION lmao (. Y .)\n  if (this.isCloneMove(from, to)) {\n    this.makeClone(from, to);\n    this.removeHighlight();\n    this.clearMoves();\n    this.switchPlayer();\n    this.continuedMove = false;\n    return;\n  }\n\n  const pi = this.board[from] >> 5;\n  const capturedPiece = this.getCapturedPiece(pi, to);\n  this.removeHighlight();\n  this.clearMoves();\n  const piece = pi << 5 | this.board[from] & 16 | this.turn;\n\n  if ((this.board[to] & 12) === 8) {\n    //SPECIAL PIECE *any player can move.... but how is TODO*\n    this.board[to] |= pi << 5;\n  } else {\n    //We can assume this cell is empty\n    this.board[to] |= piece;\n  }\n\n  if (capturedPiece) {\n    const ci = this.board[capturedPiece] >> 5;\n    if (ci < 0) debugger;\n    this.board[capturedPiece] &= 3;\n    this.board[BOARD_AREA + ci] = ~this.board[BOARD_AREA + ci]; //He DED\n\n    if (--this.pAmount[this.turn ^ 8] === 0) return true; //if Leap, then we get the direction by the difference between captured index and adjacent movement cell\n\n    const capturedAdjToDestination = -9 <= to - capturedPiece && to - capturedPiece <= 9;\n    const capturedDirection = capturedAdjToDestination ? to - capturedPiece : capturedPiece - from; //if can continue move in direction\n\n    let adj = to + capturedDirection;\n    if (this.board[adj] & 1) this.canLeap(to, adj);\n    if ((this.getPlayer(adj) ^ this.turn) === 8) this.canJump(to, capturedDirection);\n  }\n\n  this.board[from] &= 3; //keep only cell data\n\n  this.board[BOARD_AREA + pi] = to;\n  const canPhase = this.board[to] & 1 && !this.isPhaseMove(from, to, capturedPiece);\n  const canClone = this.onCloningCell(to) && !this.onCloningCell(from); //If can clone or is on phase that piece hasn't just travelled through\n\n  if (canPhase) this.canPhase(to, this.getInverseIndex(to));\n  if (canClone) this.getSpawnCells(to); //if not a continued move, change player\n\n  if (!this.moves[pi].length) this.switchPlayer();else {\n    this.continuedMove = to;\n    /*debugger;*/\n  }\n  return false;\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tREFERENCES\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n\nLeap.prototype.getPlayer = function (index) {\n  const pid = this.board[index] & 12;\n  return pid === 4 || pid === 12 ? pid : 0;\n}; //NOTE: index 0 can never be captured\n//How to optimize? Well, if moves[pid][i] !< BOARD_AREA, then it must be a capture\n\n\nLeap.prototype.getCapturedPiece = function (pid, to) {\n  const nMoves = this.moves[pid].length;\n\n  for (let i = 0; i < nMoves; i++) {\n    let move = this.moves[pid][i];\n    let capturedPiece = move >> BIT_INDEX_SHIFT;\n    if (capturedPiece >= BOARD_AREA) debugger;\n    if ((move & BIT_AREA - 1) === to && capturedPiece) return capturedPiece;\n  }\n}; //ONLY WORKS on NxN boards and phase group orders of 2\n\n\nLeap.prototype.getInverseIndex = function (index) {\n  return BOARD_AREA - 1 - index;\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tUTILITY\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n\nLeap.prototype.inBounds = function (index) {\n  return 0 <= index && index < BOARD_AREA;\n};\n\nLeap.prototype.switchPlayer = function () {\n  this.turn ^= 8;\n  this.continuedMove = false;\n  return this.turn;\n};\n\nLeap.prototype.isRedundantMove = function (from, to) {\n  const pi = this.board[from] >> 5;\n  const n = this.moves[pi].length;\n\n  for (let i = 0; i < n; i++) {\n    if ((this.moves[pi][i] & BIT_AREA - 1) === to) return true;\n  }\n\n  return false;\n};\n\nLeap.prototype.validMove = function (piece, index) {\n  const n = this.moves[piece].length;\n\n  for (let i = 0; i < n; i++) {\n    if ((this.moves[piece][i] & BIT_AREA - 1) === index) return true;\n  }\n\n  return false;\n}; //not sure how performant this is...\n\n\nLeap.prototype.randomMove = function () {\n  if (!this.continuedMove) {\n    //if no moves, enemy wins\n    if (!this.getAllMoves(this.turn)) return this.turn ^ 8; //There's gotta be a better way to remove undefined indeces\n\n    const moves = _objectSpread({}, this.moves);\n\n    const reducedMoveList = Object.keys(moves).filter(item => moves[item].length).reduce((res, key) => (res[key] = moves[key], res), {});\n    const moveKeys = Object.keys(reducedMoveList);\n    const length = moveKeys.length;\n    const piece = moveKeys[Math.floor(Math.random() * length)];\n    const to = reducedMoveList[piece][Math.floor(Math.random() * reducedMoveList[piece].length)] & BIT_AREA - 1;\n    const from = this.board[BOARD_AREA + parseInt(piece)];\n    return this.doMove(from, to) ? this.turn : 0;\n  } else {\n    this.clearMoves();\n    const from = this.continuedMove;\n    this.getMoves(from);\n    const pi = this.board[from] >> 5;\n    const to = this.moves[pi][Math.floor(Math.random() * this.moves[pi].length)] & BIT_AREA - 1;\n    return this.doMove(from, to) ? this.turn : 0;\n  }\n}; //what should the heuristic be??\n\n\nLeap.prototype.score = function () {\n  let p1 = 0;\n  let p2 = 0;\n\n  const spawnRow = index => index >> 5 & BIT_MAX_PI ? BOARD_SIZE - 1 : 0; //no piece difference...\n\n\n  if (this.pAmount[PLAYER_ONE] - this.pAmount[PLAYER_TWO] === 0) {\n    for (let key = 0; key < 2 * BIT_MAX_PI && this.board[BOARD_AREA + key] !== undefined; key++) {\n      const piece = this.board[BOARD_AREA + key];\n      const distanceFromSpawn = Math.abs(spawnRow(piece) - piece / BOARD_SIZE);\n      if (key < BIT_MAX_PI) p1 += distanceFromSpawn;else p2 += distanceFromSpawn;\n    }\n  } else {\n    const p = _objectSpread({}, this.board.slice(BOARD_AREA));\n\n    const pieces = Object.keys(p).filter(item => p[item] !== undefined).reduce((res, key) => (res[key] = p[key], res), {});\n    const n = Object.keys(pieces).length;\n\n    for (let pi in pieces) {\n      const isClone = 2 * (pieces[pi] & 16);\n      const score = 5 + !isClone;\n      if (parseInt(pi) / BIT_MAX_PI) p2 += score;else p1 += score;\n    }\n  }\n\n  if (p1 > p2) return PLAYER_ONE;else if (p2 > p1) return PLAYER_TWO;else return 0;\n};\n\nexport default Leap;","map":{"version":3,"sources":["/Users/bacchus/git/Leap/client/src/assets/leap.js"],"names":["phaseLayouts","BOARD_SIZE","BOARD_AREA","BIT_SIZE","BIT_MAX_PI","BIT_INDEX_SHIFT","BIT_AREA","PLAYER_ONE","PLAYER_TWO","getBitShift","b","Leap","player","len","phaseLayout","turn","init","prototype","layout","pAmount","continuedMove","board","length","moves","fill","bufferSize","pi","lastRow","calcPhases","index","k","clearMoves","i","initPiece","j","key","copy","n","set","addMove","from","to","captured","push","undefined","highlightMoves","piece","nMoves","removeHighlight","makeClone","c","onCloningCell","onRow","onBoundaryColumn","onBoundaryRow","spawnRow","isCloneMove","Math","floor","canLeap","adj","getInverseIndex","getPlayer","inv","phaseAdj","phaseFar","canJump","direction","inBounds","isPhaseMove","bothPhases","canPhase","isPhase","isDestinationEmpty","getSpawnCells","col","spawnCellEmpty","getMovesInDirection","jumpWithinBounds","abs","getMoves","bCol","r","validDirection","isRedundantMove","getAllMoves","hasMoves","doMove","switchPlayer","capturedPiece","getCapturedPiece","ci","capturedAdjToDestination","capturedDirection","canClone","pid","move","validMove","randomMove","reducedMoveList","Object","keys","filter","item","reduce","res","moveKeys","random","parseInt","score","p1","p2","distanceFromSpawn","p","slice","pieces","isClone"],"mappings":"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","sourcesContent":["//'use strict';\nimport {phaseLayouts} from './util';\n\nvar BOARD_SIZE, BOARD_AREA, BIT_SIZE, BIT_MAX_PI, BIT_INDEX_SHIFT, BIT_AREA;\nconst PLAYER_ONE = 4\nconst PLAYER_TWO = 12;\n\nfunction getBitShift(b) {\n  return (b >> 1) ? (1 + getBitShift(b >> 1)) : 1;\n}\n\n\nfunction Leap(player, len, phaseLayout) {\n\t//no args passed mean it will be a copy.\n\tif (player) {\n\t\tthis.turn = player;\n\t\tBOARD_SIZE = len;\n\t\tBOARD_AREA = BOARD_SIZE**2;\n\t\tBIT_SIZE = 2**getBitShift(BOARD_SIZE-1);\n\t\tBIT_MAX_PI = 2*BIT_SIZE;\n\t\tBIT_INDEX_SHIFT = getBitShift(BOARD_AREA-1);\n\t\tBIT_AREA = 2**BIT_INDEX_SHIFT;\n\n\t\tthis.init(phaseLayout);\n\t}\n}\n\nLeap.prototype.init = function (layout) {\n\tthis.pAmount = {\n\t\t[PLAYER_ONE]: BOARD_SIZE,\n\t\t[PLAYER_TWO]: BOARD_SIZE\n\t};\n\tthis.continuedMove = false;\n\t(this.board = []).length = BOARD_AREA + 4*BOARD_SIZE;\n\t(this.moves = []).length = 4*BOARD_SIZE;\n\tthis.board.fill(0, 0, BOARD_AREA-1);\n\tthis.bufferSize = 1;\t//how many rows between the pieces' starting location and the nearest phases\n\n  let pi=0; //piece Index (ID)\n\tconst lastRow = (BOARD_SIZE-1)*BOARD_SIZE;\n\n\tconst calcPhases = (index) => {\n\t\tlet k = 0;\n\t\twhile(k<phaseLayouts[layout].length) {\n\t\t\tif (index === phaseLayouts[layout][k]) return 1;\n\t\t\tk++;\n\t\t}\n\t\treturn 0;\n\t};\n\tthis.clearMoves();\n\tfor (let i=0; i<BOARD_SIZE; i++) {\n\t\tthis.board[i] = ( (pi << 5) | PLAYER_ONE); //00000 0 01 00\n\t\tthis.initPiece(pi, i);\n\n\t\tthis.board[i + lastRow] = ( (pi + BIT_MAX_PI << 5) | PLAYER_TWO); //100000 0 11 00\n\t\tthis.initPiece(pi + BIT_MAX_PI, i + lastRow);\n\t\tpi++;\n\n\t\tfor (let j=1+this.bufferSize; j<(BOARD_SIZE-1)-this.bufferSize; j++) {\n\t\t\tthis.board[i + j*BOARD_SIZE] |= calcPhases(i+j*BOARD_SIZE);\n\t\t}\n\t}\n}\n\nLeap.prototype.initPiece = function (key, index) {\n\tthis.board[BOARD_AREA + key] = index;\n}\n\nLeap.prototype.copy = function () {\n\tconst board = new Leap();\n\tconst n = BOARD_AREA + 4*BOARD_SIZE;\n\t(board.board = []).length = n;\n\t(board.moves = []).length = this.moves.length;\n\n\t//copy over the board info (including piece directory)\n\tboard.board = [...this.board];\n\n\tboard.turn = this.turn;\n\tboard.continuedMove = this.continuedMove;\n\tboard.pAmount = {...this.pAmount};\n\tboard.clearMoves();\n\treturn board;\n}\n\nLeap.prototype.set = function (board) {\n  this.board = board.board;\n  this.turn = board.turn;\n  this.continuedMove = board.continuedMove;\n  this.pAmount = board.pAmount;\n  this.moves = board.moves;\n  return this;\n}\n\n// moves[pi] = [0000000 0000000] --> [board index of captured piece + board index of destination cell]\nLeap.prototype.addMove = function (from, to, captured) {\n\tcaptured = captured || 0;\n\tconst pi = (this.board[from] >> 5);\n\tthis.moves[pi].push( (captured << (BIT_INDEX_SHIFT) ) + to );\n}\n\nLeap.prototype.clearMoves = function (pi) {\n\tif (pi !== undefined) {\n\t\tthis.moves[pi] = [];\n\t\treturn;\n\t}\n\tfor (let i=0; i<4*BOARD_SIZE; i++) this.moves[i] = [];\n}\n\nLeap.prototype.highlightMoves = function (piece) {\n\tconst nMoves = this.moves[piece].length;\n\tfor (let i=0; i<nMoves; i++) {\n\t\tlet to = ( this.moves[piece][i] & (BIT_AREA - 1) );\n\t\tthis.board[to] |= 2;\n\t}\n}\n\nLeap.prototype.removeHighlight = function () {\n\tfor (let i=0; i<BOARD_AREA; i++) {\n\t\tif (this.board[i] & 2) (this.board[i] = this.board[i] ^ 2);\n\t}\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n//Assume special tiles won't appear on spawn rows\nLeap.prototype.makeClone = function (from, to) {\n\tconst player = this.turn;\n\tthis.pAmount[player]++;\n\tconst c = (player === 12) ? BIT_MAX_PI : 0;\n\tlet key;\n\t//Find first empty slot\n\tfor (key= BOARD_SIZE+c; key< 2*BOARD_SIZE+c; key++) {\n\t\tif (this.board[BOARD_AREA + key] === undefined) {\n\t\t\tthis.board[BOARD_AREA + key] = to;\n\t\t\tthis.board[to] = (key << 5) | player | 16;\n\t\t\tthis.board[from] |= 16;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nLeap.prototype.onCloningCell = function (from) {\n\tconst onRow = from/BOARD_SIZE\n\tconst piece = this.board[from];\n\tconst onBoundaryColumn = (from+1)%BOARD_SIZE < 2;\n\tconst onBoundaryRow = (onRow + 1)%BOARD_SIZE < 2;\n\n\t//To clone: NOT be on boundary column, BE on boundary row, NOT be cloned yet\n\tif (onBoundaryColumn || !onBoundaryRow || (piece & 16) ) return false;\n\n\tconst spawnRow = ( (piece >> 5) & BIT_MAX_PI ) ? (BOARD_SIZE-1) : 0;\n\treturn (onRow ^ spawnRow);\n}\n//Assumes valid move\nLeap.prototype.isCloneMove = function (from, to) {\n\t//if on cloning cell, suffice to show if destination is on spawn row\n\tconst spawnRow = ( (this.board[from] >> 5) & BIT_MAX_PI ) ? (BOARD_SIZE - 1) : 0;\n\treturn this.onCloningCell(from) && (Math.floor(to/BOARD_SIZE) === spawnRow);\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVE LOGIC\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\nLeap.prototype.canLeap = function (from, adj) {\n\tconst to = this.getInverseIndex(from);\n\n\t//DOES NOT CONSIDER SPECIAL PIECE '10'\n\tif (this.getPlayer(to)) return;\n\n\tconst inv = this.getInverseIndex(adj);\n\tconst phaseAdj = this.getPlayer(adj);\n\tconst phaseFar = this.getPlayer(inv);\n\n\tif ( (phaseAdj ^ phaseFar ^ this.turn) === 8 ) {\n\t\tthis.addMove(from, to, (phaseAdj ? adj : inv));\n\t}\n\t//if neighbor cell is a phase, leap_cell clear, and (enemy piece on phaseAdj XOR enemy piece on phaseFar)\n}\n\nLeap.prototype.canJump = function (from, direction) {\n\t//if adj cell occupied, jumpCell in bounds, jumpCell clear, and jumpCell has enemy piece\n\tconst adj = from+direction;\n\tconst to = adj+direction;\n\tif (this.inBounds(to) && !this.getPlayer(to)) {\n\t\tthis.addMove(from, to, adj);\n\t}\n}\n\nLeap.prototype.isPhaseMove = function (from, to, captured) {\n\tconst bothPhases = (this.board[from] & this.board[to]) & 1;\n\treturn !captured && bothPhases && this.getInverseIndex(from) === to;\n}\n\nLeap.prototype.canPhase = function (from, to) {\n\tconst isPhase = (this.board[from] & 1);\n\tconst isDestinationEmpty = !(this.board[to] & 4); //1 if player piece\n\tif (isPhase && isDestinationEmpty) {\n\t\tthis.addMove(from, to);\n\t}\n}\n\n//reaching this function implies selected piece can be cloned, so piece is on a bounding row\nLeap.prototype.getSpawnCells = function (from) {\n\tconst spawnRow = ( from/BOARD_SIZE ^ (BOARD_SIZE-1) );\n\tfor (let col=1; col<BOARD_SIZE-1;col++) {\n\t\tlet to = spawnRow*BOARD_SIZE + col;\n\t\tlet spawnCellEmpty = !(this.board[to] & 4);\n\n\t\t//if spawnCell doesn't have a player on it\n\t\tif (spawnCellEmpty) this.addMove(from, to);\n\t}\n}\n\nLeap.prototype.getMovesInDirection = function (from, direction) {\n\t//check adjacent cells of piece p wrt the boundary\n\tconst adj = from+direction;\n\tconst isPhase = this.board[adj] & 1;\n\tconst jumpWithinBounds = Math.abs( (adj+direction)%BOARD_SIZE - from%BOARD_SIZE ) < 3;\n\tif (isPhase) this.canLeap(from, adj);\n\n\tif ( (this.getPlayer(adj) ^ this.turn) === 8 ) {\n\t\tif (jumpWithinBounds) this.canJump(from, direction);\n \t}\n\telse this.addMove(from, adj);\n}\n\nLeap.prototype.getMoves = function (from) {\n\tconst bCol = (from+1)%BOARD_SIZE < 2 ? (from+1)%BOARD_SIZE : undefined;\n\tfor (let r=-1; r<2; r++) {\n\t\tfor (let c=-1+(bCol === 1 ? 1 : 0); c<2-(bCol === 0 ? 1 : 0); c++) {\n\t\t\tlet direction = (r*BOARD_SIZE) + c;\n\t\t\tlet adj = from+direction;\n\t\t\tlet validDirection = (direction) && ( this.getPlayer(adj) ^ this.turn ) && this.inBounds(adj);\n\t\t\tif ( validDirection ) this.getMovesInDirection(from, direction);\n\t\t}\n\t}\n\tconst inv = this.getInverseIndex(from);\n\t// phase condition\n\tif ( !this.isRedundantMove(from, inv) ) this.canPhase(from, inv);\n\t// clone condition\n\tif (!(this.board[from] & 16) && this.onCloningCell(from) ) this.getSpawnCells(from);\n}\n\nLeap.prototype.getAllMoves = function (player) {\n\tconst c = (player === 12) ? BIT_MAX_PI : 0;\n\tvar hasMoves = 0;\n\tfor (let key=c; key < 2*BOARD_SIZE + c; key++) {\n\t\tlet from = this.board[BOARD_AREA + key];\n\t\tif (!(from === undefined || from < 0)) {\n\t\t\thasMoves++;\n\t\t\tthis.getMoves(from);\n\t\t}\n\t}\n\treturn hasMoves;\n}\n\n//Performs move. returns true if enemy runs out of pieces\nLeap.prototype.doMove = function (from, to) {\n\t//CACHE this.board HERE. ITS A VERY HOT FUNCTION lmao (. Y .)\n\tif (this.isCloneMove(from, to)) {\n\t\tthis.makeClone(from, to);\n\t\tthis.removeHighlight();\n\t\tthis.clearMoves();\n\t\tthis.switchPlayer();\n\t\tthis.continuedMove = false;\n\t\treturn;\n\t}\n\tconst pi = this.board[from] >> 5;\n\tconst capturedPiece = this.getCapturedPiece(pi, to);\n\tthis.removeHighlight();\n\tthis.clearMoves();\n\n\tconst piece = (pi << 5) | (this.board[from] & 16) | this.turn;\n\n\tif ( (this.board[to] & 12) === 8 ) {\n\t\t//SPECIAL PIECE *any player can move.... but how is TODO*\n\t\tthis.board[to] |= (pi << 5);\n\t} else {\n\t\t//We can assume this cell is empty\n\t\tthis.board[to] |= piece;\n\t}\n\n\tif (capturedPiece) {\n\t\tconst ci = this.board[capturedPiece] >> 5;\n\t\tif(ci < 0) debugger;\n\t\tthis.board[capturedPiece] &= 3;\n\t\tthis.board[BOARD_AREA + ci] = ~this.board[BOARD_AREA + ci]; //He DED\n\n\n\t\tif( (--this.pAmount[(this.turn ^ 8)]) === 0) return true;\n\t\t//if Leap, then we get the direction by the difference between captured index and adjacent movement cell\n\t\tconst capturedAdjToDestination = (-9 <= (to-capturedPiece) && (to-capturedPiece) <= 9);\n\t\tconst capturedDirection = capturedAdjToDestination ? (to-capturedPiece) : (capturedPiece - from);\n\t\t//if can continue move in direction\n\t\tlet adj = to+capturedDirection;\n\t\tif ( this.board[adj] & 1 ) this.canLeap(to, adj);\n\t\tif ( (this.getPlayer(adj) ^ this.turn) === 8) this.canJump(to, capturedDirection);\n\t}\n\tthis.board[from] &= 3; //keep only cell data\n\tthis.board[BOARD_AREA + pi] = to;\n\n\tconst canPhase = (this.board[to] & 1) && !this.isPhaseMove(from, to, capturedPiece);\n\tconst canClone = this.onCloningCell(to) && !this.onCloningCell(from);\n\t//If can clone or is on phase that piece hasn't just travelled through\n\tif (canPhase) this.canPhase(to, this.getInverseIndex(to));\n\tif (canClone)\tthis.getSpawnCells(to);\n\n\t//if not a continued move, change player\n\tif(!this.moves[pi].length) this.switchPlayer();\n\telse {this.continuedMove = to;/*debugger;*/}\n\n\treturn false;\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tREFERENCES\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\nLeap.prototype.getPlayer = function (index) {\n\tconst pid = (this.board[index] & 12);\n\treturn (pid === 4 || pid === 12) ? pid : 0;\n}\n//NOTE: index 0 can never be captured\n//How to optimize? Well, if moves[pid][i] !< BOARD_AREA, then it must be a capture\n\nLeap.prototype.getCapturedPiece = function (pid, to) {\n\tconst nMoves = this.moves[pid].length;\n\tfor (let i=0; i< nMoves; i++) {\n\t\tlet move = this.moves[pid][i];\n\t\tlet capturedPiece = move >> (BIT_INDEX_SHIFT);\n\t\tif (capturedPiece >= BOARD_AREA) debugger;\n\t\tif ( (move & (BIT_AREA - 1)) === to  && capturedPiece) return capturedPiece;\n\t}\n}\n\n//ONLY WORKS on NxN boards and phase group orders of 2\nLeap.prototype.getInverseIndex = function (index) {\n\treturn (BOARD_AREA - 1) - index;\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tUTILITY\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\nLeap.prototype.inBounds = function (index) {\n\treturn 0 <= index && index < BOARD_AREA;\n}\n\nLeap.prototype.switchPlayer = function () {\n\tthis.turn ^= 8;\n\tthis.continuedMove = false;\n\treturn this.turn;\n}\n\nLeap.prototype.isRedundantMove = function (from, to) {\n\tconst pi = (this.board[from] >> 5);\n\tconst n = this.moves[pi].length;\n\tfor (let i=0; i<n; i++) {\n\t\tif ( (this.moves[pi][i] & (BIT_AREA-1)) === to ) return true;\n\t}\n\treturn false;\n}\n\nLeap.prototype.validMove = function (piece, index) {\n\tconst n = this.moves[piece].length;\n\tfor (let i=0; i<n; i++) {\n\t\tif ( (this.moves[piece][i] & (BIT_AREA - 1)) === index ) return true;\n\t}\n\treturn false;\n}\n\n//not sure how performant this is...\nLeap.prototype.randomMove = function () {\n\tif (!this.continuedMove) {\n\t\t//if no moves, enemy wins\n\t\tif (!this.getAllMoves(this.turn)) return (this.turn ^ 8);\n\n\t\t//There's gotta be a better way to remove undefined indeces\n\t\tconst moves = {...this.moves};\n\t\tconst reducedMoveList = Object.keys(moves)\n\t\t\t.filter( item => moves[item].length)\n\t\t\t.reduce( (res, key) => (res[key] = moves[key], res), {} );\n\t\tconst moveKeys = Object.keys(reducedMoveList);\n\t\tconst length = moveKeys.length;\n\t\tconst piece = moveKeys[Math.floor(Math.random() * length)];\n\t\tconst to = reducedMoveList[piece][Math.floor(Math.random() * reducedMoveList[piece].length)] & (BIT_AREA - 1);\n\t\tconst from = this.board[BOARD_AREA + parseInt(piece)];\n\n\t\treturn (this.doMove(from, to)) ? this.turn : 0;\n\t} else {\n\n\t\tthis.clearMoves();\n\t\tconst from = this.continuedMove;\n\t\tthis.getMoves(from);\n\t\tconst pi = this.board[from] >> 5;\n\t\tconst to = this.moves[pi][Math.floor(Math.random() * this.moves[pi].length)] & (BIT_AREA - 1);\n\t\treturn (this.doMove(from, to)) ? this.turn : 0;\n\t}\n}\n\n//what should the heuristic be??\nLeap.prototype.score = function () {\n\tlet p1 = 0;\n\tlet p2 = 0;\n\tconst spawnRow = index => ( (index >> 5) & BIT_MAX_PI ) ? (BOARD_SIZE-1) : 0;\n\n\t//no piece difference...\n\tif ( (this.pAmount[PLAYER_ONE] - this.pAmount[PLAYER_TWO]) === 0 ) {\n\t\tfor (let key=0; key<2*BIT_MAX_PI && (this.board[BOARD_AREA + key] !== undefined);key++) {\n\t\t\tconst piece = this.board[BOARD_AREA + key];\n\t\t\tconst distanceFromSpawn = Math.abs(spawnRow(piece) - piece/BOARD_SIZE);\n\t\t\tif (key < BIT_MAX_PI) p1 += distanceFromSpawn;\n\t\t\telse p2 += distanceFromSpawn;\n\t\t}\n\t} else {\n\t\tconst p = {...this.board.slice(BOARD_AREA)};\n\t\tconst pieces = Object.keys(p)\n\t\t\t.filter( item => p[item] !== undefined)\n\t\t\t.reduce( (res, key) => (res[key] = p[key], res), {} );\n\t\tconst n = Object.keys(pieces).length;\n\t\tfor (let pi in pieces) {\n\t\t\tconst isClone = 2*(pieces[pi] & 16);\n\t\t\tconst score = (5+!isClone);\n\t\t\tif (parseInt(pi)/BIT_MAX_PI) p2 += score;\n\t\t\telse p1 += score;\n\t\t}\n\t}\n\tif (p1 > p2) return PLAYER_ONE;\n\telse if (p2 > p1) return PLAYER_TWO;\n\telse return 0;\n}\n\nexport default Leap;\n"]},"metadata":{},"sourceType":"module"}