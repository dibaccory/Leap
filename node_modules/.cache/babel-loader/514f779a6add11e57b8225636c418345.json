{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar spec_1 = require(\"../spec\");\n\nfunction utf8Read(bytes, offset, length) {\n  var string = '',\n      chr = 0;\n\n  for (var i = offset, end = offset + length; i < end; i++) {\n    var byte = bytes[i];\n\n    if ((byte & 0x80) === 0x00) {\n      string += String.fromCharCode(byte);\n      continue;\n    }\n\n    if ((byte & 0xe0) === 0xc0) {\n      string += String.fromCharCode((byte & 0x1f) << 6 | bytes[++i] & 0x3f);\n      continue;\n    }\n\n    if ((byte & 0xf0) === 0xe0) {\n      string += String.fromCharCode((byte & 0x0f) << 12 | (bytes[++i] & 0x3f) << 6 | (bytes[++i] & 0x3f) << 0);\n      continue;\n    }\n\n    if ((byte & 0xf8) === 0xf0) {\n      chr = (byte & 0x07) << 18 | (bytes[++i] & 0x3f) << 12 | (bytes[++i] & 0x3f) << 6 | (bytes[++i] & 0x3f) << 0;\n\n      if (chr >= 0x010000) {\n        // surrogate pair\n        chr -= 0x010000;\n        string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);\n      } else {\n        string += String.fromCharCode(chr);\n      }\n\n      continue;\n    }\n\n    throw new Error('Invalid byte ' + byte.toString(16));\n  }\n\n  return string;\n}\n\nfunction int8(bytes, it) {\n  return uint8(bytes, it) << 24 >> 24;\n}\n\nexports.int8 = int8;\n;\n\nfunction uint8(bytes, it) {\n  return bytes[it.offset++];\n}\n\nexports.uint8 = uint8;\n;\n\nfunction int16(bytes, it) {\n  return uint16(bytes, it) << 16 >> 16;\n}\n\nexports.int16 = int16;\n;\n\nfunction uint16(bytes, it) {\n  return bytes[it.offset++] | bytes[it.offset++] << 8;\n}\n\nexports.uint16 = uint16;\n;\n\nfunction int32(bytes, it) {\n  return bytes[it.offset++] | bytes[it.offset++] << 8 | bytes[it.offset++] << 16 | bytes[it.offset++] << 24;\n}\n\nexports.int32 = int32;\n;\n\nfunction uint32(bytes, it) {\n  return int32(bytes, it) >>> 0;\n}\n\nexports.uint32 = uint32;\n;\n\nfunction float32(bytes, it) {\n  return readFloat32(bytes, it);\n}\n\nexports.float32 = float32;\n\nfunction float64(bytes, it) {\n  return readFloat64(bytes, it);\n}\n\nexports.float64 = float64;\n\nfunction int64(bytes, it) {\n  var low = uint32(bytes, it);\n  var high = int32(bytes, it) * Math.pow(2, 32);\n  return high + low;\n}\n\nexports.int64 = int64;\n;\n\nfunction uint64(bytes, it) {\n  var low = uint32(bytes, it);\n  var high = uint32(bytes, it) * Math.pow(2, 32);\n  return high + low;\n}\n\nexports.uint64 = uint64;\n; // force little endian to facilitate decoding on multiple implementations\n\nvar _isLittleEndian = true; // new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n\nvar _int32 = new Int32Array(2);\n\nvar _float32 = new Float32Array(_int32.buffer);\n\nvar _float64 = new Float64Array(_int32.buffer);\n\nfunction readFloat32(bytes, it) {\n  _int32[0] = int32(bytes, it);\n  return _float32[0];\n}\n\nexports.readFloat32 = readFloat32;\n;\n\nfunction readFloat64(bytes, it) {\n  _int32[_isLittleEndian ? 0 : 1] = int32(bytes, it);\n  _int32[_isLittleEndian ? 1 : 0] = int32(bytes, it);\n  return _float64[0];\n}\n\nexports.readFloat64 = readFloat64;\n;\n\nfunction boolean(bytes, it) {\n  return uint8(bytes, it) > 0;\n}\n\nexports.boolean = boolean;\n;\n\nfunction string(bytes, it) {\n  var prefix = bytes[it.offset++];\n  var length;\n\n  if (prefix < 0xc0) {\n    // fixstr\n    length = prefix & 0x1f;\n  } else if (prefix === 0xd9) {\n    length = uint8(bytes, it);\n  } else if (prefix === 0xda) {\n    length = uint16(bytes, it);\n  } else if (prefix === 0xdb) {\n    length = uint32(bytes, it);\n  }\n\n  var value = utf8Read(bytes, it.offset, length);\n  it.offset += length;\n  return value;\n}\n\nexports.string = string;\n\nfunction stringCheck(bytes, it) {\n  var prefix = bytes[it.offset];\n  return (// fixstr\n    prefix < 0xc0 && prefix > 0xa0 || // str 8\n    prefix === 0xd9 || // str 16\n    prefix === 0xda || // str 32\n    prefix === 0xdb\n  );\n}\n\nexports.stringCheck = stringCheck;\n\nfunction number(bytes, it) {\n  var prefix = bytes[it.offset++];\n\n  if (prefix < 0x80) {\n    // positive fixint\n    return prefix;\n  } else if (prefix === 0xca) {\n    // float 32\n    return readFloat32(bytes, it);\n  } else if (prefix === 0xcb) {\n    // float 64\n    return readFloat64(bytes, it);\n  } else if (prefix === 0xcc) {\n    // uint 8\n    return uint8(bytes, it);\n  } else if (prefix === 0xcd) {\n    // uint 16\n    return uint16(bytes, it);\n  } else if (prefix === 0xce) {\n    // uint 32\n    return uint32(bytes, it);\n  } else if (prefix === 0xcf) {\n    // uint 64\n    return uint64(bytes, it);\n  } else if (prefix === 0xd0) {\n    // int 8\n    return int8(bytes, it);\n  } else if (prefix === 0xd1) {\n    // int 16\n    return int16(bytes, it);\n  } else if (prefix === 0xd2) {\n    // int 32\n    return int32(bytes, it);\n  } else if (prefix === 0xd3) {\n    // int 64\n    return int64(bytes, it);\n  } else if (prefix > 0xdf) {\n    // negative fixint\n    return (0xff - prefix + 1) * -1;\n  }\n}\n\nexports.number = number;\n;\n\nfunction numberCheck(bytes, it) {\n  var prefix = bytes[it.offset]; // positive fixint - 0x00 - 0x7f\n  // float 32        - 0xca\n  // float 64        - 0xcb\n  // uint 8          - 0xcc\n  // uint 16         - 0xcd\n  // uint 32         - 0xce\n  // uint 64         - 0xcf\n  // int 8           - 0xd0\n  // int 16          - 0xd1\n  // int 32          - 0xd2\n  // int 64          - 0xd3\n\n  return prefix < 0x80 || prefix >= 0xca && prefix <= 0xd3;\n}\n\nexports.numberCheck = numberCheck;\n\nfunction arrayCheck(bytes, it) {\n  return bytes[it.offset] < 0xa0; // const prefix = bytes[it.offset] ;\n  // if (prefix < 0xa0) {\n  //   return prefix;\n  // // array\n  // } else if (prefix === 0xdc) {\n  //   it.offset += 2;\n  // } else if (0xdd) {\n  //   it.offset += 4;\n  // }\n  // return prefix;\n}\n\nexports.arrayCheck = arrayCheck;\n\nfunction nilCheck(bytes, it) {\n  return bytes[it.offset] === spec_1.NIL;\n}\n\nexports.nilCheck = nilCheck;\n\nfunction indexChangeCheck(bytes, it) {\n  return bytes[it.offset] === spec_1.INDEX_CHANGE;\n}\n\nexports.indexChangeCheck = indexChangeCheck;","map":{"version":3,"sources":["../../src/encoding/decode.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar spec_1 = require(\"../spec\");\nfunction utf8Read(bytes, offset, length) {\n    var string = '', chr = 0;\n    for (var i = offset, end = offset + length; i < end; i++) {\n        var byte = bytes[i];\n        if ((byte & 0x80) === 0x00) {\n            string += String.fromCharCode(byte);\n            continue;\n        }\n        if ((byte & 0xe0) === 0xc0) {\n            string += String.fromCharCode(((byte & 0x1f) << 6) |\n                (bytes[++i] & 0x3f));\n            continue;\n        }\n        if ((byte & 0xf0) === 0xe0) {\n            string += String.fromCharCode(((byte & 0x0f) << 12) |\n                ((bytes[++i] & 0x3f) << 6) |\n                ((bytes[++i] & 0x3f) << 0));\n            continue;\n        }\n        if ((byte & 0xf8) === 0xf0) {\n            chr = ((byte & 0x07) << 18) |\n                ((bytes[++i] & 0x3f) << 12) |\n                ((bytes[++i] & 0x3f) << 6) |\n                ((bytes[++i] & 0x3f) << 0);\n            if (chr >= 0x010000) { // surrogate pair\n                chr -= 0x010000;\n                string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);\n            }\n            else {\n                string += String.fromCharCode(chr);\n            }\n            continue;\n        }\n        throw new Error('Invalid byte ' + byte.toString(16));\n    }\n    return string;\n}\nfunction int8(bytes, it) {\n    return uint8(bytes, it) << 24 >> 24;\n}\nexports.int8 = int8;\n;\nfunction uint8(bytes, it) {\n    return bytes[it.offset++];\n}\nexports.uint8 = uint8;\n;\nfunction int16(bytes, it) {\n    return uint16(bytes, it) << 16 >> 16;\n}\nexports.int16 = int16;\n;\nfunction uint16(bytes, it) {\n    return bytes[it.offset++] | bytes[it.offset++] << 8;\n}\nexports.uint16 = uint16;\n;\nfunction int32(bytes, it) {\n    return bytes[it.offset++] | bytes[it.offset++] << 8 | bytes[it.offset++] << 16 | bytes[it.offset++] << 24;\n}\nexports.int32 = int32;\n;\nfunction uint32(bytes, it) {\n    return int32(bytes, it) >>> 0;\n}\nexports.uint32 = uint32;\n;\nfunction float32(bytes, it) {\n    return readFloat32(bytes, it);\n}\nexports.float32 = float32;\nfunction float64(bytes, it) {\n    return readFloat64(bytes, it);\n}\nexports.float64 = float64;\nfunction int64(bytes, it) {\n    var low = uint32(bytes, it);\n    var high = int32(bytes, it) * Math.pow(2, 32);\n    return high + low;\n}\nexports.int64 = int64;\n;\nfunction uint64(bytes, it) {\n    var low = uint32(bytes, it);\n    var high = uint32(bytes, it) * Math.pow(2, 32);\n    return high + low;\n}\nexports.uint64 = uint64;\n;\n// force little endian to facilitate decoding on multiple implementations\nvar _isLittleEndian = true; // new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\nvar _int32 = new Int32Array(2);\nvar _float32 = new Float32Array(_int32.buffer);\nvar _float64 = new Float64Array(_int32.buffer);\nfunction readFloat32(bytes, it) {\n    _int32[0] = int32(bytes, it);\n    return _float32[0];\n}\nexports.readFloat32 = readFloat32;\n;\nfunction readFloat64(bytes, it) {\n    _int32[_isLittleEndian ? 0 : 1] = int32(bytes, it);\n    _int32[_isLittleEndian ? 1 : 0] = int32(bytes, it);\n    return _float64[0];\n}\nexports.readFloat64 = readFloat64;\n;\nfunction boolean(bytes, it) {\n    return uint8(bytes, it) > 0;\n}\nexports.boolean = boolean;\n;\nfunction string(bytes, it) {\n    var prefix = bytes[it.offset++];\n    var length;\n    if (prefix < 0xc0) {\n        // fixstr\n        length = prefix & 0x1f;\n    }\n    else if (prefix === 0xd9) {\n        length = uint8(bytes, it);\n    }\n    else if (prefix === 0xda) {\n        length = uint16(bytes, it);\n    }\n    else if (prefix === 0xdb) {\n        length = uint32(bytes, it);\n    }\n    var value = utf8Read(bytes, it.offset, length);\n    it.offset += length;\n    return value;\n}\nexports.string = string;\nfunction stringCheck(bytes, it) {\n    var prefix = bytes[it.offset];\n    return (\n    // fixstr\n    (prefix < 0xc0 && prefix > 0xa0) ||\n        // str 8\n        prefix === 0xd9 ||\n        // str 16\n        prefix === 0xda ||\n        // str 32\n        prefix === 0xdb);\n}\nexports.stringCheck = stringCheck;\nfunction number(bytes, it) {\n    var prefix = bytes[it.offset++];\n    if (prefix < 0x80) {\n        // positive fixint\n        return prefix;\n    }\n    else if (prefix === 0xca) {\n        // float 32\n        return readFloat32(bytes, it);\n    }\n    else if (prefix === 0xcb) {\n        // float 64\n        return readFloat64(bytes, it);\n    }\n    else if (prefix === 0xcc) {\n        // uint 8\n        return uint8(bytes, it);\n    }\n    else if (prefix === 0xcd) {\n        // uint 16\n        return uint16(bytes, it);\n    }\n    else if (prefix === 0xce) {\n        // uint 32\n        return uint32(bytes, it);\n    }\n    else if (prefix === 0xcf) {\n        // uint 64\n        return uint64(bytes, it);\n    }\n    else if (prefix === 0xd0) {\n        // int 8\n        return int8(bytes, it);\n    }\n    else if (prefix === 0xd1) {\n        // int 16\n        return int16(bytes, it);\n    }\n    else if (prefix === 0xd2) {\n        // int 32\n        return int32(bytes, it);\n    }\n    else if (prefix === 0xd3) {\n        // int 64\n        return int64(bytes, it);\n    }\n    else if (prefix > 0xdf) {\n        // negative fixint\n        return (0xff - prefix + 1) * -1;\n    }\n}\nexports.number = number;\n;\nfunction numberCheck(bytes, it) {\n    var prefix = bytes[it.offset];\n    // positive fixint - 0x00 - 0x7f\n    // float 32        - 0xca\n    // float 64        - 0xcb\n    // uint 8          - 0xcc\n    // uint 16         - 0xcd\n    // uint 32         - 0xce\n    // uint 64         - 0xcf\n    // int 8           - 0xd0\n    // int 16          - 0xd1\n    // int 32          - 0xd2\n    // int 64          - 0xd3\n    return (prefix < 0x80 ||\n        (prefix >= 0xca && prefix <= 0xd3));\n}\nexports.numberCheck = numberCheck;\nfunction arrayCheck(bytes, it) {\n    return bytes[it.offset] < 0xa0;\n    // const prefix = bytes[it.offset] ;\n    // if (prefix < 0xa0) {\n    //   return prefix;\n    // // array\n    // } else if (prefix === 0xdc) {\n    //   it.offset += 2;\n    // } else if (0xdd) {\n    //   it.offset += 4;\n    // }\n    // return prefix;\n}\nexports.arrayCheck = arrayCheck;\nfunction nilCheck(bytes, it) {\n    return bytes[it.offset] === spec_1.NIL;\n}\nexports.nilCheck = nilCheck;\nfunction indexChangeCheck(bytes, it) {\n    return bytes[it.offset] === spec_1.INDEX_CHANGE;\n}\nexports.indexChangeCheck = indexChangeCheck;\n//# sourceMappingURL=decode.js.map"]},"metadata":{},"sourceType":"script"}