{"ast":null,"code":"var _jsxFileName = \"/Users/bacchus/git/Leap/src/Leap.js\";\nimport React, { Component } from 'react';\nimport './css/ui.css';\nimport Board from './js/board.js';\nimport Countdown from 'react-countdown-now';\n\nvar util = require('./js/util.js');\n/*\nTODO:\nhighlight pieces\n\nGame description:\n\n\n\"How to Play\":\n-directions\n-tutorial?\n*/\n\n\nconst BOARD_SIZE = 8;\nconst PLAYER_ONE = 1;\nconst PLAYER_TWO = 2;\nconst PLAYERS = {\n  [PLAYER_ONE]: {\n    name: \"Player One\",\n    class: \"player-one\"\n  },\n  [PLAYER_TWO]: {\n    name: \"Player Two\",\n    class: \"player-two\"\n  }\n};\nconst CELL_COLORS = [\"gray1\", \"gray2\", \"pink\", \"red\", \"orange\", \"yellow\", \"green\", \"blue\"];\n/*\nTODO:\n- Make continue button (?)\n\n- AI player\n\n- Allow multiplayer\n    Random match making\n    invites (link or username (if integrated with Google Play))\n\n- Pieces are draggable and snap to grid\n    (if center of dragging piece is strictly within calc(cell-margin + cell-height/2) on drop, then select cell where piece dropped)\n    disable animations for all but phase and clone moves.\n\n- Make animations\n    If clone, we animate the original piece and newly created piece with cloning animation\n    If phase, piece fades in/out from center to edges on adj phase  and on far phase\n    if piece has caught:\n      If jump,\n        piece does a small hop to the destination_cell\n        captured bursts into little circles and fades away\n      If leap,\n        piece gets sucked into portal, (SVG points all transform to center of adj phase, timing ease-in-out), and pushed out (reverse animation)\n        if captured on adj phase:\n          captured shakes and does first part of phase animation while piece being sucked in, but then comes out as little circles on other side\n        else:\n          captured bursts into little circles and fades away\n    else:\n      piece does small hop to destination cell\n\nHow can we handle animations?\n> Translate moving piece p, where p is a child of the destination cell component,\n> from ( starting_cell.center.x , starting_cell.center.y ) to ( destination_cell.x, destination_cell.y)\n\n\nANIMATION PIPELINE:\n  In function Board.do_move:\n  - get move details\n      moving piece: p,\n      starting_cell = {who: board[p.row][p.col].who, move_type: ye, row: p.row, col: p.col}, -- defined first in do move\n      move_direction,\n      captured piece (if applicable)\n\n  Upon do_move or make_clone:\n  - Find Cell components of starting_cell and, if applicable, captured piece\n      (starting cell) get Cell component c such that: c.row === starting_cell.row && c.col === starting_cell.col\n      (captured piece) get\n\n  - Append DOMelement of selected_piece to DOMelement of destination_cell\n\n\n*/\n\nfunction Piece(props) {\n  //\n  let classes = \"\";\n  let p = props.board.pieces[props.piece];\n\n  if (props.piece !== null) {\n    classes += PLAYERS[p.player].class;\n    if (p.cloned) classes += \" cloned\";\n\n    if (props.selected) {\n      classes += \" selected\"; //props.board.get_moves(props.piece);\n    }\n  }\n\n  return React.createElement(\"div\", {\n    className: classes,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 101\n    },\n    __self: this\n  });\n}\n\nclass Cell extends Component {\n  render() {\n    let color = CELL_COLORS[util.cell_type(this.props.row, this.props.column)]; //let selection = this.props.selected ? \" selected\" : \"\";\n\n    let highlight = this.props.highlight ? \" highlight\" : \"\";\n    let classes = \"cell \" + color + highlight;\n    return React.createElement(\"div\", {\n      className: classes,\n      onClick: () => this.props.select_cell(this.props.row, this.props.column),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 113\n      },\n      __self: this\n    }, this.props.val !== null && React.createElement(Piece, {\n      piece: this.props.val,\n      board: this.props.board,\n      selected: this.props.selected ? true : false,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 115\n      },\n      __self: this\n    }));\n  }\n\n}\n\nclass Row extends Component {\n  render() {\n    let selected_col = this.props.selected_piece ? this.props.selected_piece.col : null;\n    let cells = this.props.row.map((cell, i) => {\n      return React.createElement(Cell, {\n        key: i,\n        val: cell.who //so this.board[row][col] = {who: p.player | null, highlight: true | false -> if selected_col then this.board[row][col].highlight\n        ,\n        board: this.props.board,\n        row: this.props.row_i,\n        column: i,\n        highlight: cell.move ? true : false,\n        selected: i === selected_col ? true : false,\n        select_cell: this.props.select_cell,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 127\n        },\n        __self: this\n      });\n    });\n    return React.createElement(\"span\", {\n      className: \"row\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 136\n      },\n      __self: this\n    }, \" \", cells, \" \");\n  }\n\n}\n\nclass GameBoard extends Component {\n  render() {\n    let selected_row = this.props.selected_piece ? this.props.selected_piece.row : null;\n    let rows = this.props.board.board.map((row, i) => {\n      return React.createElement(Row, {\n        key: i,\n        board: this.props.board,\n        row: row //board[row]\n        ,\n        selected_piece: i === selected_row ? this.props.selected_piece : null,\n        row_i: i,\n        pieces: this.props.board.pieces,\n        select_cell: this.props.select_cell,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 144\n        },\n        __self: this\n      });\n    });\n    return React.createElement(\"div\", {\n      className: \"board\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 152\n      },\n      __self: this\n    }, \" \", rows, \" \");\n  }\n\n}\n\nfunction Winner(props) {\n  let player = PLAYERS[props.player].name;\n  return React.createElement(\"div\", {\n    id: \"winner\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 159\n    },\n    __self: this\n  }, React.createElement(\"div\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 160\n    },\n    __self: this\n  }, React.createElement(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 161\n    },\n    __self: this\n  }, player, \" has won the game!\"), React.createElement(\"button\", {\n    onClick: props.restart,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 162\n    },\n    __self: this\n  }, \"Play again?\")));\n}\n\nclass Leap extends Component {\n  constructor() {\n    super();\n    this.state = {\n      board: new Board(BOARD_SIZE, PLAYER_ONE, PLAYER_TWO),\n      turn: PLAYER_ONE,\n      continued_move: false,\n      selected_piece: null,\n      winner: null\n    };\n  } //React update method\n\n\n  componentDidUpdate(prevProps, prevState) {\n    //this.state.board.update_board();\n    if (prevState.turn !== this.state.turn) {\n      let board = this.state.board;\n\n      if (!board.moves_left(this.state.turn)) {\n        console.log(\"${this.state.turn} has no more moves!\");\n        this.setState({\n          winner: this.next_player()\n        });\n      }\n    } else if (selected_piece) {//if is a move continuation, start the timer\n    }\n  }\n\n  select_cell(row, col) {\n    //If a move is not a continuation, default case,\n    if (!this.state.continued_move) {\n      if (this.can_select_piece(row, col)) this.set_piece(row, col);else if (this.state.selected_piece) this.handle_move(row, col);\n    } else {\n      //if continuation\n      //check if move = true..\n      let board = this.state.board;\n      if (board.valid_move(row, col)) this.handle_move(row, col);else {\n        //TODO: prompt \"end turn?\" option.\n        //right now, let's just end the turn otherwise\n        this.setState({\n          board: board,\n          turn: this.next_player(this.state.turn),\n          continued_move: false,\n          selected_piece: null\n        });\n        board.update_board();\n      }\n    }\n  }\n\n  handle_move(row, col) {\n    //row, col of destination\n    let board = this.state.board;\n\n    if (!board.valid_move(row, col)) {\n      console.log(\"Invalid move!\");\n      return;\n    }\n\n    console.log(\"handling move...\");\n    let sel = this.state.selected_piece;\n    let pi = board.board[sel.row][sel.col].who;\n    let move_direction; //Check if move is a clone move; If it is, we need not call do_move\n\n    if (board.is_clone_spawn(pi, row, col)) board.make_clone(pi, row, col);else move_direction = board.do_move(pi, row, col); //all highlights gone\n    //If we can jump or leap, or phase (if move prior was not a phase)\n\n    if (board.can_continue_move(pi, move_direction)) {\n      board.get_moves(pi, 3, move_direction.row_incr, move_direction.col_incr); //highlight continuable moves\n\n      this.setState({\n        board: board,\n        turn: this.state.turn,\n        continued_move: move_direction,\n        selected_piece: {\n          row: row,\n          col: col\n        }\n      });\n    } else this.setState({\n      board: board,\n      turn: this.next_player(this.state.turn),\n      continued_move: false,\n      selected_piece: null\n    });\n  }\n\n  can_select_piece(row, col) {\n    let s = this.state;\n    let cell = s.board.board[row][col].who;\n    if (cell === null) return false;\n    let player = s.board.pieces[cell].player;\n    return player === s.turn;\n  }\n\n  set_piece(row, col) {\n    let board = this.state.board;\n    board.update_board();\n    board.get_moves(board.board[row][col].who);\n    this.setState({\n      selected_piece: {\n        row: row,\n        col: col\n      }\n    }); //console.log(\"selected piece: \" + this.state.board.board[row][col].who);\n  }\n\n  next_player() {\n    return this.state.turn === PLAYER_ONE ? PLAYER_TWO : PLAYER_ONE;\n  }\n\n  restart() {\n    this.setState({\n      board: new Board(BOARD_SIZE, PLAYER_ONE, PLAYER_TWO),\n      continued_move: false,\n      turn: PLAYER_ONE,\n      selected_piece: null,\n      winner: null\n    });\n  }\n\n  render() {\n    return React.createElement(\"div\", {\n      className: \"Leap\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 260\n      },\n      __self: this\n    }, React.createElement(\"div\", {\n      className: \"Leap-header\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 261\n      },\n      __self: this\n    }, React.createElement(\"h2\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 262\n      },\n      __self: this\n    }, \"Leap\")), this.state.winner && React.createElement(Winner, {\n      player: this.state.winner,\n      restart: this.restart.bind(this),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 264\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 265\n      },\n      __self: this\n    }, \"Current turn: \", PLAYERS[this.state.turn].name, React.createElement(\"span\", {\n      className: PLAYERS[this.state.turn].class + \"-token\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 265\n      },\n      __self: this\n    })), React.createElement(\"div\", {\n      className: \"game-container\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 268\n      },\n      __self: this\n    }, React.createElement(\"div\", {\n      className: \"game-options\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 269\n      },\n      __self: this\n    }), React.createElement(GameBoard, {\n      board: this.state.board,\n      selected_piece: this.state.selected_piece,\n      select_cell: this.select_cell.bind(this),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 270\n      },\n      __self: this\n    }), React.createElement(\"div\", {\n      className: \"game-menu\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 273\n      },\n      __self: this\n    })));\n  }\n\n}\n/*\n<Countdown date={Date.now() + 10000}\n           intervalDelay={0}\n           precision={3}\n           autoStart={this.state.continued_move}\n           renderer={d => <div>\n              <span className=\"countdown-s\">{d.seconds}</span>\n              <span className=\"countdown-ms\">:{d.milliseconds}</span>\n           </div>}/>\n*/\n\n\nexport default Leap;","map":{"version":3,"sources":["/Users/bacchus/git/Leap/src/Leap.js"],"names":["React","Component","Board","Countdown","util","require","BOARD_SIZE","PLAYER_ONE","PLAYER_TWO","PLAYERS","name","class","CELL_COLORS","Piece","props","classes","p","board","pieces","piece","player","cloned","selected","Cell","render","color","cell_type","row","column","highlight","select_cell","val","Row","selected_col","selected_piece","col","cells","map","cell","i","who","row_i","move","GameBoard","selected_row","rows","Winner","restart","Leap","constructor","state","turn","continued_move","winner","componentDidUpdate","prevProps","prevState","moves_left","console","log","setState","next_player","can_select_piece","set_piece","handle_move","valid_move","update_board","sel","pi","move_direction","is_clone_spawn","make_clone","do_move","can_continue_move","get_moves","row_incr","col_incr","s","bind"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport './css/ui.css';\nimport Board from './js/board.js';\nimport Countdown from 'react-countdown-now';\nvar util = require('./js/util.js');\n\n/*\nTODO:\nhighlight pieces\n\nGame description:\n\n\n\"How to Play\":\n-directions\n-tutorial?\n*/\n\nconst BOARD_SIZE = 8;\nconst PLAYER_ONE = 1;\nconst PLAYER_TWO = 2;\nconst PLAYERS = {\n  [PLAYER_ONE]: {\n    name: \"Player One\",\n    class: \"player-one\"\n  },\n  [PLAYER_TWO]: {\n    name: \"Player Two\",\n    class: \"player-two\"\n  }\n}\n\nconst CELL_COLORS = [ \"gray1\", \"gray2\", \"pink\", \"red\", \"orange\", \"yellow\", \"green\", \"blue\"];\n\n/*\nTODO:\n- Make continue button (?)\n\n- AI player\n\n- Allow multiplayer\n    Random match making\n    invites (link or username (if integrated with Google Play))\n\n- Pieces are draggable and snap to grid\n    (if center of dragging piece is strictly within calc(cell-margin + cell-height/2) on drop, then select cell where piece dropped)\n    disable animations for all but phase and clone moves.\n\n- Make animations\n    If clone, we animate the original piece and newly created piece with cloning animation\n    If phase, piece fades in/out from center to edges on adj phase  and on far phase\n    if piece has caught:\n      If jump,\n        piece does a small hop to the destination_cell\n        captured bursts into little circles and fades away\n      If leap,\n        piece gets sucked into portal, (SVG points all transform to center of adj phase, timing ease-in-out), and pushed out (reverse animation)\n        if captured on adj phase:\n          captured shakes and does first part of phase animation while piece being sucked in, but then comes out as little circles on other side\n        else:\n          captured bursts into little circles and fades away\n    else:\n      piece does small hop to destination cell\n\nHow can we handle animations?\n> Translate moving piece p, where p is a child of the destination cell component,\n> from ( starting_cell.center.x , starting_cell.center.y ) to ( destination_cell.x, destination_cell.y)\n\n\nANIMATION PIPELINE:\n  In function Board.do_move:\n  - get move details\n      moving piece: p,\n      starting_cell = {who: board[p.row][p.col].who, move_type: ye, row: p.row, col: p.col}, -- defined first in do move\n      move_direction,\n      captured piece (if applicable)\n\n  Upon do_move or make_clone:\n  - Find Cell components of starting_cell and, if applicable, captured piece\n      (starting cell) get Cell component c such that: c.row === starting_cell.row && c.col === starting_cell.col\n      (captured piece) get\n\n  - Append DOMelement of selected_piece to DOMelement of destination_cell\n\n\n*/\n\nfunction Piece(props) {\n  //\n\n  let classes = \"\";\n  let p = props.board.pieces[props.piece];\n  if (props.piece !== null) {\n    classes += PLAYERS[p.player].class;\n    if (p.cloned) classes += \" cloned\";\n    if (props.selected) {\n      classes += \" selected\";\n      //props.board.get_moves(props.piece);\n    }\n  }\n  return (<div className={classes}></div>)\n}\n\nclass Cell extends Component {\n\n  render() {\n    let color = CELL_COLORS[util.cell_type(this.props.row, this.props.column)];\n\n    //let selection = this.props.selected ? \" selected\" : \"\";\n    let highlight = this.props.highlight ? \" highlight\" : \"\";\n    let classes = \"cell \" + color + highlight;\n    return (\n      <div className={classes} onClick={ () => this.props.select_cell(this.props.row, this.props.column) }>\n        {this.props.val !== null\n        && <Piece piece={this.props.val}\n                  board={this.props.board}\n                  selected={this.props.selected ? true : false}/>}\n      </div>\n    )\n  }\n}\n\nclass Row extends Component {\n  render() {\n    let selected_col = this.props.selected_piece ? this.props.selected_piece.col : null;\n    let cells = this.props.row.map((cell, i) => {\n      return <Cell key={i}\n              val={cell.who} //so this.board[row][col] = {who: p.player | null, highlight: true | false -> if selected_col then this.board[row][col].highlight\n              board={this.props.board}\n              row={this.props.row_i}\n              column={i}\n              highlight={cell.move ? true : false}\n              selected={i === selected_col ? true : false}\n              select_cell={this.props.select_cell} />\n    });\n    return (<span className=\"row\"> {cells} </span>)\n  }\n}\n\nclass GameBoard extends Component {\n  render() {\n    let selected_row = this.props.selected_piece ? this.props.selected_piece.row : null;\n    let rows = this.props.board.board.map((row, i) => {\n      return <Row key={i}\n              board={this.props.board}\n              row={row} //board[row]\n              selected_piece={i === selected_row ? this.props.selected_piece : null}\n              row_i={i}\n              pieces={this.props.board.pieces}\n              select_cell={this.props.select_cell} />;\n    });\n    return (<div className=\"board\"> {rows} </div>)\n  }\n}\n\nfunction Winner(props) {\n  let player = PLAYERS[props.player].name;\n  return (\n    <div id=\"winner\">\n      <div>\n        <p>{player} has won the game!</p>\n        <button onClick={props.restart}>Play again?</button>\n      </div>\n    </div>\n  );\n}\n\nclass Leap extends Component {\n  constructor() {\n    super();\n    this.state = { board: new Board(BOARD_SIZE, PLAYER_ONE, PLAYER_TWO),\n                  turn: PLAYER_ONE,\n                  continued_move: false,\n                  selected_piece: null, winner: null };\n  }\n\n  //React update method\n  componentDidUpdate(prevProps, prevState) {\n    //this.state.board.update_board();\n    if (prevState.turn !== this.state.turn) {\n      let board = this.state.board;\n      if (!board.moves_left(this.state.turn)) {\n        console.log(\"${this.state.turn} has no more moves!\");\n        this.setState({winner: this.next_player()});\n      }\n    } else if (selected_piece){\n      //if is a move continuation, start the timer\n    }\n  }\n\n  select_cell(row, col) {\n    //If a move is not a continuation, default case,\n    if (!this.state.continued_move) {\n      if (this.can_select_piece(row, col)) this.set_piece(row, col);\n      else if (this.state.selected_piece)  this.handle_move(row, col);\n    } else { //if continuation\n      //check if move = true..\n      let board = this.state.board;\n      if (board.valid_move(row, col)) this.handle_move(row, col)\n      else {\n        //TODO: prompt \"end turn?\" option.\n        //right now, let's just end the turn otherwise\n        this.setState({board: board, turn: this.next_player(this.state.turn), continued_move: false, selected_piece: null});\n        board.update_board();\n      }\n    }\n  }\n\n  handle_move(row, col) { //row, col of destination\n    let board = this.state.board;\n    if (!board.valid_move(row, col)) {\n      console.log(\"Invalid move!\");\n      return;\n    }\n    console.log(\"handling move...\");\n    let sel = this.state.selected_piece;\n    let pi = board.board[sel.row][sel.col].who;\n\n    let move_direction;\n    //Check if move is a clone move; If it is, we need not call do_move\n    if(board.is_clone_spawn(pi,row, col)) board.make_clone(pi, row, col);\n    else move_direction = board.do_move(pi, row, col);\n    //all highlights gone\n\n    //If we can jump or leap, or phase (if move prior was not a phase)\n    if (board.can_continue_move(pi, move_direction)) {\n      board.get_moves(pi, 3, move_direction.row_incr, move_direction.col_incr); //highlight continuable moves\n      this.setState( {board: board, turn: this.state.turn, continued_move: move_direction, selected_piece: {row: row, col: col}});\n    } else this.setState({board: board, turn: this.next_player(this.state.turn), continued_move: false, selected_piece: null});\n  }\n\n  can_select_piece(row, col) {\n    let s = this.state;\n    let cell = s.board.board[row][col].who;\n    if (cell === null) return false;\n    let player = s.board.pieces[cell].player;\n    return player === s.turn;\n  }\n\n  set_piece(row, col) {\n    let board = this.state.board;\n    board.update_board();\n    board.get_moves(board.board[row][col].who);\n    this.setState({selected_piece: {row: row, col: col}});\n      //console.log(\"selected piece: \" + this.state.board.board[row][col].who);\n  }\n\n  next_player() {\n    return (this.state.turn === PLAYER_ONE ? PLAYER_TWO : PLAYER_ONE);\n  }\n\n  restart() {\n    this.setState({ board: new Board(BOARD_SIZE, PLAYER_ONE, PLAYER_TWO),\n                    continued_move: false, turn: PLAYER_ONE,\n                    selected_piece: null, winner: null });\n  }\n\n  render() {\n    return (\n      <div className=\"Leap\">\n        <div className=\"Leap-header\">\n          <h2>Leap</h2>\n        </div>\n        { this.state.winner && <Winner player={this.state.winner} restart={this.restart.bind(this)} /> }\n        <h3>Current turn: {PLAYERS[this.state.turn].name}<span className={PLAYERS[this.state.turn].class+\"-token\"}></span></h3>\n\n\n        <div className=\"game-container\">\n          <div className=\"game-options\"></div>\n          <GameBoard board={this.state.board}\n                     selected_piece={this.state.selected_piece}\n                     select_cell={this.select_cell.bind(this)} />\n          <div className=\"game-menu\"></div>\n        </div>\n      </div>\n    );\n  }\n}\n/*\n<Countdown date={Date.now() + 10000}\n           intervalDelay={0}\n           precision={3}\n           autoStart={this.state.continued_move}\n           renderer={d => <div>\n              <span className=\"countdown-s\">{d.seconds}</span>\n              <span className=\"countdown-ms\">:{d.milliseconds}</span>\n           </div>}/>\n*/\n\nexport default Leap;\n"]},"metadata":{},"sourceType":"module"}