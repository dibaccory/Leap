{"ast":null,"code":"import { BOARD_SIZE, BOARD_AREA, BIT_SIZE, BIT_MAX_PI, BIT_INDEX_SHIFT, BIT_AREA } from './board.js';\nconst UCB_COEFFICENT = 1;\n\nfunction Node(player, from, to) {\n  this.visits = 1;\n  this.score = to >> 5 ? BOARD_SIZE : 0;\n  this.children = null;\n  this.to = to & BIT_AREA - 1;\n  this.from = from;\n  this.player = player;\n}\n\nNode.prototype.opponent = function () {\n  return this.player ^ 8;\n};\n\nNode.prototype.append = function (child) {\n  if (!this.children) this.children = [child];else this.children.push(child);\n};\n\nNode.prototype.branch = function (state) {\n  state.clearMoves();\n  state.getAllMoves(state.player);\n  const shift = state.player === 12 ? BIT_MAX_PI : 0;\n\n  for (let pi = shift; pi < BIT_MAX_PI + shift; pi++) {\n    const nMoves = state.moves[pi].length;\n    const from = state.board[BOARD_AREA + pi];\n\n    for (let i = 0; i < nMoves; i++) {\n      const to = state.moves[pi][i];\n      let child = new Node(state.player, from, to);\n      this.append(child);\n    }\n  }\n};\n\nNode.prototype.playFor = function (state) {\n  return state.doMove(this.from, this.to);\n};\n\nNode.prototype.ucb = function (c) {\n  const score = this.score / this.visits;\n  return score + UCB_COEFFICENT * Math.sqrt(c / this.visits);\n};\n\nNode.prototype.findBestChild = function () {\n  const coeff = Math.log(this.visits);\n  let bestScore = -Infinity;\n  let bestChild = null;\n\n  for (let i = 0; i < this.children.length; i++) {\n    const child = this.children[i];\n    let score; //Prioritize unexplored nodes\n\n    if (child.visits !== 1) score = child.ucb(coeff);else score = Math.ceil(10000 * (1 + Math.random()));\n\n    if (score > bestScore) {\n      bestScore = score;\n      bestChild = child;\n    }\n  }\n\n  return bestChild;\n};\n\nexport function UCT(startState, maxTime) {\n  this.root = new Node(startState.player);\n  this.startState = startState;\n  this.visitThreshold = BOARD_SIZE; // Populate the first node.\n\n  this.root.branch(startState);\n  this.history = [this.root];\n  let totalPlayouts = 0;\n  const start = Date.now();\n  let elapsedTime = 0;\n\n  while (elapsedTime < maxTime) {\n    for (let i = 0; i < 500; i++) this.run();\n\n    totalPlayouts += 500;\n    elapsedTime = Date.now() - start;\n  } //Choose best child of root to return next move\n\n\n  let bestChild = null;\n  let bestScore = -Infinity;\n\n  for (let i = 0; i < this.root.children.length; i++) {\n    const child = this.root.children[i];\n\n    if (child.visits > bestScore) {\n      bestChild = child;\n      bestScore = child.visits;\n    }\n  }\n\n  return {\n    elapsed: elapsedTime,\n    playouts: totalPlayouts,\n    from: bestChild.from,\n    to: bestChild.to\n  };\n}\n\nUCT.prototype.playout = function (state) {\n  let nmoves = 0;\n\n  while (++nmoves < 40) {\n    const result = state.randomMove(); //returns if won\n\n    if (result) return result;\n  }\n\n  return state.score();\n};\n\nUCT.prototype.run = function () {\n  const state = this.startState.copy();\n  let node = this.root;\n  let depth = 1;\n  let winner = 0;\n\n  while (true) {\n    if (node.children === null) {\n      //Keeps UCT from branching too quickly\n      if (node.visits >= this.visitThreshold * depth) {\n        node.branch(state); // Leaf node - go directly to update.\n\n        if (node.children === null) {\n          winner = node.opponent();\n          this.history[depth++] = node;\n          break;\n        }\n\n        continue;\n      }\n\n      winner = this.playout(state);\n      break;\n    }\n\n    node = node.findBestChild();\n    this.history[depth++] = node;\n\n    if (node.playFor(state)) {\n      winner = state.player;\n      break;\n    }\n  } //Update scores\n\n\n  for (let i = 0; i < depth; i++) {\n    node = this.history[i];\n    node.visits++;\n    if (winner === node.player) node.score += 1;else if (!winner) node.score -= 1;\n  }\n};","map":{"version":3,"sources":["/Users/bacchus/git/Leap/src/js/ai.js"],"names":["BOARD_SIZE","BOARD_AREA","BIT_SIZE","BIT_MAX_PI","BIT_INDEX_SHIFT","BIT_AREA","UCB_COEFFICENT","Node","player","from","to","visits","score","children","prototype","opponent","append","child","push","branch","state","clearMoves","getAllMoves","shift","pi","nMoves","moves","length","board","i","playFor","doMove","ucb","c","Math","sqrt","findBestChild","coeff","log","bestScore","Infinity","bestChild","ceil","random","UCT","startState","maxTime","root","visitThreshold","history","totalPlayouts","start","Date","now","elapsedTime","run","elapsed","playouts","playout","nmoves","result","randomMove","copy","node","depth","winner"],"mappings":"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","sourcesContent":["import {BOARD_SIZE, BOARD_AREA, BIT_SIZE, BIT_MAX_PI, BIT_INDEX_SHIFT, BIT_AREA} from './board.js';\n\nconst UCB_COEFFICENT = 1;\n\nfunction Node(player, from, to) {\n    this.visits = 1;\n    this.score = (to >> 5) ? BOARD_SIZE : 0;\n    this.children = null;\n    this.to = to & (BIT_AREA - 1);\n    this.from = from;\n    this.player = player;\n}\n\nNode.prototype.opponent = function () {\n    return this.player ^ 8;\n}\n\nNode.prototype.append = function (child) {\n    if (!this.children) this.children = [child];\n    else this.children.push(child);\n}\n\nNode.prototype.branch = function (state) {\n    state.clearMoves();\n    state.getAllMoves(state.player);\n\n    const shift = (state.player === 12) ? BIT_MAX_PI : 0;\n    for (let pi = shift; pi < BIT_MAX_PI + shift; pi++) {\n      const nMoves = state.moves[pi].length;\n      const from = state.board[BOARD_AREA + pi];\n\n      for (let i = 0; i < nMoves; i++) {\n        const to = state.moves[pi][i];\n        let child = new Node(state.player, from, to);\n        this.append(child);\n      }\n  }\n}\n\nNode.prototype.playFor = function (state) {\n    return state.doMove(this.from, this.to);\n}\n\nNode.prototype.ucb = function (c) {\n    const score = (this.score / this.visits);\n    return score + UCB_COEFFICENT * Math.sqrt( c / this.visits);\n}\n\nNode.prototype.findBestChild = function () {\n    const coeff = Math.log(this.visits);\n    let bestScore = -Infinity;\n    let bestChild = null;\n    for (let i = 0; i < this.children.length; i++) {\n      const child = this.children[i];\n      let score;\n\n      //Prioritize unexplored nodes\n      if (child.visits !== 1) score = child.ucb(coeff);\n      else score = Math.ceil( 10000*(1 + Math.random()) );\n\n      if (score > bestScore) {\n          bestScore = score;\n          bestChild = child;\n      }\n    }\n    return bestChild;\n}\n\n\n\n\n\nexport function UCT(startState, maxTime) {\n  this.root = new Node(startState.player);\n  this.startState = startState;\n  this.visitThreshold = BOARD_SIZE;\n\n  // Populate the first node.\n  this.root.branch(startState);\n  this.history = [this.root];\n\n  let totalPlayouts = 0;\n  const start = Date.now();\n  let elapsedTime = 0;\n  while (elapsedTime < maxTime) {\n      for (let i = 0; i < 500; i++) this.run();\n      totalPlayouts += 500;\n      elapsedTime = Date.now() - start;\n  }\n\n  //Choose best child of root to return next move\n  let bestChild = null;\n  let bestScore = -Infinity;\n  for (let i = 0; i < this.root.children.length; i++) {\n      const child = this.root.children[i];\n      if (child.visits > bestScore) {\n          bestChild = child;\n          bestScore = child.visits;\n      }\n  }\n\n  return {\n    elapsed: elapsedTime,\n    playouts: totalPlayouts,\n    from: bestChild.from,\n    to: bestChild.to\n  };\n}\n\nUCT.prototype.playout = function (state) {\n    let nmoves = 0;\n\n    while (++nmoves < 40) {\n      const result = state.randomMove(); //returns if won\n      if (result) return result;\n    }\n    return state.score();\n}\n\nUCT.prototype.run = function () {\n    const state = this.startState.copy();\n    let node = this.root;\n    let depth = 1;\n    let winner = 0;\n\n    while (true) {\n      if (node.children === null) {\n        //Keeps UCT from branching too quickly\n        if (node.visits >= this.visitThreshold*depth) {\n        node.branch(state);\n\n        // Leaf node - go directly to update.\n        if (node.children === null) {\n          winner = node.opponent();\n          this.history[depth++] = node;\n          break;\n        }\n          continue;\n        }\n        winner = this.playout(state);\n        break;\n      }\n        node = node.findBestChild();\n        this.history[depth++] = node;\n        if (node.playFor(state)) {\n          winner = state.player;\n          break;\n        }\n    }\n\n    //Update scores\n    for (let i = 0; i < depth; i++) {\n      node = this.history[i];\n      node.visits++;\n      if (winner === node.player) node.score += 1;\n      else if (!winner) node.score -= 1;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}