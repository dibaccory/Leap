{"ast":null,"code":"import { toIndex, getRow, getCol, cellType, phaseLayouts } from './util';\nimport './Leap.js'; //single, phase, jump, super-jump\n\n/*\nadj: adjacent\nphase: change portal side\nleap: capture piece while jumping through a portal\njitch: jump, then phase\nswump: switch, then jump\n}\n\nREFACTOR CHANGES:\nLeap.js -> Game.js\n\t<Leap> -> <GameController>\nboard.js -> leap.js\n\n\nBITWISE:\n\nBOARD:\nbit\t\t\t\titem\n0-1\t\t\t\tcellType\t{regular, phase} x {highlight, no highlight}\n2-3\t\t\tcellState\t\t{00: empty, 10: SPECIAL, 01: p1, 11: p2, }   NOTE, if '10' for bits 1 and 2, then it should be a SPECIAL THING???  lmao what if a piece can be moved by either player for a few turns?\n4\t\t\t\t\tisCloned\n5-9\t\t\t\tkey\t\t\t\tIf piece on cell, this is index to reach it\n\nboard[i] = (key << 4 | isCloned << 3 | cellState << 1 | cellType);\nfor i = row * SIZE + col \t\twhere row, col wtr a given piece\n\nPIECE INDEX:\nbit \t\t\titem\n0-2\t\t\t\tcol\n3-(5,6)\t\trow\n\nboard[i] = (row << 4 | col);\nfor i = SIZE*SIZE + key\t\t\twhere\n\n\nhow to store moves\nmoves[i] = [ 0 <= board_index < SIZE*SIZE, ... , ... ] all possible moves for associated piece.\nfor i = SIZE*SIZE + key\n\n\n\nindex = cell number\nkey = piece index\n\n*/\n//can I generate layouts on seeds? lmao\n\nfunction Board(len, phaseLayout) {\n  this.p1 = 4;\n  this.p2 = 12;\n  this.len = len;\n  this.area = len * len;\n  this.BIT_SHIFT = getBitShift(len - 1);\n  this.BIT_LENGTH = 2 ** this.BIT_SHIFT;\n  this.BIT_AREA = 2 ** (this.BIT_SHIFT * 2);\n  (this.board = []).length = this.area;\n  (this.moves = []).length = 4 * len;\n  this.board.fill(0);\n  this.bufferSize = 1; //how many rows between the pieces' starting location and the nearest phases\n\n  this.init(phaseLayout); //this.update();\n}\n\nBoard.prototype.init = function (layout) {\n  let pi = 0; //piece Index (ID)\n\n  const len = this.len;\n\n  const calcPhases = index => {\n    let k = 0;\n\n    while (k < phaseLayouts[layout].length) {\n      if ((index ^ phaseLayouts[layout][k]) === 0) return 1;\n      k++;\n    }\n\n    return 0;\n  };\n\n  for (let i = 0; i < len; i++) {\n    this.board[i] = pi << 5 | this.p1; //00000 0 01 00\n\n    this.initPiece(pi);\n    this.board[i + (len - 1) * len] = pi + 2 * this.BIT_LENGTH << 5 | this.p2; //100000 0 11 00\n\n    this.initPiece(pi + 2 * len);\n    pi++;\n\n    for (let j = 1 + this.bufferSize; j < len - 1 - this.bufferSize; j++) {\n      this.board[i + j * len] |= calcPhases(i + j * len);\n    }\n  }\n};\n\nBoard.prototype.initPiece = function (pi) {\n  this.moves[pi] = [];\n};\n\nBoard.prototype.getPlayer = function (index) {\n  return (this.board[index] & 12) < 12 ? this.p1 : this.p2;\n}; // moves[pi] = [0000000 0000000] --> [board index of captured piece + board index of destination cell]\n\n\nBoard.prototype.addMove = function (from, to, captured) {\n  captured = captured || 0;\n  let pi = this.board[from] >> 5;\n  this.moves[pi].push((captured << 2 * this.BIT_SHIFT) + to);\n};\n\nBoard.prototype.update = function (newPiece) {\n  if (newPiece) {\n    //find out which player this piece belongs to then add it within that player's key range (00000)\n    this.board = this.board.map(row => row.map((cell, j) => {\n      if (cell.who != null) {\n        //increment all pi in board after piecesSeparator by one\n        if (cell.who >= this.piecesSeparator) cell.who++; //if piece alive, keep on board\n\n        return this.pieces[cell.who].alive ? {\n          who: cell.who,\n          move: false\n        } : {\n          who: null,\n          move: false\n        };\n      } else return {\n        who: null,\n        move: false\n      };\n    }));\n  } else {\n    this.board = this.board.map(row => row.map((cell, j) => cell.who != null ? this.pieces[cell.who].alive ? {\n      who: cell.who,\n      move: false\n    } : {\n      who: null,\n      move: false\n    } : {\n      who: null,\n      move: false\n    }));\n  }\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n/* DEPRECIATED: we use bit shifts now\n//Calls every time a clone is made\nBoard.prototype.insertAtSeparationIndex = function () {\n\tfor(let pi=this.piecesSeparator; pi<this.pieces.length; pi++) {\n\t\t//Finds index that separates p1 and p2 pieces\n\t\tif(this.pieces[pi].player !== this.p2) {\n\t\t\tthis.piecesSeparator = pi; //update\n\t\t\treturn pi;\n\t\t}\n\t}\n}\n*/\n\n\nBoard.prototype.makeClone = function (pi, row, col) {\n  /*\n  getPlayer bit\n  */\n  this.board[row * this.len + col] |= this.getPlayer(row, col);\n  this.updateBoard(true);\n  this.board[row][col].who = this.piecesSeparator;\n  return true;\n};\n\nBoard.prototype.canClone = function (i) {\n  let row = i / this.BIT_LENGTH,\n      piece = this.board[i];\n  let onBoundingColumn = (i + 1) % this.BIT_LENGTH < 2;\n  let onBoundingRow = (row + 1) % this.BIT_LENGTH < 2;\n  if (onBoundingColumn || !onBoundingRow || piece & 16) return false;\n  let spawnRow = ((piece >> 5 & 2 * this.BIT_LENGTH) - 1) / 2;\n  return row ^ spawnRow;\n};\n/* DEPRECIATED: not used\nBoard.prototype.isCloneSpawn = function (pi, row, col) {\n\treturn this.canClone(pi) && this.board[row][col].who === null;\n}\n*/\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n// Board.prototype.getPlayer = function (pi) {\n// \treturn this.pieces[pi].player;\n// }\n\n\nBoard.prototype.isLeap = function (p, rowIncr, colIncr, isPhase, cellAdj, bypassCondition) {\n  //if neighbor cell is a phase, leap_cell clear, and (enemy piece on phaseAdj XOR enemy piece on phaseFar)\n  let destinationCell = this.board[7 - p.row][7 - p.col];\n\n  if (isPhase && !destinationCell.who) {\n    let phaseAdj = cellAdj.who;\n    let phaseFar = this.board[7 - (p.row + rowIncr)][7 - (p.col + colIncr)].who;\n\n    if ((phaseAdj || phaseFar) && !(phaseAdj && phaseFar)) {\n      //xor filter. Only one may be true\n      let capt = phaseAdj ? phaseAdj : phaseFar; //if 0, add to destinationCell.move, if 1,\n\n      if (bypassCondition) return true;else destinationCell.move = capt;\n    }\n  }\n};\n\nBoard.prototype.isJump = function (p, rowIncr, colIncr, cellAdj, bypassCondition) {\n  //if adj cell occupied, jumpCell in bounds, jumpCell clear, and jumpCell has enemy piece\n  if (this.inBounds(p.row + rowIncr * 2, p.col + colIncr * 2)) {\n    let destinationCell = this.board[p.row + rowIncr * 2][p.col + colIncr * 2];\n\n    if (this.getPlayer(cellAdj.who) !== p.player && destinationCell.who === null) {\n      if (bypassCondition % 3) return true;else destinationCell.move = cellAdj.who;\n    }\n  }\n};\n\nBoard.prototype.canPhase = function (from, row, col, bypassCondition) {\n  let len = this.len - 1; //j = 7-row_index + 7-col_index\n\n  let to = (len - row << this.BIT_SHIFT) + (len - col);\n  let isPhase = this.board[to] & 1;\n  let isDestinationEmpty = this.board[from] & 3; //1 if player piece\n\n  if (isPhase && isDestinationEmpty) {\n    if (bypassCondition % 3) return true;else this.addMove(from, to);\n  }\n}; //reaching this function implies selected piece can be cloned, so piece is on an bounding row\n\n\nBoard.prototype.getCloneSpawnCells = function (from, bypassCondition) {\n  let spawnRow = from / this.BIT_LENGTH ^ this.BIT_LENGTH - 1;\n\n  for (let col = 1; col < 7; col++) {\n    let to = spawnRow + col;\n    let spawnCell = this.board[to];\n\n    if (!(spawnCell & 4)) {\n      if (bypassCondition % 3) return true;else this.addMove(from, to);\n    }\n  }\n};\n\nBoard.prototype.getMovesInDirection = function (from, to, bypassCondition, r, c) {\n  //check adjacent cells of piece p wrt the boundary\n  if (this.inBounds(to) && (r || c)) {\n    let cellAdj = this.board[to];\n    let isPhase = cellType(to >> this.BIT_SHIFT, to & this.BIT_LENGTH - 1) > 1;\n    if (this.isLeap(p, r, c, isPhase, cellAdj, bypassCondition)) return true;\n\n    if (cellAdj.who !== null) {\n      if (this.isJump(p, r, c, cellAdj, bypassCondition)) return true;\n    } else if (bypassCondition % 3 % 2) return true; //adjacent moves\n    else if (!bypassCondition) cellAdj.move = true;\n  }\n\n  return false;\n};\n/* bypassCondition (HIGHLIGHT BYPASS CONDITION):\n\t\tundefined - default (Store all),\n\t\t1 - bypass all,\n\t\t2 - bypass continuable moves,\n\t\t3 - store continuable moves\n*/\n\n\nBoard.prototype.getMoves = function (from, bypassCondition, r, c) {\n  let row = from >> this.BIT_SHIFT,\n      col = from & this.BIT_LENGTH - 1;\n  if (this.canPhase(from, row, col, bypassCondition)) return true;\n  if (this.canClone(from)) if (this.getCloneSpawnCells(from, bypassCondition)) return true;\n\n  if (r != null && c != null) {\n    //if move continuation\n    if (this.getMovesInDirection(from, row + r << this.BIT_SHIFT + (col + c), bypassCondition, r, c)) return true;\n  } else {\n    for (r = -1; r < 2; r++) for (c = -1; c < 2; c++) {\n      //initial moves\n      if (this.getMovesInDirection(from, row, col, bypassCondition, r, c)) return true;\n    }\n  }\n\n  return false;\n}; //Performs move. returns true if caught piece in process, else false\n//NOTE: it is impossible to capture a piece at board index 0\n\n\nBoard.prototype.doMove = function (pi, row, col) {\n  let p = this.pieces[pi]; //begin move\n\n  this.board[p.row][p.col].who = null;\n  let destinationCell = this.board[row][col];\n  let caught = typeof destinationCell.move === \"number\" ? destinationCell.move : false; //caught piece index\n  // moveDirection is defined if and only if any of the following is true (for moving piece p):\n\n  let moveDirection; // (1) p caught a piece\n\n  if (caught) {\n    let c = this.pieces[caught];\n    c.alive = false;\n    this.board[c.row][c.col].who = null; //return direction of move\n    //If leap, then c adjacent at start XOR c adjacent at end\n    //Check adjacency of moving piece to captured piece on starting position and ending position\n\n    let cellAdjStartPos = Math.abs(c.row - p.row) < 2 && Math.abs(c.col - p.col) < 2;\n    let cellAdjEndPos = Math.abs(row - c.row) < 2 && Math.abs(col - c.col) < 2;\n    moveDirection = cellAdjStartPos && cellAdjEndPos ? {\n      rowIncr: Math.sign(row - c.row),\n      colIncr: Math.sign(col - c.col)\n    } //jump\n    : cellAdjStartPos ? {\n      rowIncr: Math.sign(c.row - p.row),\n      colIncr: Math.sign(c.col - p.row)\n    } //leap-> piece adj to capture on start\n    : {\n      rowIncr: Math.sign(row - c.row),\n      colIncr: Math.sign(col - c.col)\n    };\n  } // (2) p LANDS on a phase cell. That is, this move is not a phase.\n  else if (!this.samePhase(p, {\n      row: row,\n      col: col\n    })) moveDirection = {\n      rowIncr: 0,\n      colIncr: 0\n    }; //end move\n\n\n  this.board[row][col].who = pi;\n  p.row = row;\n  p.col = col; // (3) p is able to be cloned\n\n  if (this.canClone(pi)) moveDirection = {\n    rowIncr: 0,\n    colIncr: 0\n  };\n  this.updateBoard();\n  return moveDirection;\n};\n\nBoard.prototype.highlightMoves = function (pi) {\n  let nMoves = this.moves[pi].length;\n\n  for (let i = 0; i < nMoves; i++) {\n    let destinationIndex = this.moves[pi][i] & this.BIT_AREA - 1;\n    this.board[destinationIndex] |= 2;\n  }\n};\n\nBoard.prototype.removeHighlight = function () {\n  for (let i = 0; i < this.area; i++) {\n    if (this.board[i] & 2) this.board[i] = this.board[i] ^ 2;\n  }\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tINTEGRITY\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n//Don't need -> can use dest cell shit\n\n\nBoard.prototype.samePhase = function (from, to) {\n  let isDestinationPhase = cellType(to.row, to.col);\n  return isDestinationPhase > 1 && isDestinationPhase === cellType(from.row, from.col);\n};\n\nBoard.prototype.inBounds = function (index) {\n  return 0 <= index && index < this.BIT_AREA;\n};\n\nBoard.prototype.canContinueMove = function (pi, dir) {\n  return dir ? this.getMoves(pi, 2, dir.rowIncr, dir.colIncr) : false;\n};\n\nBoard.prototype.hasMoves = function (pi) {\n  return this.getMoves(pi, 1);\n}; //Player has no more moves when (1): all player's pieces are dead (2): every piece has no moves\n\n\nBoard.prototype.movesLeft = function (player) {\n  for (let pi = 0; pi < this.pieces.length; pi++) {\n    let p = this.pieces[pi];\n\n    if (p.alive && p.player === player) {\n      if (this.hasMoves(pi)) return true;\n    }\n  }\n\n  return false;\n};\n\nBoard.prototype.validMove = function (row, col) {\n  return this.board[row][col].move;\n};\n\nexport default Board;","map":{"version":3,"sources":["/Users/bacchus/git/Leap/src/js/board.js"],"names":["toIndex","getRow","getCol","cellType","phaseLayouts","Board","len","phaseLayout","p1","p2","area","BIT_SHIFT","getBitShift","BIT_LENGTH","BIT_AREA","board","length","moves","fill","bufferSize","init","prototype","layout","pi","calcPhases","index","k","i","initPiece","j","getPlayer","addMove","from","to","captured","push","update","newPiece","map","row","cell","who","piecesSeparator","pieces","alive","move","makeClone","col","updateBoard","canClone","piece","onBoundingColumn","onBoundingRow","spawnRow","isLeap","p","rowIncr","colIncr","isPhase","cellAdj","bypassCondition","destinationCell","phaseAdj","phaseFar","capt","isJump","inBounds","player","canPhase","isDestinationEmpty","getCloneSpawnCells","spawnCell","getMovesInDirection","r","c","getMoves","doMove","caught","moveDirection","cellAdjStartPos","Math","abs","cellAdjEndPos","sign","samePhase","highlightMoves","nMoves","destinationIndex","removeHighlight","isDestinationPhase","canContinueMove","dir","hasMoves","movesLeft","validMove"],"mappings":"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","sourcesContent":["import {toIndex, getRow, getCol, cellType, phaseLayouts} from './util';\nimport './Leap.js'\n//single, phase, jump, super-jump\n/*\nadj: adjacent\nphase: change portal side\nleap: capture piece while jumping through a portal\njitch: jump, then phase\nswump: switch, then jump\n}\n\nREFACTOR CHANGES:\nLeap.js -> Game.js\n\t<Leap> -> <GameController>\nboard.js -> leap.js\n\n\nBITWISE:\n\nBOARD:\nbit\t\t\t\titem\n0-1\t\t\t\tcellType\t{regular, phase} x {highlight, no highlight}\n2-3\t\t\tcellState\t\t{00: empty, 10: SPECIAL, 01: p1, 11: p2, }   NOTE, if '10' for bits 1 and 2, then it should be a SPECIAL THING???  lmao what if a piece can be moved by either player for a few turns?\n4\t\t\t\t\tisCloned\n5-9\t\t\t\tkey\t\t\t\tIf piece on cell, this is index to reach it\n\nboard[i] = (key << 4 | isCloned << 3 | cellState << 1 | cellType);\nfor i = row * SIZE + col \t\twhere row, col wtr a given piece\n\nPIECE INDEX:\nbit \t\t\titem\n0-2\t\t\t\tcol\n3-(5,6)\t\trow\n\nboard[i] = (row << 4 | col);\nfor i = SIZE*SIZE + key\t\t\twhere\n\n\nhow to store moves\nmoves[i] = [ 0 <= board_index < SIZE*SIZE, ... , ... ] all possible moves for associated piece.\nfor i = SIZE*SIZE + key\n\n\n\nindex = cell number\nkey = piece index\n\n*/\n\n\n//can I generate layouts on seeds? lmao\n\n\nfunction Board(len, phaseLayout) {\n\n\tthis.p1 = 4;\n\tthis.p2 = 12;\n\n\tthis.len = len;\n\tthis.area = len*len;\n\tthis.BIT_SHIFT = getBitShift(len-1);\n\tthis.BIT_LENGTH = 2**this.BIT_SHIFT;\n\tthis.BIT_AREA = 2**(this.BIT_SHIFT*2);\n\n\t(this.board = []).length = this.area;\n\t(this.moves = []).length = 4*len;\n\n\tthis.board.fill(0);\n\tthis.bufferSize = 1;\t//how many rows between the pieces' starting location and the nearest phases\n\tthis.init(phaseLayout);\n\t//this.update();\n}\n\n\n\nBoard.prototype.init = function (layout) {\n    let pi=0; //piece Index (ID)\n\t\tconst len = this.len;\n\n\t\tconst calcPhases = (index) => {\n\t\t\tlet k = 0;\n\t\t\twhile(k<phaseLayouts[layout].length) {\n\t\t\t\tif ( (index^phaseLayouts[layout][k]) === 0 ) return 1;\n\t\t\t\tk++;\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\n\t\tfor(let i=0; i<len; i++) {\n\t\t\tthis.board[i] = ( (pi << 5) | this.p1); //00000 0 01 00\n\t\t\tthis.initPiece(pi);\n\t\t\tthis.board[i + (len-1)*len] = ( (pi + 2*this.BIT_LENGTH << 5) | this.p2); //100000 0 11 00\n\t\t\tthis.initPiece(pi + 2*len);\n\t\t\tpi++;\n\n\t\t\tfor(let j=1+this.bufferSize; j<len-1-this.bufferSize; j++) {\n\t\t\t\tthis.board[i + j*len] |= calcPhases(i+j*len);\n\t\t\t}\n\t\t}\n}\n\nBoard.prototype.initPiece = function (pi) {\n\tthis.moves[pi] = [];\n}\n\nBoard.prototype.getPlayer = function (index) {\n\treturn ( (this.board[index] & 12) < 12 ) ? this.p1 : this.p2;\n}\n\n// moves[pi] = [0000000 0000000] --> [board index of captured piece + board index of destination cell]\nBoard.prototype.addMove = function (from, to, captured) {\n\tcaptured = captured || 0;\n\tlet pi = (this.board[from] >> 5);\n\tthis.moves[pi].push( (captured << 2*this.BIT_SHIFT) + to );\n}\n\nBoard.prototype.update = function (newPiece) {\n\tif (newPiece) {\n\t\t//find out which player this piece belongs to then add it within that player's key range (00000)\n\t\tthis.board = this.board.map(row => row.map((cell, j) => {\n\t\t\tif (cell.who != null) { //increment all pi in board after piecesSeparator by one\n\t\t\t\tif (cell.who >= this.piecesSeparator) cell.who++;\n\t\t\t\t//if piece alive, keep on board\n\t\t\t\treturn this.pieces[cell.who].alive ? {who: cell.who, move:false} : {who: null, move:false};\n\t\t\t} else return {who: null, move: false};\n\t\t}));\n\t} else {\n\t\tthis.board = this.board.map(row => row.map((cell, j) =>\n\t\t\t(cell.who != null)\n\t\t\t? (this.pieces[cell.who].alive\n\t\t\t\t? {who: cell.who, move:false}\n\t\t\t\t: {who: null, move:false})\n\t\t\t: {who: null, move: false}\n\t\t));\n\t}\n}\n\n\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n/* DEPRECIATED: we use bit shifts now\n//Calls every time a clone is made\nBoard.prototype.insertAtSeparationIndex = function () {\n\tfor(let pi=this.piecesSeparator; pi<this.pieces.length; pi++) {\n\t\t//Finds index that separates p1 and p2 pieces\n\t\tif(this.pieces[pi].player !== this.p2) {\n\t\t\tthis.piecesSeparator = pi; //update\n\t\t\treturn pi;\n\t\t}\n\t}\n}\n*/\nBoard.prototype.makeClone = function (pi, row, col) {\n\t/*\n\tgetPlayer bit\n\t*/\n\tthis.board[row*this.len + col] |= this.getPlayer(row, col)\n\tthis.updateBoard(true);\n\tthis.board[row][col].who = this.piecesSeparator;\n\treturn true;\n}\n\nBoard.prototype.canClone = function (i) {\n\tlet row = i/this.BIT_LENGTH, piece = this.board[i];\n\tlet onBoundingColumn = (i+1)%this.BIT_LENGTH < 2;\n\tlet onBoundingRow = (row + 1)%this.BIT_LENGTH < 2;\n\n\tif(onBoundingColumn || !onBoundingRow || (piece & 16) ) return false;\n\n\tlet spawnRow = (( (piece >> 5) & 2*this.BIT_LENGTH ) - 1) / 2;\n\treturn (row ^ spawnRow);\n}\n\n/* DEPRECIATED: not used\nBoard.prototype.isCloneSpawn = function (pi, row, col) {\n\treturn this.canClone(pi) && this.board[row][col].who === null;\n}\n*/\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n// Board.prototype.getPlayer = function (pi) {\n// \treturn this.pieces[pi].player;\n// }\n\nBoard.prototype.isLeap = function (p, rowIncr, colIncr, isPhase, cellAdj, bypassCondition) {\n\t//if neighbor cell is a phase, leap_cell clear, and (enemy piece on phaseAdj XOR enemy piece on phaseFar)\n\tlet destinationCell = this.board[7 - p.row][7 - p.col];\n\tif(isPhase && !destinationCell.who) {\n\t\tlet phaseAdj = cellAdj.who;\n\t\tlet phaseFar = this.board[7 - (p.row + rowIncr)][7 - (p.col + colIncr)].who;\n\t\tif((phaseAdj || phaseFar) && !(phaseAdj && phaseFar)) { //xor filter. Only one may be true\n\t\t\tlet capt = phaseAdj ? phaseAdj : phaseFar;\n\t\t\t//if 0, add to destinationCell.move, if 1,\n\t\t\tif (bypassCondition) return true;\n\t\t\telse destinationCell.move = capt;\n\t\t}\n\t}\n}\n\nBoard.prototype.isJump = function (p, rowIncr, colIncr, cellAdj, bypassCondition) {\n\t//if adj cell occupied, jumpCell in bounds, jumpCell clear, and jumpCell has enemy piece\n\tif(this.inBounds(p.row + rowIncr*2, p.col + colIncr*2)) {\n\t\tlet destinationCell = this.board[p.row + rowIncr*2][p.col + colIncr*2];\n\t\tif (this.getPlayer(cellAdj.who) !== p.player && destinationCell.who === null) {\n\t\t\tif(bypassCondition%3) return true;\n\t\t\telse destinationCell.move = cellAdj.who;\n\t\t}\n\t}\n}\n\nBoard.prototype.canPhase = function (from, row, col, bypassCondition) {\n\tlet len= this.len - 1;\n\t//j = 7-row_index + 7-col_index\n\tlet to = ( (len - row) << this.BIT_SHIFT ) + (len - col);\n\tlet isPhase = (this.board[to] & 1);\n\tlet isDestinationEmpty = (this.board[from] & 3); //1 if player piece\n\tif(isPhase && isDestinationEmpty) {\n\t\tif (bypassCondition%3) return true;\n\t\telse this.addMove(from, to);\n\t}\n}\n\n//reaching this function implies selected piece can be cloned, so piece is on an bounding row\nBoard.prototype.getCloneSpawnCells = function (from, bypassCondition) {\n\tlet spawnRow = ( from/this.BIT_LENGTH ^ (this.BIT_LENGTH - 1) );\n\tfor(let col=1; col<7;col++) {\n\t\tlet to = spawnRow + col;\n\t\tlet spawnCell = this.board[to];\n\t\tif ( !(spawnCell & 4) ) {\n\t\t\tif (bypassCondition%3) return true;\n\t\t\telse this.addMove(from, to);\n\t\t}\n\t}\n}\n\nBoard.prototype.getMovesInDirection = function (from, to, bypassCondition, r, c) {\n\t//check adjacent cells of piece p wrt the boundary\n\n\tif(this.inBounds(to) && (r || c)) {\n\t\tlet cellAdj = this.board[to];\n\t\tlet isPhase = cellType( to >> this.BIT_SHIFT, to & (this.BIT_LENGTH-1) ) > 1;\n\n\t\tif (this.isLeap(p, r, c, isPhase, cellAdj, bypassCondition)) return true;\n\t\tif (cellAdj.who !== null) {\n\t\t\tif (this.isJump(p, r, c, cellAdj, bypassCondition)) return true;\n\t\t}\n\t\telse if (bypassCondition%3%2) return true;\t//adjacent moves\n\t\telse if (!bypassCondition) cellAdj.move = true;\n\t}\n\treturn false;\n}\n\n/* bypassCondition (HIGHLIGHT BYPASS CONDITION):\n\t\tundefined - default (Store all),\n\t\t1 - bypass all,\n\t\t2 - bypass continuable moves,\n\t\t3 - store continuable moves\n*/\nBoard.prototype.getMoves = function (from, bypassCondition, r, c) {\n\tlet row = (from >> this.BIT_SHIFT), col = (from & (this.BIT_LENGTH-1));\n\tif (this.canPhase(from, row, col, bypassCondition)) return true;\n\tif (this.canClone(from)) if(this.getCloneSpawnCells(from, bypassCondition)) return true;\n\n\tif (r != null && c != null) { //if move continuation\n\t\tif (this.getMovesInDirection(from, (row + r) << this.BIT_SHIFT + (col + c), bypassCondition, r, c)) return true;\n\t} else {\n\t\tfor(r=-1;r<2;r++) for(c=-1;c<2; c++) { //initial moves\n\t\t\tif (this.getMovesInDirection(from, row, col, bypassCondition, r, c)) return true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n//Performs move. returns true if caught piece in process, else false\n//NOTE: it is impossible to capture a piece at board index 0\nBoard.prototype.doMove = function (pi, row, col) {\n\tlet p = this.pieces[pi];\n\t//begin move\n\tthis.board[p.row][p.col].who = null;\n\n\tlet destinationCell = this.board[row][col];\n\tlet caught = typeof(destinationCell.move) === \"number\" ? destinationCell.move : false; //caught piece index\n\t// moveDirection is defined if and only if any of the following is true (for moving piece p):\n\tlet moveDirection;\n\t\t// (1) p caught a piece\n\tif (caught) {\n\t\tlet c = this.pieces[caught];\n\t\tc.alive = false;\n\t\tthis.board[c.row][c.col].who = null;\n\t\t//return direction of move\n\t\t//If leap, then c adjacent at start XOR c adjacent at end\n\t\t//Check adjacency of moving piece to captured piece on starting position and ending position\n\t\tlet cellAdjStartPos = Math.abs(c.row - p.row) < 2 && Math.abs(c.col - p.col) < 2;\n\t\tlet cellAdjEndPos = Math.abs(row - c.row) < 2 && Math.abs(col - c.col) < 2;\n\n\t\tmoveDirection = (cellAdjStartPos && cellAdjEndPos)\n\t\t\t? {rowIncr: Math.sign(row-c.row), colIncr: Math.sign(col-c.col)}\t//jump\n\t\t\t: (cellAdjStartPos\n\t\t\t\t? {rowIncr: Math.sign(c.row-p.row), colIncr: Math.sign(c.col-p.row)}\t//leap-> piece adj to capture on start\n\t\t\t\t: {rowIncr: Math.sign(row-c.row), colIncr: Math.sign(col-c.col)});\n\t}\t// (2) p LANDS on a phase cell. That is, this move is not a phase.\n\telse if (!this.samePhase(p,{row: row, col: col}))\tmoveDirection = {rowIncr: 0, colIncr: 0};\n\n\t//end move\n\tthis.board[row][col].who = pi;\n\tp.row = row;\n\tp.col = col;\n\n\t\t// (3) p is able to be cloned\n\tif (this.canClone(pi)) moveDirection = {rowIncr: 0, colIncr:0};\n\tthis.updateBoard();\n\treturn moveDirection;\n}\n\nBoard.prototype.highlightMoves = function (pi) {\n\tlet nMoves = this.moves[pi].length;\n\tfor(let i=0; i<nMoves; i++) {\n\t\tlet destinationIndex = ( this.moves[pi][i] & (this.BIT_AREA - 1) );\n\t\tthis.board[destinationIndex] |= 2;\n\t}\n}\n\nBoard.prototype.removeHighlight = function () {\n\tfor(let i=0; i<this.area; i++) {\n\t\tif(this.board[i] & 2) (this.board[i] = this.board[i] ^ 2);\n\t}\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tINTEGRITY\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n//Don't need -> can use dest cell shit\nBoard.prototype.samePhase = function (from, to) {\n\tlet isDestinationPhase = cellType(to.row, to.col);\n\treturn isDestinationPhase > 1 && isDestinationPhase === cellType(from.row, from.col);\n}\n\nBoard.prototype.inBounds = function (index) {\n\treturn 0 <= index && index < this.BIT_AREA;\n}\n\nBoard.prototype.canContinueMove = function (pi, dir) {\n\n\treturn dir ? this.getMoves(pi, 2, dir.rowIncr, dir.colIncr) : false;\n}\n\nBoard.prototype.hasMoves = function (pi) {\n\treturn this.getMoves(pi, 1);\n}\n\n//Player has no more moves when (1): all player's pieces are dead (2): every piece has no moves\nBoard.prototype.movesLeft = function (player) {\n\tfor(let pi=0; pi < this.pieces.length; pi++) {\n\t\tlet p = this.pieces[pi];\n\t\tif(p.alive && p.player === player) {\n\t\t\tif(this.hasMoves(pi)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nBoard.prototype.validMove = function (row, col) {\n\treturn this.board[row][col].move;\n}\n\nexport default Board;\n"]},"metadata":{},"sourceType":"module"}