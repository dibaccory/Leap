{"ast":null,"code":"import { BOARD_SIZE, BOARD_AREA, BIT_SIZE, BIT_MAX_PI, BIT_INDEX_SHIFT, BIT_AREA } from './board.js';\n\nfunction Node(player, from, to) {\n  this.visits = 1;\n  this.score = 0;\n  this.children = null;\n  this.to = to;\n  this.from = from;\n  this.player = player;\n} //\n// Node.prototype.opponent = function () {\n//     return this.player ^ 8;\n// }\n\n\nNode.prototype.append = function (child) {\n  if (!this.children) this.children = [child];else this.children.push(child);\n};\n\nNode.prototype.branch = function (state) {\n  state.clearMoves();\n  state.getAllMoves(state.player);\n  const shift = state.player === 12 ? BIT_MAX_PI : 0;\n\n  for (let pi = shift; pi < BIT_MAX_PI + shift; pi++) {\n    const nMoves = state.moves[pi].length;\n    const from = state.board[BOARD_AREA + pi];\n\n    for (let i = 0; i < nMoves; i++) {\n      const to = state.moves[pi][i] & BIT_AREA - 1;\n      let child = new Node(state.player, from, to);\n      this.append(child);\n    }\n  }\n};\n\nNode.prototype.playFor = function (state) {\n  return state.doMove(this.from, this.to);\n};\n\nNode.prototype.ucb = function (coeff) {\n  var score = this.score / this.visits;\n  return score + Math.sqrt(coeff / this.visits);\n};\n\nNode.prototype.findBestChild = function () {\n  const coeff = 20 * Math.log(this.visits);\n  let bestScore = -Infinity;\n  let bestChild = null;\n\n  for (let i = 0; i < this.children.length; i++) {\n    const child = this.children[i];\n    const score = child.ucb(coeff);\n\n    if (score > bestScore) {\n      bestScore = score;\n      bestChild = child;\n    }\n  }\n\n  return bestChild;\n};\n\nexport function UCT(startState, maxTime) {\n  this.root = new Node(startState.player);\n  this.startState = startState;\n  this.visitThreshold = 2 * BOARD_SIZE; // Populate the first node.\n\n  this.root.branch(startState);\n  this.history = [this.root];\n  let totalPlayouts = 0;\n  const start = Date.now();\n  let elapsedTime = 0;\n\n  while (elapsedTime < maxTime) {\n    for (var i = 0; i < 500; i++) this.run();\n\n    totalPlayouts += 500;\n    elapsedTime = Date.now() - start;\n  }\n\n  let bestChild = null;\n  let bestScore = -Infinity;\n\n  for (let i = 0; i < this.root.children.length; i++) {\n    const child = this.root.children[i];\n\n    if (child.visits > bestScore) {\n      bestChild = child;\n      bestScore = child.visits;\n    }\n  }\n\n  return {\n    elapsed: elapsedTime,\n    playouts: totalPlayouts,\n    from: bestChild.from,\n    to: bestChild.to\n  };\n}\n\nUCT.prototype.playout = function (state) {\n  let nmoves = 0;\n\n  while (++nmoves < 60) {\n    const result = state.randomMove(); //returns if won\n\n    if (result) return result;\n  }\n\n  return state.score();\n};\n\nUCT.prototype.run = function () {\n  const state = this.startState.copy();\n  let node = this.root;\n  let depth = 1;\n  let winner = 0;\n\n  while (true) {\n    if (node.children === null) {\n      if (node.visits >= this.visitThreshold * depth) {\n        node.branch(state); // Leaf node - go directly to update.\n\n        if (node.children === null) {\n          winner = node.opponent();\n          this.history[depth++] = node;\n          break;\n        }\n\n        continue;\n      }\n\n      winner = this.playout(state);\n      break;\n    }\n\n    node = node.findBestChild();\n    this.history[depth++] = node;\n\n    if (node.playFor(state)) {\n      winner = state.player;\n      break;\n    }\n  }\n\n  for (let i = 0; i < depth; i++) {\n    node = this.history[i];\n    node.visits++;\n    if (winner === node.player) node.score += 1;else if (!winner) node.score -= 1;\n  }\n};","map":{"version":3,"sources":["/Users/bacchus/git/Leap/src/js/ai.js"],"names":["BOARD_SIZE","BOARD_AREA","BIT_SIZE","BIT_MAX_PI","BIT_INDEX_SHIFT","BIT_AREA","Node","player","from","to","visits","score","children","prototype","append","child","push","branch","state","clearMoves","getAllMoves","shift","pi","nMoves","moves","length","board","i","playFor","doMove","ucb","coeff","Math","sqrt","findBestChild","log","bestScore","Infinity","bestChild","UCT","startState","maxTime","root","visitThreshold","history","totalPlayouts","start","Date","now","elapsedTime","run","elapsed","playouts","playout","nmoves","result","randomMove","copy","node","depth","winner","opponent"],"mappings":"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","sourcesContent":["import {BOARD_SIZE, BOARD_AREA, BIT_SIZE, BIT_MAX_PI, BIT_INDEX_SHIFT, BIT_AREA} from './board.js';\n\nfunction Node(player, from, to) {\n    this.visits = 1;\n    this.score = 0;\n    this.children = null;\n    this.to = to;\n    this.from = from;\n    this.player = player;\n}\n//\n// Node.prototype.opponent = function () {\n//     return this.player ^ 8;\n// }\n\nNode.prototype.append = function (child) {\n    if (!this.children) this.children = [child];\n    else this.children.push(child);\n}\n\nNode.prototype.branch = function (state) {\n    state.clearMoves();\n    state.getAllMoves(state.player);\n\n    const shift = (state.player === 12) ? BIT_MAX_PI : 0;\n    for (let pi = shift; pi < BIT_MAX_PI + shift; pi++) {\n      const nMoves = state.moves[pi].length;\n      const from = state.board[BOARD_AREA + pi];\n\n      for (let i = 0; i < nMoves; i++) {\n        const to = ( state.moves[pi][i] & (BIT_AREA - 1) );\n        let child = new Node(state.player, from, to);\n        this.append(child);\n      }\n  }\n}\n\nNode.prototype.playFor = function (state) {\n    return state.doMove(this.from, this.to);\n}\n\nNode.prototype.ucb = function (coeff) {\n    var score = (this.score / this.visits);\n    return score + Math.sqrt(coeff / this.visits);\n}\n\nNode.prototype.findBestChild = function () {\n    const coeff = 20 * Math.log(this.visits);\n    let bestScore = -Infinity;\n    let bestChild = null;\n    for (let i = 0; i < this.children.length; i++) {\n        const child = this.children[i];\n        const score = child.ucb(coeff);\n        if (score > bestScore) {\n            bestScore = score;\n            bestChild = child;\n        }\n    }\n    return bestChild;\n}\n\n\n\n\n\nexport function UCT(startState, maxTime) {\n  this.root = new Node(startState.player);\n  this.startState = startState;\n  this.visitThreshold = 2*BOARD_SIZE;\n\n  // Populate the first node.\n  this.root.branch(startState);\n  this.history = [this.root];\n\n  let totalPlayouts = 0;\n  const start = Date.now();\n  let elapsedTime = 0;\n  while (elapsedTime < maxTime) {\n      for (var i = 0; i < 500; i++) this.run();\n      totalPlayouts += 500;\n      elapsedTime = Date.now() - start;\n  }\n\n  let bestChild = null;\n  let bestScore = -Infinity;\n  for (let i = 0; i < this.root.children.length; i++) {\n      const child = this.root.children[i];\n      if (child.visits > bestScore) {\n          bestChild = child;\n          bestScore = child.visits;\n      }\n  }\n\n  return {\n    elapsed: elapsedTime,\n    playouts: totalPlayouts,\n    from: bestChild.from,\n    to: bestChild.to\n  };\n}\n\nUCT.prototype.playout = function (state) {\n    let nmoves = 0;\n\n    while (++nmoves < 60) {\n      const result = state.randomMove(); //returns if won\n      if (result) return result;\n    }\n    return state.score();\n}\n\nUCT.prototype.run = function () {\n    const state = this.startState.copy();\n    let node = this.root;\n    let depth = 1;\n    let winner = 0;\n\n    while (true) {\n      if (node.children === null) {\n        if (node.visits >= this.visitThreshold*depth) {\n          node.branch(state);\n\n          // Leaf node - go directly to update.\n          if (node.children === null) {\n            winner = node.opponent();\n            this.history[depth++] = node;\n            break;\n          }\n          continue;\n        }\n        winner = this.playout(state);\n        break;\n      }\n        node = node.findBestChild();\n        this.history[depth++] = node;\n        if (node.playFor(state)) {\n          winner = state.player;\n          break;\n        }\n    }\n\n    for (let i = 0; i < depth; i++) {\n      node = this.history[i];\n      node.visits++;\n      if (winner === node.player) node.score += 1;\n      else if (!winner) node.score -= 1;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}