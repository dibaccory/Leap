{"ast":null,"code":"//'use strict';\nimport { cellType, phaseLayouts } from './util';\n/*\n\nREFACTOR CHANGES:\nLeap.js -> Game.js\n\t<Leap> -> <GameController>\nboard.js -> leap.js\n\n\nBITWISE:\n\nBOARD:\nbit\t\t\t\titem\n0-1\t\t\t\tcellType\t{regular, phase} x {highlight, no highlight}\n2-3\t\t\tcellState\t\t{00: empty, 10: SPECIAL, 01: p1, 11: p2, }   NOTE, if '10' for bits 1 and 2, then it should be a SPECIAL THING???  lmao what if a piece can be moved by either player for a few turns?\n4\t\t\t\t\tisCloned\n5-9\t\t\t\tkey\t\t\t\tIf piece on cell, this is index to reach it\n\nboard[i] = (key << 4 | isCloned << 3 | cellState << 1 | cellType);\nfor i = row * SIZE + col \t\twhere row, col wtr a given piece\n\nPIECE INDEX:\nbit \t\t\titem\n0-2\t\t\t\tcol\n3-(5,6)\t\trow\n\nboard[i] = (row << 4 | col);\nfor i = SIZE*SIZE + key\t\t\twhere\n\n\nhow to store moves\nmoves[i] = [ 0 <= board_index < SIZE*SIZE, ... , ... ] all possible moves for associated piece.\nfor i = SIZE*SIZE\n\n\nindex = cell number\nkey = piece index\n\n*/\n\nvar BOARD_SIZE, BOARD_AREA, BIT_SIZE, BIT_MAX_PI, BIT_INDEX_SHIFT, BIT_AREA;\n\nfunction getBitShift(b) {\n  return b >> 1 ? 1 + getBitShift(b >> 1) : 1;\n}\n\nfunction Board(player, len, phaseLayout) {\n  this.player = player;\n  this.p1 = 4;\n  this.p2 = 12;\n  BOARD_SIZE = len;\n  BOARD_AREA = BOARD_SIZE ** 2;\n  BIT_SIZE = 2 ** getBitShift(BOARD_SIZE - 1);\n  BIT_MAX_PI = 2 * BIT_SIZE;\n  BIT_INDEX_SHIFT = getBitShift(BOARD_AREA - 1);\n  BIT_AREA = 2 ** BIT_INDEX_SHIFT;\n  (this.board = []).length = BOARD_AREA + 4 * len;\n  (this.moves = []).length = 4 * len;\n  this.board.fill(0, 0, BOARD_AREA - 1);\n  this.bufferSize = 1; //how many rows between the pieces' starting location and the nearest phases\n\n  this.init(phaseLayout);\n}\n\nBoard.prototype.init = function (layout) {\n  let pi = 0; //piece Index (ID)\n\n  const lastRow = (BOARD_SIZE - 1) * BOARD_SIZE;\n\n  const calcPhases = index => {\n    let k = 0;\n\n    while (k < phaseLayouts[layout].length) {\n      if ((index ^ phaseLayouts[layout][k]) === 0) return 1;\n      k++;\n    }\n\n    return 0;\n  };\n\n  this.clearMoves();\n\n  for (let i = 0; i < BOARD_SIZE; i++) {\n    this.board[i] = pi << 5 | this.p1; //00000 0 01 00\n\n    this.initPiece(pi, i);\n    this.board[i + lastRow] = pi + BIT_MAX_PI << 5 | this.p2; //100000 0 11 00\n\n    this.initPiece(pi + BIT_MAX_PI, i + lastRow);\n    pi++;\n\n    for (let j = 1 + this.bufferSize; j < BOARD_SIZE - 1 - this.bufferSize; j++) {\n      this.board[i + j * BOARD_SIZE] |= calcPhases(i + j * BOARD_SIZE);\n    }\n  }\n};\n\nBoard.prototype.initPiece = function (key, index) {\n  this.board[BOARD_AREA + key] = index;\n}; // moves[pi] = [0000000 0000000] --> [board index of captured piece + board index of destination cell]\n\n\nBoard.prototype.addMove = function (from, to, captured) {\n  captured = captured || 0;\n  const pi = this.board[from] >> 5;\n  this.moves[pi].push((captured << BIT_INDEX_SHIFT) + to);\n};\n\nBoard.prototype.clearMoves = function (pi) {\n  if (pi !== undefined) {\n    this.moves[pi] = [];\n    return;\n  }\n\n  for (let i = 0; i < 4 * BOARD_SIZE; i++) this.moves[i] = [];\n}; //Player has no more moves when (1): all player's pieces are dead (2): every piece has no moves\n\n\nBoard.prototype.movesLeft = function (player) {\n  const c = player === 12 ? BIT_MAX_PI : 0;\n\n  for (let key = c; key < 2 * BOARD_SIZE + c; key++) {\n    let piece = this.board[BOARD_AREA + key];\n    if (!(piece < 0 || piece === undefined) && this.getMoves(piece, true)) return true;\n  }\n\n  return false;\n};\n\nBoard.prototype.highlightMoves = function (piece) {\n  const nMoves = this.moves[piece].length;\n\n  for (let i = 0; i < nMoves; i++) {\n    let to = this.moves[piece][i] & BIT_AREA - 1;\n    this.board[to] |= 2;\n  }\n};\n\nBoard.prototype.removeHighlight = function () {\n  for (let i = 0; i < BOARD_AREA; i++) {\n    if (this.board[i] & 2) this.board[i] = this.board[i] ^ 2;\n  }\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n//Assume special tiles won't appear on spawn rows\n\n\nBoard.prototype.makeClone = function (from, to) {\n  const player = this.getPlayer(from);\n  const c = player === 12 ? BIT_MAX_PI : 0;\n  let key; //Find first empty slot\n\n  for (key = BOARD_SIZE + c; key < 2 * BOARD_SIZE + c; key++) {\n    if (this.board[BOARD_AREA + key] === undefined) {\n      this.board[BOARD_AREA + key] = to;\n      this.board[to] = key << 5 | player | 16;\n      this.board[from] |= 16;\n      break;\n    }\n  }\n};\n\nBoard.prototype.onCloningCell = function (from) {\n  const onRow = from / BOARD_SIZE;\n  const piece = this.board[from];\n  const onBoundaryColumn = (from + 1) % BOARD_SIZE < 2;\n  const onBoundaryRow = (onRow + 1) % BOARD_SIZE < 2; //To clone: NOT be on boundary column, BE on boundary row, NOT be cloned yet\n\n  if (onBoundaryColumn || !onBoundaryRow || piece & 16) return false;\n  const spawnRow = piece >> 5 & BIT_MAX_PI ? BOARD_SIZE - 1 : 0;\n  return onRow ^ spawnRow;\n}; //Assumes valid move\n\n\nBoard.prototype.isCloneMove = function (from, to) {\n  //if on cloning cell, suffice to show if destination is on spawn row\n  const spawnRow = this.board[from] >> 5 & BIT_MAX_PI ? BOARD_SIZE - 1 : 0;\n  return this.onCloningCell(from) && Math.floor(to / BOARD_SIZE) === spawnRow;\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVE LOGIC\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n// Board.prototype.getPlayer = function (pi) {\n// \treturn this.pieces[pi].player;\n// }\n\n\nBoard.prototype.canLeap = function (from, adj, bypass) {\n  const to = this.getInverseIndex(from); //DOES NOT CONSIDER SPECIAL PIECE '10'\n\n  if (this.getPlayer(to)) return;\n  const player = this.getPlayer(from);\n  const inv = this.getInverseIndex(adj);\n  const phaseAdj = this.getPlayer(adj);\n  const phaseFar = this.getPlayer(inv);\n\n  if ((phaseAdj ^ phaseFar ^ player) === 8) {\n    if (bypass) return true;else this.addMove(from, to, phaseAdj ? adj : inv);\n  } //if neighbor cell is a phase, leap_cell clear, and (enemy piece on phaseAdj XOR enemy piece on phaseFar)\n\n};\n\nBoard.prototype.canJump = function (from, direction, bypass) {\n  //if adj cell occupied, jumpCell in bounds, jumpCell clear, and jumpCell has enemy piece\n  const adj = from + direction;\n  const to = adj + direction;\n\n  if (this.inBounds(to) && !this.getPlayer(to)) {\n    if (bypass) return true;else this.addMove(from, to, adj);\n  }\n};\n\nBoard.prototype.isPhaseMove = function (from, to, captured) {\n  const bothPhases = this.board[from] & this.board[to] & 1;\n  return !captured && bothPhases && this.getInverseIndex(from) === to;\n};\n\nBoard.prototype.canPhase = function (from, to, bypass) {\n  const isPhase = this.board[from] & 1;\n  const isDestinationEmpty = !(this.board[to] & 4); //1 if player piece\n\n  if (isPhase && isDestinationEmpty) {\n    if (bypass) return true;else this.addMove(from, to);\n  }\n}; //reaching this function implies selected piece can be cloned, so piece is on a bounding row\n\n\nBoard.prototype.getSpawnCells = function (from, bypass) {\n  const spawnRow = from / BOARD_SIZE ^ BOARD_SIZE - 1;\n\n  for (let col = 1; col < BOARD_SIZE - 1; col++) {\n    let to = spawnRow * BOARD_SIZE + col;\n    let spawnCellEmpty = !(this.board[to] & 4); //if spawnCell doesn't have a player on it\n\n    if (spawnCellEmpty) {\n      if (bypass) return true;else this.addMove(from, to);\n    }\n  }\n};\n\nBoard.prototype.getMovesInDirection = function (from, direction, bypass) {\n  //check adjacent cells of piece p wrt the boundary\n  const adj = from + direction;\n  const isPhase = this.board[adj] & 1;\n  if (isPhase && this.canLeap(from, adj, bypass)) return true;\n\n  if ((this.getPlayer(adj) ^ this.getPlayer(from)) === 8) {\n    if (this.canJump(from, direction, bypass)) return true;\n  } else if (bypass) return true;else this.addMove(from, adj);\n}; //bypass: if you want to see if this piece is able to move\n\n\nBoard.prototype.getMoves = function (from, bypass) {\n  const bCol = (from + 1) % BOARD_SIZE < 2 ? (from + 1) % BOARD_SIZE : undefined;\n\n  for (let r = -1; r < 2; r++) {\n    for (let c = -1 + (bCol === 1 ? 1 : 0); c < 2 - (bCol === 0 ? 1 : 0); c++) {\n      let direction = r * BOARD_SIZE + c;\n      let adj = from + direction; //enemy or empty cell\n\n      let validDirection = this.getPlayer(adj) ^ this.getPlayer(from) && this.inBounds(adj) && direction;\n      if (validDirection && this.getMovesInDirection(from, direction, bypass)) return true;\n    }\n  }\n\n  const inv = this.getInverseIndex(from); // phase condition\n\n  if (!this.isRedundantMove(from, inv) && this.canPhase(from, inv, bypass)) return true; // clone condition\n\n  if (!(this.board[from] & 16) && this.onCloningCell(from) && this.getSpawnCells(from, bypass)) return true;\n};\n\nBoard.protoype.getAllMoves = function (player) {\n  const c = player === 12 ? BIT_MAX_PI : 0;\n\n  for (let key = c; key < 2 * BOARD_SIZE + c; key++) {\n    let from = this.board[BOARD_AREA + key];\n    if (!(from === undefined || from < 0)) this.getMoves(from);\n  }\n}; //Performs move. returns true if caught piece in process, else false\n//NOTE: it is impossible to capture a piece at board index 0\n\n\nBoard.prototype.doMove = function (from, to) {\n  if (this.isCloneMove(from, to)) {\n    this.makeClone(from, to);\n    this.removeHighlight();\n    this.clearMoves();\n    return;\n  }\n\n  const pi = this.board[from] >> 5;\n  const capturedPiece = this.getCapturedPiece(pi, to);\n  this.removeHighlight();\n  this.clearMoves();\n  const piece = pi << 5 | this.board[from] & 16 | this.getPlayer(from);\n\n  if ((this.board[to] & 12) === 8) {\n    //SPECIAL PIECE *any player can move.... but how is TODO*\n    this.board[to] |= pi << 5;\n  } else {\n    //We can assume this cell is empty\n    this.board[to] |= piece;\n  }\n\n  if (capturedPiece) {\n    const ci = this.board[capturedPiece] >> 5;\n    this.board[capturedPiece] &= 3;\n    this.board[BOARD_AREA + ci] = ~this.board[BOARD_AREA + ci]; //He DED\n    //if Leap, then we get the direction by the difference between captured index and adjacent movement cell\n\n    const capturedAdjToDestination = -9 <= to - capturedPiece && to - capturedPiece <= 9;\n    const capturedDirection = capturedAdjToDestination ? to - capturedPiece : capturedPiece - from; //if can continue move in direction\n\n    let adj = to + capturedDirection;\n    if (this.board[adj] & 1) this.canLeap(to, adj);\n    if (this.getPlayer(adj) ^ this.getPlayer(to) === 2) this.canJump(to, capturedDirection);\n  } //const isLeap = capturedPiece && alreadyPhased;\n\n\n  const canPhase = this.board[to] & 1 && !this.isPhaseMove(from, to, capturedPiece);\n  const canClone = this.onCloningCell(to) && !this.onCloningCell(from); //If can clone or is on phase that piece hasn't just travelled through\n\n  if (canPhase) this.canPhase(to, this.getInverseIndex(to));\n  if (canClone) this.getSpawnCells(to);\n  this.board[from] &= 3; //keep only cell data\n\n  this.board[BOARD_AREA + pi] = to; //What if we return length of this.moves[pi] to determine if move can be continued? Then we don't need to call all these checkers\n\n  return this.moves[pi].length;\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tREFERENCES\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n\nBoard.prototype.getPlayer = function (index) {\n  const pid = this.board[index] & 12;\n\n  switch (pid) {\n    case 12:\n      return this.p2;\n\n    case 4:\n      return this.p1;\n\n    default:\n      return 0;\n  }\n};\n\nBoard.prototype.getCapturedPiece = function (pid, to) {\n  const nMoves = this.moves[pid].length;\n\n  for (let i = 0; i < nMoves; i++) {\n    let move = this.moves[pid][i];\n    let capturedPiece = move >> BIT_INDEX_SHIFT;\n    if ((move & BIT_AREA - 1) === to && capturedPiece) return capturedPiece;\n  }\n}; //ONLY WORKS on NxN boards and phase group orders of 2\n\n\nBoard.prototype.getInverseIndex = function (index) {\n  return BOARD_AREA - 1 - index;\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tUTILITY\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n\nBoard.prototype.isRedundantMove = function (from, to) {\n  const pi = this.board[from] >> 5;\n  const n = this.moves[pi].length;\n\n  for (let i = 0; i < n; i++) {\n    if ((this.moves[pi][i] & BIT_AREA - 1) === to) return true;\n  }\n\n  return false;\n};\n\nBoard.prototype.inBounds = function (index) {\n  return 0 <= index && index < BOARD_AREA;\n};\n\nBoard.prototype.validMove = function (piece, index) {\n  const n = this.moves[piece].length;\n  let isAvailableMove = 0;\n\n  for (let i = 0; i < n; i++) {\n    if ((this.moves[piece][i] & BIT_AREA - 1) === index) isAvailableMove++;\n  }\n\n  return !!isAvailableMove;\n};\n\nBoard.prototype.copy = function (board) {};\n\nexport default Board;","map":{"version":3,"sources":["/Users/bacchus/git/Leap/src/js/board.js"],"names":["cellType","phaseLayouts","BOARD_SIZE","BOARD_AREA","BIT_SIZE","BIT_MAX_PI","BIT_INDEX_SHIFT","BIT_AREA","getBitShift","b","Board","player","len","phaseLayout","p1","p2","board","length","moves","fill","bufferSize","init","prototype","layout","pi","lastRow","calcPhases","index","k","clearMoves","i","initPiece","j","key","addMove","from","to","captured","push","undefined","movesLeft","c","piece","getMoves","highlightMoves","nMoves","removeHighlight","makeClone","getPlayer","onCloningCell","onRow","onBoundaryColumn","onBoundaryRow","spawnRow","isCloneMove","Math","floor","canLeap","adj","bypass","getInverseIndex","inv","phaseAdj","phaseFar","canJump","direction","inBounds","isPhaseMove","bothPhases","canPhase","isPhase","isDestinationEmpty","getSpawnCells","col","spawnCellEmpty","getMovesInDirection","bCol","r","validDirection","isRedundantMove","protoype","getAllMoves","doMove","capturedPiece","getCapturedPiece","ci","capturedAdjToDestination","capturedDirection","canClone","pid","move","n","validMove","isAvailableMove","copy"],"mappings":"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","sourcesContent":["//'use strict';\nimport {cellType, phaseLayouts} from './util';\n\n/*\n\nREFACTOR CHANGES:\nLeap.js -> Game.js\n\t<Leap> -> <GameController>\nboard.js -> leap.js\n\n\nBITWISE:\n\nBOARD:\nbit\t\t\t\titem\n0-1\t\t\t\tcellType\t{regular, phase} x {highlight, no highlight}\n2-3\t\t\tcellState\t\t{00: empty, 10: SPECIAL, 01: p1, 11: p2, }   NOTE, if '10' for bits 1 and 2, then it should be a SPECIAL THING???  lmao what if a piece can be moved by either player for a few turns?\n4\t\t\t\t\tisCloned\n5-9\t\t\t\tkey\t\t\t\tIf piece on cell, this is index to reach it\n\nboard[i] = (key << 4 | isCloned << 3 | cellState << 1 | cellType);\nfor i = row * SIZE + col \t\twhere row, col wtr a given piece\n\nPIECE INDEX:\nbit \t\t\titem\n0-2\t\t\t\tcol\n3-(5,6)\t\trow\n\nboard[i] = (row << 4 | col);\nfor i = SIZE*SIZE + key\t\t\twhere\n\n\nhow to store moves\nmoves[i] = [ 0 <= board_index < SIZE*SIZE, ... , ... ] all possible moves for associated piece.\nfor i = SIZE*SIZE\n\n\nindex = cell number\nkey = piece index\n\n*/\nvar BOARD_SIZE, BOARD_AREA, BIT_SIZE, BIT_MAX_PI, BIT_INDEX_SHIFT, BIT_AREA;\n\nfunction getBitShift(b) {\n  return (b >> 1) ? (1 + getBitShift(b >> 1)) : 1;\n}\n\n\nfunction Board(player, len, phaseLayout) {\n\tthis.player = player;\n\tthis.p1 = 4;\n\tthis.p2 = 12;\n\n\tBOARD_SIZE = len;\n\tBOARD_AREA = BOARD_SIZE**2;\n\tBIT_SIZE = 2**getBitShift(BOARD_SIZE-1);\n\tBIT_MAX_PI = 2*BIT_SIZE;\n\tBIT_INDEX_SHIFT = getBitShift(BOARD_AREA-1);\n\tBIT_AREA = 2**BIT_INDEX_SHIFT;\n\n\n\n\t(this.board = []).length = BOARD_AREA + 4*len;\n\t(this.moves = []).length = 4*len;\n\tthis.board.fill(0, 0, BOARD_AREA-1);\n\tthis.bufferSize = 1;\t//how many rows between the pieces' starting location and the nearest phases\n\tthis.init(phaseLayout);\n\n}\n\n\n\nBoard.prototype.init = function (layout) {\n    let pi=0; //piece Index (ID)\n\t\tconst lastRow = (BOARD_SIZE-1)*BOARD_SIZE;\n\n\t\tconst calcPhases = (index) => {\n\t\t\tlet k = 0;\n\t\t\twhile(k<phaseLayouts[layout].length) {\n\t\t\t\tif ( (index^phaseLayouts[layout][k]) === 0 ) return 1;\n\t\t\t\tk++;\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\t\tthis.clearMoves();\n\t\tfor (let i=0; i<BOARD_SIZE; i++) {\n\t\t\tthis.board[i] = ( (pi << 5) | this.p1); //00000 0 01 00\n\t\t\tthis.initPiece(pi, i);\n\n\t\t\tthis.board[i + lastRow] = ( (pi + BIT_MAX_PI << 5) | this.p2); //100000 0 11 00\n\t\t\tthis.initPiece(pi + BIT_MAX_PI, i + lastRow);\n\t\t\tpi++;\n\n\t\t\tfor (let j=1+this.bufferSize; j<(BOARD_SIZE-1)-this.bufferSize; j++) {\n\t\t\t\tthis.board[i + j*BOARD_SIZE] |= calcPhases(i+j*BOARD_SIZE);\n\t\t\t}\n\t\t}\n}\n\nBoard.prototype.initPiece = function (key, index) {\n\tthis.board[BOARD_AREA + key] = index;\n}\n\n\n// moves[pi] = [0000000 0000000] --> [board index of captured piece + board index of destination cell]\nBoard.prototype.addMove = function (from, to, captured) {\n\tcaptured = captured || 0;\n\tconst pi = (this.board[from] >> 5);\n\tthis.moves[pi].push( (captured << (BIT_INDEX_SHIFT) ) + to );\n}\n\nBoard.prototype.clearMoves = function (pi) {\n\tif (pi !== undefined) {\n\t\tthis.moves[pi] = [];\n\t\treturn;\n\t}\n\tfor (let i=0; i<4*BOARD_SIZE; i++) this.moves[i] = [];\n}\n\n//Player has no more moves when (1): all player's pieces are dead (2): every piece has no moves\nBoard.prototype.movesLeft = function (player) {\n\tconst c = (player === 12) ? BIT_MAX_PI : 0;\n\tfor (let key=c; key < 2*BOARD_SIZE + c; key++) {\n\t\tlet piece = this.board[BOARD_AREA + key];\n\t\tif ( !(piece < 0 || piece === undefined) && this.getMoves(piece, true) ) return true;\n\t}\n\treturn false;\n}\n\nBoard.prototype.highlightMoves = function (piece) {\n\tconst nMoves = this.moves[piece].length;\n\tfor (let i=0; i<nMoves; i++) {\n\t\tlet to = ( this.moves[piece][i] & (BIT_AREA - 1) );\n\t\tthis.board[to] |= 2;\n\t}\n}\n\nBoard.prototype.removeHighlight = function () {\n\tfor (let i=0; i<BOARD_AREA; i++) {\n\t\tif (this.board[i] & 2) (this.board[i] = this.board[i] ^ 2);\n\t}\n}\n\n\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n//Assume special tiles won't appear on spawn rows\nBoard.prototype.makeClone = function (from, to) {\n\tconst player = this.getPlayer(from);\n\tconst c = (player === 12) ? BIT_MAX_PI : 0;\n\tlet key;\n\t//Find first empty slot\n\tfor (key= BOARD_SIZE+c; key< 2*BOARD_SIZE+c; key++) {\n\t\tif (this.board[BOARD_AREA + key] === undefined) {\n\t\t\tthis.board[BOARD_AREA + key] = to;\n\t\t\tthis.board[to] = (key << 5) | player | 16;\n\t\t\tthis.board[from] |= 16;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nBoard.prototype.onCloningCell = function (from) {\n\tconst onRow = from/BOARD_SIZE\n\tconst piece = this.board[from];\n\tconst onBoundaryColumn = (from+1)%BOARD_SIZE < 2;\n\tconst onBoundaryRow = (onRow + 1)%BOARD_SIZE < 2;\n\n\t//To clone: NOT be on boundary column, BE on boundary row, NOT be cloned yet\n\tif (onBoundaryColumn || !onBoundaryRow || (piece & 16) ) return false;\n\n\tconst spawnRow = ( (piece >> 5) & BIT_MAX_PI ) ? (BOARD_SIZE-1) : 0;\n\treturn (onRow ^ spawnRow);\n}\n//Assumes valid move\nBoard.prototype.isCloneMove = function (from, to) {\n\t//if on cloning cell, suffice to show if destination is on spawn row\n\tconst spawnRow = ( (this.board[from] >> 5) & BIT_MAX_PI ) ? (BOARD_SIZE - 1) : 0;\n\treturn this.onCloningCell(from) && (Math.floor(to/BOARD_SIZE) === spawnRow);\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVE LOGIC\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n// Board.prototype.getPlayer = function (pi) {\n// \treturn this.pieces[pi].player;\n// }\n\nBoard.prototype.canLeap = function (from, adj, bypass) {\n\tconst to = this.getInverseIndex(from);\n\n\t//DOES NOT CONSIDER SPECIAL PIECE '10'\n\tif (this.getPlayer(to)) return;\n\n\tconst player = this.getPlayer(from);\n\tconst inv = this.getInverseIndex(adj);\n\tconst phaseAdj = this.getPlayer(adj);\n\tconst phaseFar = this.getPlayer(inv);\n\n\tif ( (phaseAdj ^ phaseFar ^ player) === 8 ) {\n\t\tif (bypass) return true;\n\t\telse this.addMove(from, to, (phaseAdj ? adj : inv));\n\t}\n\t//if neighbor cell is a phase, leap_cell clear, and (enemy piece on phaseAdj XOR enemy piece on phaseFar)\n}\n\nBoard.prototype.canJump = function (from, direction, bypass) {\n\t//if adj cell occupied, jumpCell in bounds, jumpCell clear, and jumpCell has enemy piece\n\tconst adj = from+direction;\n\tconst to = adj+direction;\n\tif (this.inBounds(to) && !this.getPlayer(to)) {\n\t\tif (bypass) return true;\n\t\telse this.addMove(from, to, adj);\n\t}\n}\n\nBoard.prototype.isPhaseMove = function (from, to, captured) {\n\tconst bothPhases = (this.board[from] & this.board[to]) & 1;\n\treturn !captured && bothPhases && this.getInverseIndex(from) === to;\n}\n\nBoard.prototype.canPhase = function (from, to, bypass) {\n\tconst isPhase = (this.board[from] & 1);\n\tconst isDestinationEmpty = !(this.board[to] & 4); //1 if player piece\n\tif (isPhase && isDestinationEmpty) {\n\t\tif (bypass) return true;\n\t\telse this.addMove(from, to);\n\t}\n}\n\n//reaching this function implies selected piece can be cloned, so piece is on a bounding row\nBoard.prototype.getSpawnCells = function (from, bypass) {\n\tconst spawnRow = ( from/BOARD_SIZE ^ (BOARD_SIZE-1) );\n\tfor (let col=1; col<BOARD_SIZE-1;col++) {\n\t\tlet to = spawnRow*BOARD_SIZE + col;\n\t\tlet spawnCellEmpty = !(this.board[to] & 4);\n\n\t\t//if spawnCell doesn't have a player on it\n\t\tif (spawnCellEmpty) {\n\t\t\tif (bypass) return true;\n\t\t\telse this.addMove(from, to);\n\t\t}\n\t}\n}\n\nBoard.prototype.getMovesInDirection = function (from, direction, bypass) {\n\t//check adjacent cells of piece p wrt the boundary\n\tconst adj = from+direction;\n\tconst isPhase = this.board[adj] & 1;\n\n\tif (isPhase && this.canLeap(from, adj, bypass)) return true;\n\n\tif ( (this.getPlayer(adj) ^ this.getPlayer(from)) === 8) {\n\t\tif (this.canJump(from, direction, bypass) ) return true;\n \t}\n\telse if (bypass) return true;\n\telse this.addMove(from, adj);\n}\n\n//bypass: if you want to see if this piece is able to move\nBoard.prototype.getMoves = function (from, bypass) {\n\tconst bCol = (from+1)%BOARD_SIZE < 2 ? (from+1)%BOARD_SIZE : undefined;\n\tfor (let r=-1; r<2; r++) {\n\t\tfor (let c=-1+(bCol === 1 ? 1 : 0); c<2-(bCol === 0 ? 1 : 0); c++) {\n\t\t\tlet direction = (r*BOARD_SIZE) + c;\n\t\t\tlet adj = from+direction;\n\t\t\t//enemy or empty cell\n\t\t\tlet validDirection = ( this.getPlayer(adj) ^ this.getPlayer(from) ) && this.inBounds(adj) && (direction);\n\t\t\tif ( validDirection && this.getMovesInDirection(from, direction, bypass) ) return true;\n\t\t}\n\t}\n\tconst inv = this.getInverseIndex(from);\n\t// phase condition\n\tif ( !this.isRedundantMove(from, inv) && this.canPhase(from, inv, bypass) ) return true;\n\t// clone condition\n\tif (!(this.board[from] & 16) && this.onCloningCell(from) && this.getSpawnCells(from, bypass)) return true;\n}\n\nBoard.protoype.getAllMoves = function (player) {\n\tconst c = (player === 12) ? BIT_MAX_PI : 0;\n\tfor (let key=c; key < 2*BOARD_SIZE + c; key++) {\n\t\tlet from = this.board[BOARD_AREA + key];\n\t\tif (!(from === undefined || from < 0)) this.getMoves(from);\n\t}\n}\n\n//Performs move. returns true if caught piece in process, else false\n//NOTE: it is impossible to capture a piece at board index 0\nBoard.prototype.doMove = function (from, to) {\n\tif (this.isCloneMove(from, to)) {\n\t\tthis.makeClone(from, to);\n\t\tthis.removeHighlight();\n\t\tthis.clearMoves();\n\t\treturn;\n\t}\n\tconst pi = this.board[from] >> 5;\n\tconst capturedPiece = this.getCapturedPiece(pi, to);\n\tthis.removeHighlight();\n\tthis.clearMoves();\n\n\tconst piece = (pi << 5) | (this.board[from] & 16) | this.getPlayer(from);\n\n\tif ( (this.board[to] & 12) === 8 ) {\n\t\t//SPECIAL PIECE *any player can move.... but how is TODO*\n\t\tthis.board[to] |= (pi << 5);\n\t} else {\n\t\t//We can assume this cell is empty\n\t\tthis.board[to] |= piece;\n\t}\n\n\tif (capturedPiece) {\n\t\tconst ci = this.board[capturedPiece] >> 5;\n\t\tthis.board[capturedPiece] &= 3;\n\t\tthis.board[BOARD_AREA + ci] = ~this.board[BOARD_AREA + ci]; //He DED\n\n\t\t//if Leap, then we get the direction by the difference between captured index and adjacent movement cell\n\t\tconst capturedAdjToDestination = (-9 <= (to-capturedPiece) && (to-capturedPiece) <= 9);\n\t\tconst capturedDirection = capturedAdjToDestination ? (to-capturedPiece) : (capturedPiece - from);\n\t\t//if can continue move in direction\n\t\tlet adj = to+capturedDirection;\n\t\tif ( this.board[adj] & 1 ) this.canLeap(to, adj);\n\t\tif ( this.getPlayer(adj) ^ this.getPlayer(to) === 2) this.canJump(to, capturedDirection);\n\t}\n\t//const isLeap = capturedPiece && alreadyPhased;\n\tconst canPhase = (this.board[to] & 1) && !this.isPhaseMove(from, to, capturedPiece);\n\tconst canClone = this.onCloningCell(to) && !this.onCloningCell(from);\n\t//If can clone or is on phase that piece hasn't just travelled through\n\tif ( canPhase ) this.canPhase(to, this.getInverseIndex(to));\n\tif ( canClone )\tthis.getSpawnCells(to);\n\n\tthis.board[from] &= 3; //keep only cell data\n\tthis.board[BOARD_AREA + pi] = to;\n\n\t//What if we return length of this.moves[pi] to determine if move can be continued? Then we don't need to call all these checkers\n\treturn this.moves[pi].length;\n}\n\n\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tREFERENCES\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\nBoard.prototype.getPlayer = function (index) {\n\tconst pid = (this.board[index] & 12);\n\tswitch (pid) {\n\t\tcase 12:\n\t\t\treturn this.p2;\n\t\tcase 4:\n\t\t\treturn this.p1;\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\nBoard.prototype.getCapturedPiece = function (pid, to) {\n\tconst nMoves = this.moves[pid].length;\n\tfor (let i=0; i< nMoves; i++) {\n\t\tlet move = this.moves[pid][i];\n\t\tlet capturedPiece = move >> (BIT_INDEX_SHIFT);\n\t\tif ( (move & (BIT_AREA - 1)) === to  && capturedPiece) return capturedPiece;\n\t}\n}\n\n//ONLY WORKS on NxN boards and phase group orders of 2\nBoard.prototype.getInverseIndex = function (index) {\n\treturn (BOARD_AREA - 1) - index;\n}\n\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tUTILITY\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\nBoard.prototype.isRedundantMove = function (from, to) {\n\tconst pi = (this.board[from] >> 5);\n\tconst n = this.moves[pi].length;\n\tfor (let i=0; i<n; i++) {\n\t\tif ( (this.moves[pi][i] & (BIT_AREA-1)) === to ) return true;\n\t}\n\treturn false;\n}\n\nBoard.prototype.inBounds = function (index) {\n\treturn 0 <= index && index < BOARD_AREA;\n}\n\nBoard.prototype.validMove = function (piece, index) {\n\tconst n = this.moves[piece].length;\n\tlet isAvailableMove = 0;\n\tfor (let i=0; i<n; i++) {\n\t\tif ( (this.moves[piece][i] & (BIT_AREA - 1)) === index ) isAvailableMove++;\n\t}\n\treturn !!(isAvailableMove);\n}\n\nBoard.prototype.copy = function (board) {\n\n}\n\nexport default Board;\n"]},"metadata":{},"sourceType":"module"}