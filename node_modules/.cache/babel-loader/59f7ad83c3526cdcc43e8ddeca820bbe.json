{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ChangeTree_1 = require(\"./ChangeTree\");\n\nvar Schema_1 = require(\"./Schema\");\n\nvar Context =\n/** @class */\nfunction () {\n  function Context() {\n    this.types = {};\n    this.schemas = new Map();\n  }\n\n  Context.prototype.has = function (schema) {\n    return this.schemas.has(schema);\n  };\n\n  Context.prototype.get = function (typeid) {\n    return this.types[typeid];\n  };\n\n  Context.prototype.add = function (schema) {\n    schema._typeid = this.schemas.size;\n    this.types[schema._typeid] = schema;\n    this.schemas.set(schema, schema._typeid);\n  };\n\n  return Context;\n}();\n\nexports.Context = Context;\nexports.globalContext = new Context();\n/**\n * `@type()` decorator for proxies\n */\n\nfunction type(type, context) {\n  if (context === void 0) {\n    context = exports.globalContext;\n  }\n\n  return function (target, field) {\n    var constructor = target.constructor;\n    constructor._context = context;\n    /*\n     * static schema\n     */\n\n    if (!context.has(constructor)) {\n      context.add(constructor); // support inheritance\n\n      constructor._schema = Object.assign({}, constructor._schema || {});\n      constructor._indexes = Object.assign({}, constructor._indexes || {});\n      constructor._fieldsByIndex = Object.assign({}, constructor._fieldsByIndex || {});\n      constructor._descriptors = Object.assign({}, constructor._descriptors || {});\n      constructor._deprecated = Object.assign({}, constructor._deprecated || {});\n    }\n\n    var index = Object.keys(constructor._schema).length;\n    constructor._fieldsByIndex[index] = field;\n    constructor._indexes[field] = index;\n    constructor._schema[field] = type;\n    /**\n     * skip if descriptor already exists for this field (`@deprecated()`)\n     */\n\n    if (constructor._descriptors[field]) {\n      return;\n    }\n    /**\n     * TODO: `isSchema` / `isArray` / `isMap` is repeated on many places!\n     * need to refactor all of them.\n     */\n\n\n    var isArray = Array.isArray(type);\n    var isMap = !isArray && type.map;\n    var isSchema = typeof constructor._schema[field] === \"function\";\n    var fieldCached = \"_\" + field;\n    constructor._descriptors[fieldCached] = {\n      enumerable: false,\n      configurable: false,\n      writable: true\n    };\n    constructor._descriptors[field] = {\n      get: function () {\n        return this[fieldCached];\n      },\n      set: function (value) {\n        /**\n         * Create Proxy for array or map items\n         */\n        if (isArray || isMap) {\n          value = new Proxy(value, {\n            get: function (obj, prop) {\n              return obj[prop];\n            },\n            set: function (obj, prop, setValue) {\n              if (prop !== \"length\" && prop.indexOf(\"$\") !== 0) {\n                // ensure new value has a parent\n                var key = isArray ? Number(prop) : String(prop);\n\n                if (!obj.$sorting) {\n                  // track index change\n                  var previousIndex = obj.$changes.getIndex(setValue);\n\n                  if (previousIndex !== undefined) {\n                    obj.$changes.mapIndexChange(setValue, previousIndex);\n                  }\n\n                  obj.$changes.mapIndex(setValue, key);\n                } // if (isMap) {\n                //     obj._indexes.delete(prop);\n                // }\n\n\n                if (setValue instanceof Schema_1.Schema) {\n                  // new items are flagged with all changes\n                  if (!setValue.$changes.parent) {\n                    setValue.$changes = new ChangeTree_1.ChangeTree(setValue._indexes, key, obj.$changes);\n                    setValue.$changes.changeAll(setValue);\n                  }\n                } else {\n                  obj[prop] = setValue;\n                } // apply change on ArraySchema / MapSchema\n\n\n                obj.$changes.change(key);\n              } else if (setValue !== obj[prop]) {// console.log(\"SET NEW LENGTH:\", setValue);\n                // console.log(\"PREVIOUS LENGTH: \", obj[prop]);\n              }\n\n              obj[prop] = setValue;\n              return true;\n            },\n            deleteProperty: function (obj, prop) {\n              var deletedValue = obj[prop];\n\n              if (isMap && deletedValue !== undefined) {\n                obj.$changes.deleteIndex(deletedValue);\n                obj.$changes.deleteIndexChange(deletedValue);\n\n                if (deletedValue.$changes) {\n                  // deletedValue may be a primitive value\n                  delete deletedValue.$changes.parent;\n                } // obj._indexes.delete(prop);\n\n              }\n\n              delete obj[prop];\n              var key = isArray ? Number(prop) : String(prop);\n              obj.$changes.change(key, true);\n              return true;\n            }\n          });\n        } // skip if value is the same as cached.\n\n\n        if (value === this[fieldCached]) {\n          return;\n        }\n\n        this[fieldCached] = value;\n\n        if (isArray) {\n          // directly assigning an array of items as value.\n          this.$changes.change(field);\n          value.$changes = new ChangeTree_1.ChangeTree({}, field, this.$changes);\n\n          for (var i = 0; i < value.length; i++) {\n            if (value[i] instanceof Schema_1.Schema) {\n              value[i].$changes = new ChangeTree_1.ChangeTree(value[i]._indexes, i, value.$changes);\n              value[i].$changes.changeAll(value[i]);\n            }\n\n            value.$changes.mapIndex(value[i], i);\n            value.$changes.change(i);\n          }\n        } else if (isMap) {\n          // directly assigning a map\n          value.$changes = new ChangeTree_1.ChangeTree({}, field, this.$changes);\n          this.$changes.change(field);\n\n          for (var key in value) {\n            if (value[key] instanceof Schema_1.Schema) {\n              value[key].$changes = new ChangeTree_1.ChangeTree(value[key]._indexes, key, value.$changes);\n              value[key].$changes.changeAll(value[key]);\n            }\n\n            value.$changes.mapIndex(value[key], key);\n            value.$changes.change(key);\n          }\n        } else if (isSchema) {\n          // directly assigning a `Schema` object\n          // value may be set to null\n          this.$changes.change(field);\n\n          if (value) {\n            value.$changes = new ChangeTree_1.ChangeTree(value._indexes, field, this.$changes);\n            value.$changes.changeAll(value);\n          }\n        } else {\n          // directly assigning a primitive type\n          this.$changes.change(field);\n        }\n      },\n      enumerable: true,\n      configurable: true\n    };\n  };\n}\n\nexports.type = type;\n/**\n * `@filter()` decorator for defining data filters per client\n */\n\nfunction filter(cb) {\n  return function (target, field) {\n    var constructor = target.constructor;\n    /*\n     * static filters\n     */\n\n    if (!constructor._filters) {\n      constructor._filters = {};\n    }\n\n    constructor._filters[field] = cb;\n  };\n}\n\nexports.filter = filter;\n/**\n * `@deprecated()` flag a field as deprecated.\n * The previous `@type()` annotation should remain along with this one.\n */\n\nfunction deprecated(throws, context) {\n  if (throws === void 0) {\n    throws = true;\n  }\n\n  if (context === void 0) {\n    context = exports.globalContext;\n  }\n\n  return function (target, field) {\n    var constructor = target.constructor;\n    constructor._deprecated[field] = true;\n\n    if (throws) {\n      constructor._descriptors[field] = {\n        get: function () {\n          throw new Error(field + \" is deprecated.\");\n        },\n        set: function (value) {},\n        enumerable: false,\n        configurable: true\n      };\n    }\n  };\n}\n\nexports.deprecated = deprecated;\n\nfunction defineTypes(target, fields, context) {\n  if (context === void 0) {\n    context = exports.globalContext;\n  }\n\n  for (var field in fields) {\n    type(fields[field], context)(target.prototype, field);\n  }\n\n  return target;\n}\n\nexports.defineTypes = defineTypes;","map":{"version":3,"sources":["../src/annotations.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ChangeTree_1 = require(\"./ChangeTree\");\nvar Schema_1 = require(\"./Schema\");\nvar Context = /** @class */ (function () {\n    function Context() {\n        this.types = {};\n        this.schemas = new Map();\n    }\n    Context.prototype.has = function (schema) {\n        return this.schemas.has(schema);\n    };\n    Context.prototype.get = function (typeid) {\n        return this.types[typeid];\n    };\n    Context.prototype.add = function (schema) {\n        schema._typeid = this.schemas.size;\n        this.types[schema._typeid] = schema;\n        this.schemas.set(schema, schema._typeid);\n    };\n    return Context;\n}());\nexports.Context = Context;\nexports.globalContext = new Context();\n/**\n * `@type()` decorator for proxies\n */\nfunction type(type, context) {\n    if (context === void 0) { context = exports.globalContext; }\n    return function (target, field) {\n        var constructor = target.constructor;\n        constructor._context = context;\n        /*\n         * static schema\n         */\n        if (!context.has(constructor)) {\n            context.add(constructor);\n            // support inheritance\n            constructor._schema = Object.assign({}, constructor._schema || {});\n            constructor._indexes = Object.assign({}, constructor._indexes || {});\n            constructor._fieldsByIndex = Object.assign({}, constructor._fieldsByIndex || {});\n            constructor._descriptors = Object.assign({}, constructor._descriptors || {});\n            constructor._deprecated = Object.assign({}, constructor._deprecated || {});\n        }\n        var index = Object.keys(constructor._schema).length;\n        constructor._fieldsByIndex[index] = field;\n        constructor._indexes[field] = index;\n        constructor._schema[field] = type;\n        /**\n         * skip if descriptor already exists for this field (`@deprecated()`)\n         */\n        if (constructor._descriptors[field]) {\n            return;\n        }\n        /**\n         * TODO: `isSchema` / `isArray` / `isMap` is repeated on many places!\n         * need to refactor all of them.\n         */\n        var isArray = Array.isArray(type);\n        var isMap = !isArray && type.map;\n        var isSchema = (typeof (constructor._schema[field]) === \"function\");\n        var fieldCached = \"_\" + field;\n        constructor._descriptors[fieldCached] = {\n            enumerable: false,\n            configurable: false,\n            writable: true,\n        };\n        constructor._descriptors[field] = {\n            get: function () {\n                return this[fieldCached];\n            },\n            set: function (value) {\n                /**\n                 * Create Proxy for array or map items\n                 */\n                if (isArray || isMap) {\n                    value = new Proxy(value, {\n                        get: function (obj, prop) { return obj[prop]; },\n                        set: function (obj, prop, setValue) {\n                            if (prop !== \"length\" && prop.indexOf(\"$\") !== 0) {\n                                // ensure new value has a parent\n                                var key = (isArray) ? Number(prop) : String(prop);\n                                if (!obj.$sorting) {\n                                    // track index change\n                                    var previousIndex = obj.$changes.getIndex(setValue);\n                                    if (previousIndex !== undefined) {\n                                        obj.$changes.mapIndexChange(setValue, previousIndex);\n                                    }\n                                    obj.$changes.mapIndex(setValue, key);\n                                }\n                                // if (isMap) {\n                                //     obj._indexes.delete(prop);\n                                // }\n                                if (setValue instanceof Schema_1.Schema) {\n                                    // new items are flagged with all changes\n                                    if (!setValue.$changes.parent) {\n                                        setValue.$changes = new ChangeTree_1.ChangeTree(setValue._indexes, key, obj.$changes);\n                                        setValue.$changes.changeAll(setValue);\n                                    }\n                                }\n                                else {\n                                    obj[prop] = setValue;\n                                }\n                                // apply change on ArraySchema / MapSchema\n                                obj.$changes.change(key);\n                            }\n                            else if (setValue !== obj[prop]) {\n                                // console.log(\"SET NEW LENGTH:\", setValue);\n                                // console.log(\"PREVIOUS LENGTH: \", obj[prop]);\n                            }\n                            obj[prop] = setValue;\n                            return true;\n                        },\n                        deleteProperty: function (obj, prop) {\n                            var deletedValue = obj[prop];\n                            if (isMap && deletedValue !== undefined) {\n                                obj.$changes.deleteIndex(deletedValue);\n                                obj.$changes.deleteIndexChange(deletedValue);\n                                if (deletedValue.$changes) { // deletedValue may be a primitive value\n                                    delete deletedValue.$changes.parent;\n                                }\n                                // obj._indexes.delete(prop);\n                            }\n                            delete obj[prop];\n                            var key = (isArray) ? Number(prop) : String(prop);\n                            obj.$changes.change(key, true);\n                            return true;\n                        },\n                    });\n                }\n                // skip if value is the same as cached.\n                if (value === this[fieldCached]) {\n                    return;\n                }\n                this[fieldCached] = value;\n                if (isArray) {\n                    // directly assigning an array of items as value.\n                    this.$changes.change(field);\n                    value.$changes = new ChangeTree_1.ChangeTree({}, field, this.$changes);\n                    for (var i = 0; i < value.length; i++) {\n                        if (value[i] instanceof Schema_1.Schema) {\n                            value[i].$changes = new ChangeTree_1.ChangeTree(value[i]._indexes, i, value.$changes);\n                            value[i].$changes.changeAll(value[i]);\n                        }\n                        value.$changes.mapIndex(value[i], i);\n                        value.$changes.change(i);\n                    }\n                }\n                else if (isMap) {\n                    // directly assigning a map\n                    value.$changes = new ChangeTree_1.ChangeTree({}, field, this.$changes);\n                    this.$changes.change(field);\n                    for (var key in value) {\n                        if (value[key] instanceof Schema_1.Schema) {\n                            value[key].$changes = new ChangeTree_1.ChangeTree(value[key]._indexes, key, value.$changes);\n                            value[key].$changes.changeAll(value[key]);\n                        }\n                        value.$changes.mapIndex(value[key], key);\n                        value.$changes.change(key);\n                    }\n                }\n                else if (isSchema) {\n                    // directly assigning a `Schema` object\n                    // value may be set to null\n                    this.$changes.change(field);\n                    if (value) {\n                        value.$changes = new ChangeTree_1.ChangeTree(value._indexes, field, this.$changes);\n                        value.$changes.changeAll(value);\n                    }\n                }\n                else {\n                    // directly assigning a primitive type\n                    this.$changes.change(field);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        };\n    };\n}\nexports.type = type;\n/**\n * `@filter()` decorator for defining data filters per client\n */\nfunction filter(cb) {\n    return function (target, field) {\n        var constructor = target.constructor;\n        /*\n         * static filters\n         */\n        if (!constructor._filters) {\n            constructor._filters = {};\n        }\n        constructor._filters[field] = cb;\n    };\n}\nexports.filter = filter;\n/**\n * `@deprecated()` flag a field as deprecated.\n * The previous `@type()` annotation should remain along with this one.\n */\nfunction deprecated(throws, context) {\n    if (throws === void 0) { throws = true; }\n    if (context === void 0) { context = exports.globalContext; }\n    return function (target, field) {\n        var constructor = target.constructor;\n        constructor._deprecated[field] = true;\n        if (throws) {\n            constructor._descriptors[field] = {\n                get: function () { throw new Error(field + \" is deprecated.\"); },\n                set: function (value) { },\n                enumerable: false,\n                configurable: true\n            };\n        }\n    };\n}\nexports.deprecated = deprecated;\nfunction defineTypes(target, fields, context) {\n    if (context === void 0) { context = exports.globalContext; }\n    for (var field in fields) {\n        type(fields[field], context)(target.prototype, field);\n    }\n    return target;\n}\nexports.defineTypes = defineTypes;\n//# sourceMappingURL=annotations.js.map"]},"metadata":{},"sourceType":"script"}