{"ast":null,"code":"import _objectSpread from \"/Users/bacchus/git/Leap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nvar _jsxFileName = \"/Users/bacchus/git/Leap/src/Leap.js\";\nimport React, { Component } from 'react';\nimport './css/ui.css';\nimport Countdown from 'react-countdown-now';\nimport { cellType } from './js/util.js';\n/*\nTODO:\nhighlight pieces\n\nGame description:\n\n\n\"How to Play\":\n-directions\n-tutorial?\n*/\n\nfunction getBitShift(b) {\n  return b >> 1 ? 1 + getBitShift(b >> 1) : 0;\n}\n\nexport const BOARD_SIZE = CONFIG.size;\nexport const BOARD_AREA = 2 ** BOARD_SIZE;\nexport const BIT_SHIFT = getBitShift(BOARD_SIZE);\nexport const BIT_LENGTH = 2 ** BIT_SHIFT;\nexport const BIT_AREA = 2 ** BIT_LENGTH; //const BOARD_AREA = BOARD_SIZE*BOARD_SIZE;\n\nconst playerOne = 4;\nconst playerTwo = 12;\nvar PLAYERS;\nconst CELL_COLORS = [\"gray1\", \"gray2\", \"pink\", \"red\", \"orange\", \"yellow\", \"green\", \"blue\"];\n\nclass Leap extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      /*...props.config,*/\n      board: new Board(BOARD_SIZE, 0),\n      // 0 is phaseLayout\n      turn: props.config.players[0].first ? playerOne : playerTwo,\n      continuedMove: false,\n      selectedPiece: null,\n      winner: null\n    };\n    /*\n    When we implement colyseus,\n      name: 'Player X' default, change in 'more' section or something\n      class: 'piece '+ chosen color\n      bot: true | false\n    */\n\n    PLAYERS = {\n      [playerOne]: _objectSpread({}, props.config.players[0], {\n        class: \"player-one\"\n      }),\n      [playerTwo]: _objectSpread({}, props.config.players[1], {\n        class: \"player-two\"\n      })\n    };\n  }\n\n  componentDidMount() {\n    //Check if first player is bot\n    if (PLAYERS[this.state.turn].bot) {\n      console.log('tete');\n    }\n  } //GOOD PLACE FOR NETWORK REQUEST\n\n  /*\n    componentDidUpdate(prevProps, prevState, snapshot) {\n  \n      //check if current player is bot\n      if(PLAYERS[this.state.turn].bot) {\n        console.log('BOT TIME: ');\n  \n      }\n    }\n    */\n  //React update method\n\n\n  componentDidUpdate(prevProps, prevState) {\n    //this.state.board.highlightPieceMoves();\n    if (prevState.turn !== this.state.turn) {\n      let board = this.state.board;\n\n      if (!board.movesLeft(this.state.turn)) {\n        console.log(\"${this.state.turn} has no more moves!\");\n        this.setState({\n          winner: this.nextPlayer()\n        });\n      }\n    } else if (this.state.selectedPiece) {//if is a move continuation and Counter hasn't started, start the timer\n      //if (this.state.contined_move) {}\n    }\n  }\n\n  selectCell(index) {\n    //If a move is not a continuation, default case,\n    if (!this.state.continuedMove) {\n      if (this.canSelectPiece(index)) this.setPiece(index);else if (this.state.selectedPiece) this.handleMove(index);\n    } else {\n      //if continuation\n      //check if move = true..\n      let board = this.state.board;\n      if (board.validMove(index)) this.handleMove(index);else {\n        //TODO: prompt \"end turn?\" option.\n        //right now, let's just end the turn otherwise\n        this.setState({\n          board: board,\n          turn: this.nextPlayer(this.state.turn),\n          continuedMove: false,\n          selectedPiece: null\n        });\n        board.highlightPieceMoves();\n      }\n    }\n  }\n\n  handleMove(index, row, col) {\n    //row, col of destination\n    let board = this.state.board;\n\n    if (!board.validMove(row, col)) {\n      console.log(\"Invalid move!\");\n      return;\n    }\n\n    console.log(\"handling move...\");\n    let sel = this.state.selectedPiece;\n    let pi = board.board[sel.row][sel.col].who;\n    let moveDirection; //Check if move is a clone move; If it is, we need not call doMove\n\n    if (board.isCloneSpawn(pi, row, col)) board.makeClone(pi, row, col);else moveDirection = board.doMove(pi, row, col); //all highlights gone\n    //If we can jump or leap, or phase (if move prior was not a phase)\n\n    if (board.canContinueMove(pi, moveDirection)) {\n      board.getMoves(pi, 3, moveDirection.rowIncr, moveDirection.colIncr); //highlight continuable moves\n\n      this.setState({\n        board: board,\n        turn: this.state.turn,\n        continuedMove: moveDirection,\n        selectedPiece: board[index] >> 5\n      });\n    } else this.setState({\n      board: board,\n      turn: this.nextPlayer(this.state.turn),\n      continuedMove: false,\n      selectedPiece: null\n    });\n  } //bot need not use this; they get the move from ai.js, pass it on directly to doMove\n\n\n  canSelectPiece(index) {\n    //let p = this.state.board.board[index];\n    //bit 2 indicates a player piece\n    return index & 4 && (index >> 2 & 3) === this.state.turn >> 2 && !PLAYERS[this.state.turn].bot;\n  }\n\n  setPiece(index) {\n    let board = this.state.board,\n        pi = board[index] >> 5;\n    board.getMoves(index);\n    board.highlightMoves(pi);\n    this.setState({\n      selectedPiece: pi\n    }); //console.log(\"selected piece: \" + this.state.board.board[row][col].who);\n  }\n\n  nextPlayer() {\n    return this.state.turn ^ 2;\n  }\n\n  restart() {\n    this.setState({\n      board: new Board(BOARD_SIZE, playerOne, playerTwo),\n      continuedMove: false,\n      turn: playerOne,\n      //TODO\n      selectedPiece: null,\n      winner: null\n    });\n  }\n\n  render() {\n    return React.createElement(\"div\", {\n      className: \"Leap\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 181\n      },\n      __self: this\n    }, this.state.winner && React.createElement(Winner, {\n      player: this.state.winner,\n      restart: this.restart.bind(this),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 182\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 183\n      },\n      __self: this\n    }, \"Current turn: \", PLAYERS[this.state.turn].name, React.createElement(\"span\", {\n      className: PLAYERS[this.state.turn].class + \"-token\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 185\n      },\n      __self: this\n    })), React.createElement(\"div\", {\n      className: \"game-container\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 187\n      },\n      __self: this\n    }, React.createElement(\"div\", {\n      className: \"game-options\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 188\n      },\n      __self: this\n    }), React.createElement(GameBoard, {\n      board: this.state.board,\n      selectedPiece: this.state.selectedPiece,\n      selectCell: this.selectCell.bind(this),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 189\n      },\n      __self: this\n    }), React.createElement(\"div\", {\n      className: \"game-menu\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 192\n      },\n      __self: this\n    })));\n  }\n\n}\n/*\n<Countdown date={Date.now() + 10000}\n           intervalDelay={0}\n           precision={3}\n           autoStart={this.state.continuedMove}\n           renderer={d => <div>\n              <span className=\"countdown-s\">{d.seconds}</span>\n              <span className=\"countdown-ms\">:{d.milliseconds}</span>\n           </div>}/>\n*/\n\n\nfunction Winner(props) {\n  let player = PLAYERS[props.player].name;\n  return React.createElement(\"div\", {\n    id: \"winner\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 213\n    },\n    __self: this\n  }, React.createElement(\"div\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 214\n    },\n    __self: this\n  }, React.createElement(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 215\n    },\n    __self: this\n  }, player, \" has won the game!\"), React.createElement(\"button\", {\n    onClick: props.restart,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 216\n    },\n    __self: this\n  }, \"Play again?\")));\n}\n\nfunction GameBoard(props) {\n  //let selectedRow = props.selectedPiece ? props.selectedPiece.row : null;\n  let rows = [];\n\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    rows.push(React.createElement(Row, {\n      key: r,\n      row: r,\n      board: props.board,\n      selectedPiece: props.selectedPiece,\n      selectCell: props.selectCell,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 228\n      },\n      __self: this\n    }));\n  }\n\n  return React.createElement(\"div\", {\n    className: \"board\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 235\n    },\n    __self: this\n  }, \" \", rows, \" \");\n}\n\nfunction Row(props) {\n  let cells = [],\n      index,\n      cell;\n\n  for (let c = 0; c < BOARD_SIZE; c++) {\n    index = props.row * BOARD_SIZE + c;\n    cell = props.board.board[index];\n    cells.push(React.createElement(Cell, {\n      key: index //board index\n      ,\n      index: index,\n      val: cell //cell info\n      ,\n      row: props.row,\n      col: c,\n      highlight: props.board[index] & 2,\n      selected: cell >> 5 === props.selectedPiece,\n      selectCell: props.selectCell,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 243\n      },\n      __self: this\n    }));\n  }\n\n  return React.createElement(\"span\", {\n    className: \"row\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 253\n    },\n    __self: this\n  }, \" \", cells, \" \");\n}\n\nfunction Cell(props) {\n  let color = CELL_COLORS[cellType(props.row, props.col)];\n  let highlight = props.highlight ? \" highlight\" : \"\";\n  let classes = \"cell \" + color + highlight;\n  return React.createElement(\"div\", {\n    className: classes,\n    onClick: () => props.selectCell(props.val),\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 261\n    },\n    __self: this\n  }, (props.val & 12) > 0 && React.createElement(Piece, {\n    key: props.val >> 5,\n    player: props.val & 12,\n    cloned: props.val >> 4 & 16,\n    selected: props.selected,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 262\n    },\n    __self: this\n  }));\n}\n\nfunction Piece(p) {\n  let classes = \"\";\n  classes += PLAYERS[p.player].class;\n  if (p.cloned) classes += \" cloned\";\n\n  if (p.selected) {\n    classes += \" selected\";\n  }\n\n  return React.createElement(\"div\", {\n    className: classes,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 278\n    },\n    __self: this\n  });\n}\n/*\nTODO:\n- Make continue button (?)\n\n- AI player\n\n- Allow multiplayer\n    Random match making\n    invites (link or username (if integrated with Google Play))\n\n- Pieces are draggable and snap to grid\n    (if center of dragging piece is strictly within calc(cell-margin + cell-height/2) on drop, then select cell where piece dropped)\n    disable animations for all but phase and clone moves.\n\n- Make animations\n    If clone, we animate the original piece and newly created piece with cloning animation\n    If phase, piece fades in/out from center to edges on adj phase  and on far phase\n    if piece has caught:\n      If jump,\n        piece does a small hop to the destinationCell\n        captured bursts into little circles and fades away\n      If leap,\n        piece gets sucked into portal, (SVG points all transform to center of adj phase, timing ease-in-out), and pushed out (reverse animation)\n        if captured on adj phase:\n          captured shakes and does first part of phase animation while piece being sucked in, but then comes out as little circles on other side\n        else:\n          captured bursts into little circles and fades away\n    else:\n      piece does small hop to destination cell\n\nHow can we handle animations?\n> Translate moving piece p, where p is a child of the destination cell component,\n> from ( startingCell.center.x , startingCell.center.y ) to ( destinationCell.x, destinationCell.y)\n\n\nANIMATION PIPELINE:\n  In function Board.doMove:\n  - get move details\n      moving piece: p,\n      startingCell = {who: board[p.row][p.col].who, move_type: ye, row: p.row, col: p.col}, -- defined first in do move\n      moveDirection,\n      captured piece (if applicable)\n\n  Upon doMove or makeClone:\n  - Find Cell components of startingCell and, if applicable, captured piece\n      (starting cell) get Cell component c such that: c.row === startingCell.row && c.col === startingCell.col\n      (captured piece) get\n\n  -\n\n\n*/\n\n\nexport default Leap;","map":{"version":3,"sources":["/Users/bacchus/git/Leap/src/Leap.js"],"names":["React","Component","Countdown","cellType","getBitShift","b","BOARD_SIZE","CONFIG","size","BOARD_AREA","BIT_SHIFT","BIT_LENGTH","BIT_AREA","playerOne","playerTwo","PLAYERS","CELL_COLORS","Leap","constructor","props","state","board","Board","turn","config","players","first","continuedMove","selectedPiece","winner","class","componentDidMount","bot","console","log","componentDidUpdate","prevProps","prevState","movesLeft","setState","nextPlayer","selectCell","index","canSelectPiece","setPiece","handleMove","validMove","highlightPieceMoves","row","col","sel","pi","who","moveDirection","isCloneSpawn","makeClone","doMove","canContinueMove","getMoves","rowIncr","colIncr","highlightMoves","restart","render","bind","name","Winner","player","GameBoard","rows","r","push","Row","cells","cell","c","Cell","color","highlight","classes","val","selected","Piece","p","cloned"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport './css/ui.css';\nimport Countdown from 'react-countdown-now';\nimport {cellType} from './js/util.js';\n\n/*\nTODO:\nhighlight pieces\n\nGame description:\n\n\n\"How to Play\":\n-directions\n-tutorial?\n*/\nfunction getBitShift(b) {\n  return (b >> 1) ? (1 + getBitShift(b >> 1)) : 0;\n}\n\nexport const BOARD_SIZE = CONFIG.size;\nexport const BOARD_AREA = 2**BOARD_SIZE;\nexport const BIT_SHIFT = getBitShift(BOARD_SIZE);\nexport const BIT_LENGTH = 2**BIT_SHIFT;\nexport const BIT_AREA = 2**BIT_LENGTH;\n//const BOARD_AREA = BOARD_SIZE*BOARD_SIZE;\nconst playerOne = 4;\nconst playerTwo = 12;\nvar PLAYERS;\n\nconst CELL_COLORS = [ \"gray1\", \"gray2\", \"pink\", \"red\", \"orange\", \"yellow\", \"green\", \"blue\"];\n\nclass Leap extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      /*...props.config,*/\n      board: new Board(BOARD_SIZE, 0), // 0 is phaseLayout\n      turn: props.config.players[0].first ? playerOne : playerTwo,\n      continuedMove: false,\n      selectedPiece: null,\n      winner: null\n    };\n\n    /*\n    When we implement colyseus,\n      name: 'Player X' default, change in 'more' section or something\n      class: 'piece '+ chosen color\n      bot: true | false\n    */\n    PLAYERS = {\n      [playerOne]: {\n        ...props.config.players[0],\n        class: \"player-one\"\n      },\n      [playerTwo]: {\n        ...props.config.players[1],\n        class: \"player-two\"\n      }\n    }\n  }\n\n  componentDidMount() {\n    //Check if first player is bot\n    if(PLAYERS[this.state.turn].bot) {\n      console.log('tete');\n    }\n  }\n\n//GOOD PLACE FOR NETWORK REQUEST\n/*\n  componentDidUpdate(prevProps, prevState, snapshot) {\n\n    //check if current player is bot\n    if(PLAYERS[this.state.turn].bot) {\n      console.log('BOT TIME: ');\n\n    }\n  }\n  */\n\n  //React update method\n  componentDidUpdate(prevProps, prevState) {\n    //this.state.board.highlightPieceMoves();\n    if (prevState.turn !== this.state.turn) {\n      let board = this.state.board;\n      if (!board.movesLeft(this.state.turn)) {\n        console.log(\"${this.state.turn} has no more moves!\");\n        this.setState({winner: this.nextPlayer()});\n      }\n    } else if (this.state.selectedPiece){\n      //if is a move continuation and Counter hasn't started, start the timer\n      //if (this.state.contined_move) {}\n    }\n  }\n\n  selectCell(index) {\n    //If a move is not a continuation, default case,\n    if (!this.state.continuedMove) {\n      if (this.canSelectPiece(index)) this.setPiece(index);\n      else if (this.state.selectedPiece)  this.handleMove(index);\n    } else { //if continuation\n      //check if move = true..\n      let board = this.state.board;\n      if (board.validMove(index)) this.handleMove(index)\n      else {\n        //TODO: prompt \"end turn?\" option.\n        //right now, let's just end the turn otherwise\n        this.setState({\n          board: board,\n          turn: this.nextPlayer(this.state.turn),\n          continuedMove: false,\n          selectedPiece: null\n        });\n        board.highlightPieceMoves(/*KEYKEYLMAO*/);\n      }\n    }\n  }\n\n  handleMove(index, row, col) { //row, col of destination\n    let board = this.state.board;\n    if (!board.validMove(row, col)) {\n      console.log(\"Invalid move!\");\n      return;\n    }\n    console.log(\"handling move...\");\n    let sel = this.state.selectedPiece;\n    let pi = board.board[sel.row][sel.col].who;\n\n    let moveDirection;\n    //Check if move is a clone move; If it is, we need not call doMove\n    if(board.isCloneSpawn(pi,row, col)) board.makeClone(pi, row, col);\n    else moveDirection = board.doMove(pi, row, col);\n    //all highlights gone\n\n    //If we can jump or leap, or phase (if move prior was not a phase)\n    if (board.canContinueMove(pi, moveDirection)) {\n      board.getMoves(pi, 3, moveDirection.rowIncr, moveDirection.colIncr); //highlight continuable moves\n      this.setState({\n        board: board,\n        turn: this.state.turn,\n        continuedMove: moveDirection,\n        selectedPiece: (board[index] >> 5)\n      });\n    } else this.setState({\n        board: board,\n        turn: this.nextPlayer(this.state.turn),\n        continuedMove: false,\n        selectedPiece: null\n      });\n  }\n\n  //bot need not use this; they get the move from ai.js, pass it on directly to doMove\n  canSelectPiece(index) {\n    //let p = this.state.board.board[index];\n    //bit 2 indicates a player piece\n    return (index & 4) && ( ((index >> 2) & 3) === (this.state.turn >> 2) ) && !PLAYERS[this.state.turn].bot;\n  }\n\n  setPiece(index) {\n    let board = this.state.board, pi = (board[index] >> 5);\n    board.getMoves(index);\n    board.highlightMoves(pi);\n    this.setState({selectedPiece: pi});\n      //console.log(\"selected piece: \" + this.state.board.board[row][col].who);\n  }\n\n  nextPlayer() {\n    return this.state.turn ^ 2;\n  }\n\n  restart() {\n    this.setState({ board: new Board(BOARD_SIZE, playerOne, playerTwo),\n                    continuedMove: false, turn: playerOne, //TODO\n                    selectedPiece: null, winner: null });\n  }\n\n  render() {\n    return (\n      <div className=\"Leap\">\n        { this.state.winner && <Winner player={this.state.winner} restart={this.restart.bind(this)} /> }\n        <h3>\n          Current turn: {PLAYERS[this.state.turn].name}\n          <span className={PLAYERS[this.state.turn].class+\"-token\"}></span>\n        </h3>\n        <div className=\"game-container\">\n          <div className=\"game-options\"></div>\n          <GameBoard board={this.state.board}\n                     selectedPiece={this.state.selectedPiece}\n                     selectCell={this.selectCell.bind(this)} />\n          <div className=\"game-menu\"></div>\n        </div>\n      </div>\n    );\n  }\n}\n\n/*\n<Countdown date={Date.now() + 10000}\n           intervalDelay={0}\n           precision={3}\n           autoStart={this.state.continuedMove}\n           renderer={d => <div>\n              <span className=\"countdown-s\">{d.seconds}</span>\n              <span className=\"countdown-ms\">:{d.milliseconds}</span>\n           </div>}/>\n*/\n\nfunction Winner(props) {\n  let player = PLAYERS[props.player].name;\n  return (\n    <div id=\"winner\">\n      <div>\n        <p>{player} has won the game!</p>\n        <button onClick={props.restart}>Play again?</button>\n      </div>\n    </div>\n  );\n}\n\n\nfunction GameBoard(props) {\n  //let selectedRow = props.selectedPiece ? props.selectedPiece.row : null;\n\n  let rows = [];\n  for(let r=0; r<BOARD_SIZE; r++) {\n    rows.push(<Row\n      key={r}\n      row={r}\n      board={props.board}\n      selectedPiece={props.selectedPiece}\n      selectCell={props.selectCell} />);\n  }\n  return (<div className=\"board\"> {rows} </div>);\n}\n\nfunction Row(props) {\n  let cells = [], index, cell;\n  for(let c=0; c< BOARD_SIZE; c++) {\n    index = props.row*BOARD_SIZE + c;\n    cell = props.board.board[index];\n    cells.push(<Cell\n      key={index} //board index\n      index={index}\n      val={cell} //cell info\n      row={props.row}\n      col={c}\n      highlight={props.board[index] & 2}\n      selected={(cell >> 5) === props.selectedPiece}\n      selectCell={props.selectCell} />);\n  }\n  return (<span className=\"row\"> {cells} </span>);\n}\n\nfunction Cell(props) {\n  let color = CELL_COLORS[cellType(props.row, props.col)];\n  let highlight = props.highlight ? \" highlight\" : \"\";\n  let classes = \"cell \" + color + highlight;\n  return (\n    <div className={classes} onClick={ () => props.selectCell(props.val) }>\n      { ((props.val & 12) > 0) && <Piece\n        key={props.val >> 5}\n        player={props.val & 12}\n        cloned={(props.val >> 4) & 16}\n        selected={props.selected} />}\n    </div>\n  );\n}\n\nfunction Piece(p) {\n  let classes = \"\";\n  classes += PLAYERS[p.player].class;\n  if (p.cloned) classes += \" cloned\";\n  if (p.selected) {\n    classes += \" selected\";\n  }\n  return (<div className={classes}></div>)\n}\n\n\n\n/*\nTODO:\n- Make continue button (?)\n\n- AI player\n\n- Allow multiplayer\n    Random match making\n    invites (link or username (if integrated with Google Play))\n\n- Pieces are draggable and snap to grid\n    (if center of dragging piece is strictly within calc(cell-margin + cell-height/2) on drop, then select cell where piece dropped)\n    disable animations for all but phase and clone moves.\n\n- Make animations\n    If clone, we animate the original piece and newly created piece with cloning animation\n    If phase, piece fades in/out from center to edges on adj phase  and on far phase\n    if piece has caught:\n      If jump,\n        piece does a small hop to the destinationCell\n        captured bursts into little circles and fades away\n      If leap,\n        piece gets sucked into portal, (SVG points all transform to center of adj phase, timing ease-in-out), and pushed out (reverse animation)\n        if captured on adj phase:\n          captured shakes and does first part of phase animation while piece being sucked in, but then comes out as little circles on other side\n        else:\n          captured bursts into little circles and fades away\n    else:\n      piece does small hop to destination cell\n\nHow can we handle animations?\n> Translate moving piece p, where p is a child of the destination cell component,\n> from ( startingCell.center.x , startingCell.center.y ) to ( destinationCell.x, destinationCell.y)\n\n\nANIMATION PIPELINE:\n  In function Board.doMove:\n  - get move details\n      moving piece: p,\n      startingCell = {who: board[p.row][p.col].who, move_type: ye, row: p.row, col: p.col}, -- defined first in do move\n      moveDirection,\n      captured piece (if applicable)\n\n  Upon doMove or makeClone:\n  - Find Cell components of startingCell and, if applicable, captured piece\n      (starting cell) get Cell component c such that: c.row === startingCell.row && c.col === startingCell.col\n      (captured piece) get\n\n  -\n\n\n*/\n\nexport default Leap;\n"]},"metadata":{},"sourceType":"module"}