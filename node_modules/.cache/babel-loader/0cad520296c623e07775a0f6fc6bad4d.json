{"ast":null,"code":"var util = require('./util.js'); //single, phase, jump, super-jump\n\n/*\nadj: adjacent\nphase: change portal side\nleap: capture piece while jumping through a portal\njitch: jump, then phase\nswump: switch, then jump\n}\n*/\n\n/*\nLEGEND\npi = piece index in Board.pieces\np = piece Board.pieces[pi]\n*/\n\n/*\nPreviously, I assumed that if a uncloned piece reaches the end of the other player's side,\nthen that piece must duplicate before continuing the game. However, my assumption fails\nif the player's spawn row is full and hence I will give the player the option to choose.\n\nThis realization got me thinking about adding different game modes that\nmodify things like the board size, and side-wrapping.\n\nboard size: If board were 9x9, we can put a clone phaser in the center\nthat duplicates any non-clone pieces at most once.\n\nside wrapping: columns are cyclic: make board[row] = cyclic linked List?\n\n\n\nSpeaking of linked lists... Why am I not using them now?\nMaybe this is what I needed to store highlight;\n represent each of this.state.selectedPiece's moves as a boolean for 'highlight' in\n this.board[row][col] = {who: p.player | null, highlight: true | false :: added in Board.getMoves(pi)}\n for some row,col,  and p = this.piece[pi]\n to Leap.setPiece(), add this.state.board.updateBoard()\n\n*/\n\n\nfunction Board(size, p1, p2) {\n  this.p1 = p1;\n  this.p2 = p2;\n  this.board = this.initBoard(size);\n  this.piecesSeparator = 8;\n  this.pieces = this.initPieces(size, p1, p2);\n  this.updateBoard(); //add pieces to board\n} //TODO:\n//this.board[row][col] = {who: p.player | null, highlight: {row: some_row, col: some_col} | null:: added in Board.getMoves(pi)}\n//update occurs when (1) piece is cloned (pieces index may change)\n// and when (2) setPiece is called\n//To make highlight function properly, I'll have to call this.getMoves() from here.\n//It follows that I will have to remove other calls to this.getMoves()\n\n\nBoard.prototype.updateBoard = function (newPiece) {\n  if (newPiece) {\n    this.board = this.board.map(row => row.map((cell, j) => {\n      if (cell.who != null) {\n        //increment all pi in board after piecesSeparator by one\n        if (cell.who >= this.piecesSeparator) cell.who++; //if piece alive, keep on board\n\n        return this.pieces[cell.who].alive ? {\n          who: cell.who,\n          move: false\n        } : {\n          who: null,\n          move: false\n        };\n      } else return {\n        who: null,\n        move: false\n      };\n    }));\n  } else {\n    this.board = this.board.map(row => row.map((cell, j) => cell.who != null ? this.pieces[cell.who].alive ? {\n      who: cell.who,\n      move: false\n    } : {\n      who: null,\n      move: false\n    } : {\n      who: null,\n      move: false\n    }));\n  }\n};\n\nBoard.prototype.initBoard = function (size) {\n  let board = [],\n      playerTwo = [],\n      playerOne = []; //TODO: fill as {who: pi (this.pieces index), highlight: null}\n\n  for (let i = 0; i < size; i++) {\n    playerTwo.push({\n      who: i,\n      move: false\n    });\n    playerOne.push({\n      who: i + 8,\n      move: false\n    });\n  }\n\n  board.push(playerTwo);\n\n  for (let i = 1; i < size - 1; i++) board.push(Array(size).fill({\n    who: null,\n    move: false\n  }));\n\n  board.push(playerOne);\n  return board;\n};\n\nBoard.prototype.initPieces = function (size) {\n  let whitePieces = [];\n  let blackPieces = [];\n\n  for (let c = 0; c < size; c++) {\n    whitePieces.push({\n      player: this.p1,\n      cloned: false,\n      row: 7,\n      col: c,\n      alive: true\n    });\n    blackPieces.push({\n      player: this.p2,\n      cloned: false,\n      row: 0,\n      col: c,\n      alive: true\n    });\n  }\n\n  return blackPieces.concat(whitePieces);\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n//Calls every time a clone is made\n\n\nBoard.prototype.insertAtSeparationIndex = function () {\n  for (let pi = this.piecesSeparator; pi < this.pieces.length; pi++) {\n    //Finds index that separates p1 and p2 pieces\n    if (this.pieces[pi].player !== this.p2) {\n      this.piecesSeparator = pi; //update\n\n      return pi;\n    }\n  }\n};\n\nBoard.prototype.makeClone = function (pi, row, col) {\n  let p = this.pieces[pi];\n  p.cloned = true;\n  let clone = {\n    player: p.player,\n    cloned: true,\n    row: row,\n    col: col,\n    alive: true\n  };\n  this.pieces.splice(this.insertAtSeparationIndex(), 0, clone); //add clone to pieces Array\n\n  this.updateBoard(true);\n  this.board[row][col].who = this.piecesSeparator;\n  return true;\n};\n\nBoard.prototype.canClone = function (pi) {\n  let p = this.pieces[pi];\n  return !p.cloned && p.col < 7 && p.col > 0 && (p.player === this.p1 && !p.row || p.player === this.p2 && p.row === 7);\n};\n\nBoard.prototype.isCloneSpawn = function (pi, row, col) {\n  return this.canClone(pi) && this.board[row][col].who === null;\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n\nBoard.prototype.getPlayer = function (pi) {\n  return this.pieces[pi].player;\n};\n\nBoard.prototype.isLeap = function (p, rowIncr, colIncr, isPhase, cellAdj, bypassCondition) {\n  //if neighbor cell is a phase, leap_cell clear, and (enemy piece on phaseAdj XOR enemy piece on phaseFar)\n  let destinationCell = this.board[7 - p.row][7 - p.col];\n\n  if (isPhase && !destinationCell.who) {\n    let phaseAdj = cellAdj.who;\n    let phaseFar = this.board[7 - (p.row + rowIncr)][7 - (p.col + colIncr)].who;\n\n    if ((phaseAdj || phaseFar) && !(phaseAdj && phaseFar)) {\n      //xor filter. Only one may be true\n      let capt = phaseAdj ? phaseAdj : phaseFar; //if 0, add to destinationCell.move, if 1,\n\n      if (bypassCondition) return true;else destinationCell.move = capt;\n    }\n  }\n};\n\nBoard.prototype.isJump = function (p, rowIncr, colIncr, cellAdj, bypassCondition) {\n  //if adj cell occupied, jumpCell in bounds, jumpCell clear, and jumpCell has enemy piece\n  if (util.inBounds(p.row + rowIncr * 2, p.col + colIncr * 2)) {\n    let destinationCell = this.board[p.row + rowIncr * 2][p.col + colIncr * 2];\n\n    if (this.getPlayer(cellAdj.who) !== p.player && destinationCell.who === null) {\n      if (bypassCondition % 3) return true;else destinationCell.move = cellAdj.who;\n    }\n  }\n};\n\nBoard.prototype.isPhase = function (p, bypassCondition) {\n  let isPhase = util.cellType(p.row, p.col) > 1;\n  let destinationCell = this.board[7 - p.row][7 - p.col];\n\n  if (isPhase && destinationCell.who === null) {\n    if (bypassCondition % 3) return true;else destinationCell.move = true;\n  }\n};\n\nBoard.prototype.getCloneSpawns = function (p, bypassCondition) {\n  let row = p.player === this.p1 ? 7 : 0;\n\n  for (let col = 1; col < 7; col++) {\n    let destinationCell = this.board[row][col];\n\n    if (destinationCell.who === null) {\n      if (bypassCondition % 3) return true;else destinationCell.move = true;\n    }\n  }\n};\n\nBoard.prototype.getMovesInDirection = function (p, bypassCondition, r, c) {\n  //check adjacent cells of piece p wrt the boundary\n  if (util.inBounds(p.row + r, p.col + c) && (r || c)) {\n    let cellAdj = this.board[p.row + r][p.col + c];\n    let isPhase = util.cellType(p.row + r, p.col + c) > 1;\n    if (this.isLeap(p, r, c, isPhase, cellAdj, bypassCondition)) return true;\n\n    if (cellAdj.who !== null) {\n      if (this.isJump(p, r, c, cellAdj, bypassCondition)) return true;\n    } else if (bypassCondition % 3 % 2) return true; //adjacent moves\n    else if (!bypassCondition) cellAdj.move = true;\n  }\n\n  return false;\n}; //bypassCondition (HIGHLIGHT BYPASS CONDITION): undefined - default (Store all), 1 - bypass all, 2 - bypass continuable moves, 3 - store continuable moves\n\n\nBoard.prototype.getMoves = function (pi, bypassCondition, r, c) {\n  let p = this.pieces[pi]; //TODO: ref this.board[p.row + r][p.col + r].who, and set highlight = true for every destination\n\n  if (this.isPhase(p, bypassCondition)) return true;\n  if (this.canClone(pi) && this.getCloneSpawns(p, bypassCondition)) return true;\n\n  if (r != null && c != null) {\n    if (this.getMovesInDirection(p, bypassCondition, r, c)) return true;\n  } else {\n    for (r = -1; r < 2; r++) for (c = -1; c < 2; c++) {\n      if (this.getMovesInDirection(p, bypassCondition, r, c)) return true;\n    }\n  }\n\n  return false;\n}; //Performs move. returns true if caught piece in process, else false\n\n\nBoard.prototype.doMove = function (pi, row, col) {\n  let p = this.pieces[pi]; //begin move\n\n  this.board[p.row][p.col].who = null;\n  let destinationCell = this.board[row][col];\n  let caught = typeof destinationCell.move === \"number\" ? destinationCell.move : false; //caught piece index\n  // moveDirection is defined if and only if any of the following is true (for moving piece p):\n\n  let moveDirection; // (1) p caught a piece\n\n  if (caught) {\n    let c = this.pieces[caught];\n    c.alive = false;\n    this.board[c.row][c.col].who = null; //return direction of move\n    //If leap, then c adjacent at start XOR c adjacent at end\n    //Check adjacency of moving piece to captured piece on starting position and ending position\n\n    let cellAdjStartPos = Math.abs(c.row - p.row) < 2 && Math.abs(c.col - p.col) < 2;\n    let cellAdjEndPos = Math.abs(row - c.row) < 2 && Math.abs(col - c.col) < 2;\n    moveDirection = cellAdjStartPos && cellAdjEndPos ? {\n      rowIncr: Math.sign(row - c.row),\n      colIncr: Math.sign(col - c.col) //jump\n\n    } : cellAdjStartPos ? {\n      rowIncr: Math.sign(c.row - p.row),\n      colIncr: Math.sign(c.col - p.row) //leap-> piece adj to capture on start\n\n    } : {\n      rowIncr: Math.sign(row - c.row),\n      colIncr: Math.sign(col - c.col)\n    };\n  } // (2) p LANDS on a phase cell. That is, this move is not a phase.\n  else if (!this.samePhase(p, {\n      row: row,\n      col: col\n    })) moveDirection = {\n      rowIncr: 0,\n      colIncr: 0\n    }; //end move\n\n\n  this.board[row][col].who = pi;\n  p.row = row;\n  p.col = col; // (3) p is able to be cloned\n\n  if (this.canClone(pi)) moveDirection = {\n    rowIncr: 0,\n    colIncr: 0\n  };\n  this.updateBoard();\n  return moveDirection;\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tINTEGRITY\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n\nBoard.prototype.samePhase = function (from, to) {\n  let isDestinationPhase = util.cellType(to.row, to.col);\n  return isDestinationPhase > 1 && isDestinationPhase === util.cellType(from.row, from.col);\n};\n\nBoard.prototype.canContinueMove = function (pi, dir) {\n  return dir ? this.getMoves(pi, 2, dir.rowIncr, dir.colIncr) : false;\n};\n\nBoard.prototype.hasMoves = function (pi) {\n  return this.getMoves(pi, 1);\n}; //Player has no more moves when (1): all player's pieces are dead (2): every piece has no moves\n\n\nBoard.prototype.movesLeft = function (player) {\n  for (let pi = 0; pi < this.pieces.length; pi++) {\n    let p = this.pieces[pi];\n\n    if (p.alive && p.player === player) {\n      if (this.hasMoves(pi)) return true;\n    }\n  }\n\n  return false;\n};\n\nBoard.prototype.validMove = function (row, col) {\n  return this.board[row][col].move;\n};\n\nmodule.exports = Board;","map":{"version":3,"sources":["/Users/bacchus/git/Leap/src/js/board.js"],"names":["util","require","Board","size","p1","p2","board","initBoard","piecesSeparator","pieces","initPieces","updateBoard","prototype","newPiece","map","row","cell","j","who","alive","move","playerTwo","playerOne","i","push","Array","fill","whitePieces","blackPieces","c","player","cloned","col","concat","insertAtSeparationIndex","pi","length","makeClone","p","clone","splice","canClone","isCloneSpawn","getPlayer","isLeap","rowIncr","colIncr","isPhase","cellAdj","bypassCondition","destinationCell","phaseAdj","phaseFar","capt","isJump","inBounds","cellType","getCloneSpawns","getMovesInDirection","r","getMoves","doMove","caught","moveDirection","cellAdjStartPos","Math","abs","cellAdjEndPos","sign","samePhase","from","to","isDestinationPhase","canContinueMove","dir","hasMoves","movesLeft","validMove","module","exports"],"mappings":"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","sourcesContent":["var util = require('./util.js');\n//single, phase, jump, super-jump\n/*\nadj: adjacent\nphase: change portal side\nleap: capture piece while jumping through a portal\njitch: jump, then phase\nswump: switch, then jump\n}\n*/\n/*\nLEGEND\npi = piece index in Board.pieces\np = piece Board.pieces[pi]\n*/\n\n/*\nPreviously, I assumed that if a uncloned piece reaches the end of the other player's side,\nthen that piece must duplicate before continuing the game. However, my assumption fails\nif the player's spawn row is full and hence I will give the player the option to choose.\n\nThis realization got me thinking about adding different game modes that\nmodify things like the board size, and side-wrapping.\n\nboard size: If board were 9x9, we can put a clone phaser in the center\nthat duplicates any non-clone pieces at most once.\n\nside wrapping: columns are cyclic: make board[row] = cyclic linked List?\n\n\n\nSpeaking of linked lists... Why am I not using them now?\nMaybe this is what I needed to store highlight;\n represent each of this.state.selectedPiece's moves as a boolean for 'highlight' in\n this.board[row][col] = {who: p.player | null, highlight: true | false :: added in Board.getMoves(pi)}\n for some row,col,  and p = this.piece[pi]\n to Leap.setPiece(), add this.state.board.updateBoard()\n\n*/\n\n\nfunction Board(size, p1, p2) {\n\tthis.p1 = p1;\n\tthis.p2 = p2;\n\tthis.board = this.initBoard(size);\n\tthis.piecesSeparator = 8;\n\tthis.pieces = this.initPieces(size, p1, p2);\n\tthis.updateBoard(); //add pieces to board\n}\n\n//TODO:\n//this.board[row][col] = {who: p.player | null, highlight: {row: some_row, col: some_col} | null:: added in Board.getMoves(pi)}\n//update occurs when (1) piece is cloned (pieces index may change)\n// and when (2) setPiece is called\n//To make highlight function properly, I'll have to call this.getMoves() from here.\n//It follows that I will have to remove other calls to this.getMoves()\nBoard.prototype.updateBoard = function (newPiece) {\n\tif (newPiece) {\n\t\tthis.board = this.board.map(row => row.map((cell, j) => {\n\t\t\tif (cell.who != null) { //increment all pi in board after piecesSeparator by one\n\t\t\t\tif (cell.who >= this.piecesSeparator) cell.who++;\n\t\t\t\t//if piece alive, keep on board\n\t\t\t\treturn this.pieces[cell.who].alive ? {who: cell.who, move:false} : {who: null, move:false};\n\t\t\t} else return {who: null, move: false};\n\t\t}));\n\t} else {\n\t\tthis.board = this.board.map(row => row.map((cell, j) =>\n\t\t\t(cell.who != null)\n\t\t\t? (this.pieces[cell.who].alive\n\t\t\t\t? {who: cell.who, move:false}\n\t\t\t\t: {who: null, move:false})\n\t\t\t: {who: null, move: false}\n\t\t));\n\t}\n}\n\nBoard.prototype.initBoard = function (size) {\n    let board = [], playerTwo = [], playerOne = [];\n\t\t//TODO: fill as {who: pi (this.pieces index), highlight: null}\n\t\tfor (let i = 0; i < size; i++) {\n\t\t\tplayerTwo.push({who: i, move: false});\n\t\t\tplayerOne.push({who: i+8, move: false});\n\t\t}\n\t\tboard.push(playerTwo);\n\t\tfor (let i = 1; i < size-1; i++) board.push(Array(size).fill({who: null, move: false}));\n\t\tboard.push(playerOne);\n\n    return board;\n}\n\nBoard.prototype.initPieces = function (size) {\n\tlet whitePieces = [];\n\tlet blackPieces = [];\n\tfor (let c = 0; c < size; c++) {\n\t\twhitePieces.push({player: this.p1, cloned: false, row: 7, col: c, alive: true});\n\t\tblackPieces.push({player: this.p2, cloned: false, row: 0, col: c, alive: true});\n\t}\n    return blackPieces.concat(whitePieces);\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n//Calls every time a clone is made\nBoard.prototype.insertAtSeparationIndex = function () {\n\tfor(let pi=this.piecesSeparator; pi<this.pieces.length; pi++) {\n\t\t//Finds index that separates p1 and p2 pieces\n\t\tif(this.pieces[pi].player !== this.p2) {\n\t\t\tthis.piecesSeparator = pi; //update\n\t\t\treturn pi;\n\t\t}\n\t}\n}\n\nBoard.prototype.makeClone = function (pi, row, col) {\n\tlet p = this.pieces[pi];\n\tp.cloned = true;\n\tlet clone = {player: p.player, cloned: true, row: row, col: col, alive: true};\n\tthis.pieces.splice(this.insertAtSeparationIndex(),0, clone); //add clone to pieces Array\n\tthis.updateBoard(true);\n\tthis.board[row][col].who = this.piecesSeparator;\n\treturn true;\n}\n\nBoard.prototype.canClone = function (pi) {\n\tlet p = this.pieces[pi];\n\treturn (!p.cloned && p.col < 7 && p.col > 0 && ( (p.player === this.p1 && !p.row) || (p.player === this.p2 && p.row === 7) ));\n}\n\nBoard.prototype.isCloneSpawn = function (pi, row, col) {\n\treturn this.canClone(pi) && this.board[row][col].who === null;\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\nBoard.prototype.getPlayer = function (pi) {\n\treturn this.pieces[pi].player;\n}\n\nBoard.prototype.isLeap = function (p, rowIncr, colIncr, isPhase, cellAdj, bypassCondition) {\n\t//if neighbor cell is a phase, leap_cell clear, and (enemy piece on phaseAdj XOR enemy piece on phaseFar)\n\tlet destinationCell = this.board[7 - p.row][7 - p.col];\n\tif(isPhase && !destinationCell.who) {\n\t\tlet phaseAdj = cellAdj.who;\n\t\tlet phaseFar = this.board[7 - (p.row + rowIncr)][7 - (p.col + colIncr)].who;\n\t\tif((phaseAdj || phaseFar) && !(phaseAdj && phaseFar)) { //xor filter. Only one may be true\n\t\t\tlet capt = phaseAdj ? phaseAdj : phaseFar;\n\t\t\t//if 0, add to destinationCell.move, if 1,\n\t\t\tif (bypassCondition) return true;\n\t\t\telse destinationCell.move = capt;\n\t\t}\n\t}\n}\n\nBoard.prototype.isJump = function (p, rowIncr, colIncr, cellAdj, bypassCondition) {\n\t//if adj cell occupied, jumpCell in bounds, jumpCell clear, and jumpCell has enemy piece\n\tif(util.inBounds(p.row + rowIncr*2, p.col + colIncr*2)) {\n\t\tlet destinationCell = this.board[p.row + rowIncr*2][p.col + colIncr*2];\n\t\tif (this.getPlayer(cellAdj.who) !== p.player && destinationCell.who === null) {\n\t\t\tif(bypassCondition%3) return true;\n\t\t\telse destinationCell.move = cellAdj.who;\n\t\t}\n\t}\n}\n\nBoard.prototype.isPhase = function (p, bypassCondition) {\n\tlet isPhase = util.cellType(p.row, p.col) > 1;\n\tlet destinationCell = this.board[7 - p.row][7 - p.col];\n\tif(isPhase && destinationCell.who === null) {\n\t\tif (bypassCondition%3) return true;\n\t\telse destinationCell.move = true;\n\t}\n}\n\nBoard.prototype.getCloneSpawns = function (p, bypassCondition) {\n\tlet row = p.player === this.p1 ? 7 : 0;\n\tfor(let col=1; col<7;col++) {\n\t\tlet destinationCell = this.board[row][col];\n\t\tif (destinationCell.who === null) {\n\t\t\tif (bypassCondition%3) return true;\n\t\t\telse destinationCell.move = true;\n\t\t}\n\t}\n}\n\nBoard.prototype.getMovesInDirection = function (p, bypassCondition, r, c) {\n\t//check adjacent cells of piece p wrt the boundary\n\tif(util.inBounds(p.row + r, p.col + c) && (r || c)) {\n\t\tlet cellAdj = this.board[p.row + r][p.col + c];\n\t\tlet isPhase = util.cellType(p.row + r, p.col + c) > 1;\n\n\t\tif (this.isLeap(p, r, c, isPhase, cellAdj, bypassCondition)) return true;\n\t\tif (cellAdj.who !== null) {\n\t\t\tif (this.isJump(p, r, c, cellAdj, bypassCondition)) return true;\n\t\t}\n\t\telse if (bypassCondition%3%2) return true;\t//adjacent moves\n\t\telse if (!bypassCondition) cellAdj.move = true;\n\t}\n\treturn false;\n}\n\n//bypassCondition (HIGHLIGHT BYPASS CONDITION): undefined - default (Store all), 1 - bypass all, 2 - bypass continuable moves, 3 - store continuable moves\nBoard.prototype.getMoves = function (pi, bypassCondition, r, c) {\n\n\tlet p = this.pieces[pi];\n\t//TODO: ref this.board[p.row + r][p.col + r].who, and set highlight = true for every destination\n\tif (this.isPhase(p, bypassCondition)) return true;\n\tif (this.canClone(pi) && this.getCloneSpawns(p, bypassCondition)) return true;\n\n\tif (r != null && c != null) {\n\t\tif (this.getMovesInDirection(p, bypassCondition, r, c)) return true;\n\t} else {\n\t\tfor(r=-1;r<2;r++) for(c=-1;c<2; c++) {\n\t\t\tif (this.getMovesInDirection(p, bypassCondition, r, c)) return true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n//Performs move. returns true if caught piece in process, else false\nBoard.prototype.doMove = function (pi, row, col) {\n\tlet p = this.pieces[pi];\n\t//begin move\n\tthis.board[p.row][p.col].who = null;\n\n\tlet destinationCell = this.board[row][col];\n\tlet caught = typeof(destinationCell.move) === \"number\" ? destinationCell.move : false; //caught piece index\n\t// moveDirection is defined if and only if any of the following is true (for moving piece p):\n\tlet moveDirection;\n\t\t// (1) p caught a piece\n\tif (caught) {\n\t\tlet c = this.pieces[caught];\n\t\tc.alive = false;\n\t\tthis.board[c.row][c.col].who = null;\n\t\t//return direction of move\n\t\t//If leap, then c adjacent at start XOR c adjacent at end\n\t\t//Check adjacency of moving piece to captured piece on starting position and ending position\n\t\tlet cellAdjStartPos = Math.abs(c.row - p.row) < 2 && Math.abs(c.col - p.col) < 2;\n\t\tlet cellAdjEndPos = Math.abs(row - c.row) < 2 && Math.abs(col - c.col) < 2;\n\n\t\tmoveDirection = (cellAdjStartPos && cellAdjEndPos)\n\t\t\t? {rowIncr: Math.sign(row-c.row), colIncr: Math.sign(col-c.col)}\t//jump\n\t\t\t: (cellAdjStartPos\n\t\t\t\t? {rowIncr: Math.sign(c.row-p.row), colIncr: Math.sign(c.col-p.row)}\t//leap-> piece adj to capture on start\n\t\t\t\t: {rowIncr: Math.sign(row-c.row), colIncr: Math.sign(col-c.col)});\n\t}\t// (2) p LANDS on a phase cell. That is, this move is not a phase.\n\telse if (!this.samePhase(p,{row: row, col: col}))\tmoveDirection = {rowIncr: 0, colIncr: 0};\n\n\t//end move\n\tthis.board[row][col].who = pi;\n\tp.row = row;\n\tp.col = col;\n\n\t\t// (3) p is able to be cloned\n\tif (this.canClone(pi)) moveDirection = {rowIncr: 0, colIncr:0};\n\tthis.updateBoard();\n\treturn moveDirection;\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tINTEGRITY\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\nBoard.prototype.samePhase = function (from, to) {\n\tlet isDestinationPhase = util.cellType(to.row, to.col);\n\treturn isDestinationPhase > 1 && isDestinationPhase === util.cellType(from.row, from.col);\n}\n\nBoard.prototype.canContinueMove = function (pi, dir) {\n\n\treturn dir ? this.getMoves(pi, 2, dir.rowIncr, dir.colIncr) : false;\n}\n\nBoard.prototype.hasMoves = function (pi) {\n\treturn this.getMoves(pi, 1);\n}\n\n//Player has no more moves when (1): all player's pieces are dead (2): every piece has no moves\nBoard.prototype.movesLeft = function (player) {\n\tfor(let pi=0; pi < this.pieces.length; pi++) {\n\t\tlet p = this.pieces[pi];\n\t\tif(p.alive && p.player === player) {\n\t\t\tif(this.hasMoves(pi)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nBoard.prototype.validMove = function (row, col) {\n\treturn this.board[row][col].move;\n}\n\nmodule.exports = Board;\n"]},"metadata":{},"sourceType":"module"}