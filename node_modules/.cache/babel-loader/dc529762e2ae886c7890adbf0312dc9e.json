{"ast":null,"code":"var util = require('./util.js'); //single, phase, jump, super-jump\n\n/*\nadj: adjacent\nphase: change portal side\nleap: capture piece while jumping through a portal\njitch: jump, then phase\nswump: switch, then jump\n}\n*/\n\n/*\nLEGEND\npi = piece index in Board.pieces\np = piece Board.pieces[pi]\n*/\n\n/*\nPreviously, I assumed that if a uncloned piece reaches the end of the other player's side,\nthen that piece must duplicate before continuing the game. However, my assumption fails\nif the player's spawn row is full and hence I will give the player the option to choose.\n\nThis realization got me thinking about adding different game modes that\nmodify things like the board size, and side-wrapping.\n\nboard size: If board were 9x9, we can put a clone phaser in the center\nthat duplicates any non-clone pieces at most once.\n\nside wrapping: columns are cyclic: make board[row] = cyclic linked List?\n\n\n\nSpeaking of linked lists... Why am I not using them now?\nMaybe this is what I needed to store highlight;\n represent each of this.state.selected_piece's moves as a boolean for 'highlight' in\n this.board[row][col] = {who: p.player | null, highlight: true | false :: added in Board.get_moves(pi)}\n for some row,col,  and p = this.piece[pi]\n to Leap.set_piece(), add this.state.board.update_board()\n\n*/\n\n\nfunction Board(size, p1, p2) {\n  this.p1 = p1;\n  this.p2 = p2;\n  this.board = this.init_board(size);\n  this.pieces_separator = 8;\n  this.pieces = this.init_pieces(size, p1, p2);\n  this.update_board(); //add pieces to board\n} //TODO:\n//this.board[row][col] = {who: p.player | null, highlight: {row: some_row, col: some_col} | null:: added in Board.get_moves(pi)}\n//update occurs when (1) piece is cloned (pieces index may change)\n// and when (2) set_piece is called\n//To make highlight function properly, I'll have to call this.get_moves() from here.\n//It follows that I will have to remove other calls to this.get_moves()\n\n\nBoard.prototype.update_board = function () {\n  this.board = this.board.map(row => row.map((cell, j) => cell.who != null ? this.pieces[cell.who].alive ? {\n    who: cell.who,\n    move: false\n  } : {\n    who: null,\n    move: false\n  } : {\n    who: null,\n    move: false\n  }));\n};\n\nBoard.prototype.init_board = function (size) {\n  let board = [],\n      player_two = [],\n      player_one = []; //TODO: fill as {who: pi (this.pieces index), highlight: null}\n\n  for (let i = 0; i < size; i++) {\n    player_two.push({\n      who: i,\n      move: false\n    });\n    player_one.push({\n      who: i + 8,\n      move: false\n    });\n  }\n\n  board.push(player_two);\n\n  for (let i = 1; i < size - 1; i++) board.push(Array(size).fill({\n    who: null,\n    move: false\n  }));\n\n  board.push(player_one);\n  return board;\n};\n\nBoard.prototype.init_pieces = function (size) {\n  let white_pieces = [];\n  let black_pieces = [];\n\n  for (let c = 0; c < size; c++) {\n    white_pieces.push({\n      player: this.p1,\n      cloned: false,\n      row: 7,\n      col: c,\n      alive: true\n    });\n    black_pieces.push({\n      player: this.p2,\n      cloned: false,\n      row: 0,\n      col: c,\n      alive: true\n    });\n  }\n\n  return black_pieces.concat(white_pieces);\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n//Calls every time a clone is made\n\n\nBoard.prototype.insert_at_separation_index = function () {\n  for (let pi = this.pieces_separator; pi < this.pieces.length; pi++) {\n    //Finds index that separates p1 and p2 pieces\n    if (this.pieces[pi].player !== this.p2) {\n      this.pieces_separator = pi; //update\n\n      return pi;\n    }\n  }\n};\n\nBoard.prototype.make_clone = function (pi, row, col) {\n  let p = this.pieces[pi];\n  p.cloned = true;\n  let clone = {\n    player: p.player,\n    cloned: true,\n    row: row,\n    col: col,\n    alive: true\n  };\n  this.pieces.splice(this.insert_at_separation_index(), 0, clone);\n  return true;\n};\n\nBoard.prototype.can_clone = function (pi) {\n  let p = this.pieces[pi];\n  return !p.cloned && p.col < 7 && p.col > 0 && (p.player === this.p1 && !p.row || p.player === this.p2 && p.row === 7);\n};\n\nBoard.prototype.is_clone_spawn = function (pi, row, col) {\n  if (this.can_clone(pi)) return this.board[row][col].who === null;\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n\nBoard.prototype.get_player = function (pi) {\n  return this.pieces[pi].player;\n};\n\nBoard.prototype.is_leap = function (p, row_incr, col_incr, is_phase, cell_adj, bypass_condition) {\n  //if neighbor cell is a phase, leap_cell clear, and (enemy piece on phase_adj XOR enemy piece on phase_far)\n  let destination_cell = this.board[7 - p.row][7 - p.col];\n\n  if (is_phase && !destination_cell.who) {\n    let phase_adj = cell_adj.who;\n    let phase_far = this.board[7 - (p.row + row_incr)][7 - (p.col + col_incr)].who;\n\n    if ((phase_adj || phase_far) && !(phase_adj && phase_far)) {\n      //xor filter. Only one may be true\n      let capt = phase_adj ? phase_adj : phase_far; //if 0, add to destination_cell.move, if 1,\n\n      if (bypass_condition) return true;else destination_cell.move = capt;\n    }\n  }\n};\n\nBoard.prototype.is_jump = function (p, row_incr, col_incr, cell_adj, bypass_condition) {\n  //if adj cell occupied, jump_cell in bounds, jump_cell clear, and jump_cell has enemy piece\n  if (util.in_bounds(p.row + row_incr * 2, p.col + col_incr * 2)) {\n    let destination_cell = this.board[p.row + row_incr * 2][p.col + col_incr * 2];\n\n    if (this.get_player(cell_adj.who) !== p.player && destination_cell.who === null) {\n      if (bypass_condition % 3) return true;else destination_cell.move = cell_adj.who;\n    }\n  }\n};\n\nBoard.prototype.is_phase = function (p, bypass_condition) {\n  let is_phase = util.cell_type(p.row, p.col) > 1;\n  let destination_cell = this.board[7 - p.row][7 - p.col];\n\n  if (is_phase && destination_cell.who === null) {\n    if (bypass_condition % 3) return true;else destination_cell.move = true;\n  }\n};\n\nBoard.prototype.get_clone_spawns = function (p, bypass_condition) {\n  let row = p.player === this.p1 ? 7 : 0;\n  let clone_spawns = [];\n\n  for (let col = 1; col < 7; col++) {\n    let destination_cell = this.board[row][col];\n\n    if (destination_cell.who === null) {\n      if (bypass_condition % 3) return true;else destination_cell.move = true;\n    }\n  }\n};\n\nBoard.prototype.get_moves_in_direction = function (p, bypass_condition, r, c) {\n  //check adjacent cells of piece p wrt the boundary\n  if (util.in_bounds(p.row + r, p.col + c) && (r || c)) {\n    let cell_adj = this.board[p.row + r][p.col + c];\n    let is_phase = util.cell_type(p.row + r, p.col + c) > 1;\n    if (this.is_leap(p, r, c, is_phase, cell_adj, bypass_condition)) return true;\n\n    if (cell_adj.who !== null) {\n      if (this.is_jump(p, r, c, cell_adj, bypass_condition)) return true;\n    } else if (bypass_condition % 3 % 2) return true; //adjacent moves\n    else if (!bypass_condition) cell_adj.move = true;\n  }\n\n  return false;\n}; //bypass_condition (HIGHLIGHT BYPASS CONDITION): undefined - default (Store all), 1 - bypass all, 2 - bypass continuable moves, 3 - store continuable moves\n\n\nBoard.prototype.get_moves = function (pi, bypass_condition, r, c) {\n  let p = this.pieces[pi]; //TODO: ref this.board[p.row + r][p.col + r].who, and set highlight = true for every destination\n\n  if (this.is_phase(p, bypass_condition)) return true;\n  if (this.can_clone(pi) && this.get_clone_spawns(p, bypass_condition)) return true;\n\n  if (r != null && c != null) {\n    if (this.get_moves_in_direction(p, bypass_condition, r, c)) return true;\n  } else {\n    for (r = -1; r < 2; r++) for (c = -1; c < 2; c++) {\n      if (this.get_moves_in_direction(p, bypass_condition, r, c)) return true;\n    }\n  }\n\n  return false;\n}; //Performs move. returns true if caught piece in process, else false\n\n\nBoard.prototype.do_move = function (pi, row, col) {\n  let p = this.pieces[pi]; //begin move\n\n  this.board[p.row][p.col].who = null;\n  let destination_cell = this.board[row][col];\n  let caught = typeof destination_cell.move === \"number\" ? destination_cell.move : false; //caught piece index\n  // move_direction is defined if and only if any of the following is true (for moving piece p):\n\n  let move_direction; // (1) p caught a piece\n\n  if (caught) {\n    let c = this.pieces[caught];\n    c.alive = false;\n    this.board[c.row][c.col].who = null; //return direction of move\n\n    move_direction = {\n      row_incr: Math.sign(row - c.row),\n      col_incr: Math.sign(col - c.col)\n    };\n  } // (2) p LANDS on a phase cell. That is, this move is not a phase.\n  else if (!this.same_phase(p, {\n      row: row,\n      col: col\n    })) move_direction = {\n      row_incr: 0,\n      col_incr: 0\n    }; //end move\n\n\n  this.board[row][col].who = pi;\n  p.row = row;\n  p.col = col; // (3) p is able to be cloned\n\n  if (this.can_clone(pi)) move_direction = {\n    row_incr: 0,\n    col_incr: 0\n  };\n  return move_direction;\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tINTEGRITY\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n\nBoard.prototype.same_phase = function (from, to) {\n  let is_destination_phase = util.cell_type(to.row, to.col);\n  return is_destination_phase > 1 && is_destination_phase === util.cell_type(from.row, from.col);\n};\n\nBoard.prototype.can_continue_move = function (pi, dir) {\n  return dir ? this.get_moves(pi, 2, dir.row_incr, dir.col_incr) : false;\n};\n\nBoard.prototype.has_moves = function (pi) {\n  return this.get_moves(pi, 1);\n}; //Player has no more moves when (1): all player's pieces are dead (2): every piece has no moves\n\n\nBoard.prototype.moves_left = function (player) {\n  for (let pi = 0; pi < this.pieces.length; pi++) {\n    let p = this.pieces[pi];\n\n    if (p.alive && p.player === player) {\n      if (this.has_moves(pi)) return true;\n    }\n  }\n\n  return false;\n};\n\nBoard.prototype.valid_move = function (row, col) {\n  return this.board[row][col].move;\n};\n\nmodule.exports = Board;","map":{"version":3,"sources":["/Users/bacchus/git/Leap/src/js/board.js"],"names":["util","require","Board","size","p1","p2","board","init_board","pieces_separator","pieces","init_pieces","update_board","prototype","map","row","cell","j","who","alive","move","player_two","player_one","i","push","Array","fill","white_pieces","black_pieces","c","player","cloned","col","concat","insert_at_separation_index","pi","length","make_clone","p","clone","splice","can_clone","is_clone_spawn","get_player","is_leap","row_incr","col_incr","is_phase","cell_adj","bypass_condition","destination_cell","phase_adj","phase_far","capt","is_jump","in_bounds","cell_type","get_clone_spawns","clone_spawns","get_moves_in_direction","r","get_moves","do_move","caught","move_direction","Math","sign","same_phase","from","to","is_destination_phase","can_continue_move","dir","has_moves","moves_left","valid_move","module","exports"],"mappings":"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","sourcesContent":["var util = require('./util.js');\n//single, phase, jump, super-jump\n/*\nadj: adjacent\nphase: change portal side\nleap: capture piece while jumping through a portal\njitch: jump, then phase\nswump: switch, then jump\n}\n*/\n/*\nLEGEND\npi = piece index in Board.pieces\np = piece Board.pieces[pi]\n*/\n\n/*\nPreviously, I assumed that if a uncloned piece reaches the end of the other player's side,\nthen that piece must duplicate before continuing the game. However, my assumption fails\nif the player's spawn row is full and hence I will give the player the option to choose.\n\nThis realization got me thinking about adding different game modes that\nmodify things like the board size, and side-wrapping.\n\nboard size: If board were 9x9, we can put a clone phaser in the center\nthat duplicates any non-clone pieces at most once.\n\nside wrapping: columns are cyclic: make board[row] = cyclic linked List?\n\n\n\nSpeaking of linked lists... Why am I not using them now?\nMaybe this is what I needed to store highlight;\n represent each of this.state.selected_piece's moves as a boolean for 'highlight' in\n this.board[row][col] = {who: p.player | null, highlight: true | false :: added in Board.get_moves(pi)}\n for some row,col,  and p = this.piece[pi]\n to Leap.set_piece(), add this.state.board.update_board()\n\n*/\n\n\nfunction Board(size, p1, p2) {\n\tthis.p1 = p1;\n\tthis.p2 = p2;\n\tthis.board = this.init_board(size);\n\tthis.pieces_separator = 8;\n\tthis.pieces = this.init_pieces(size, p1, p2);\n\tthis.update_board(); //add pieces to board\n}\n\n//TODO:\n//this.board[row][col] = {who: p.player | null, highlight: {row: some_row, col: some_col} | null:: added in Board.get_moves(pi)}\n//update occurs when (1) piece is cloned (pieces index may change)\n// and when (2) set_piece is called\n//To make highlight function properly, I'll have to call this.get_moves() from here.\n//It follows that I will have to remove other calls to this.get_moves()\nBoard.prototype.update_board = function () {\n\tthis.board = this.board.map(row => row.map((cell, j) =>\n\t\t(cell.who != null)\n\t\t? (this.pieces[cell.who].alive\n\t\t\t? {who: cell.who, move:false}\n\t\t\t: {who: null, move:false})\n\t\t: {who: null, move: false}\n\t));\n}\n\nBoard.prototype.init_board = function (size) {\n    let board = [], player_two = [], player_one = [];\n\t\t//TODO: fill as {who: pi (this.pieces index), highlight: null}\n\t\tfor (let i = 0; i < size; i++) {\n\t\t\tplayer_two.push({who: i, move: false});\n\t\t\tplayer_one.push({who: i+8, move: false});\n\t\t}\n\t\tboard.push(player_two);\n\t\tfor (let i = 1; i < size-1; i++) board.push(Array(size).fill({who: null, move: false}));\n\t\tboard.push(player_one);\n\n    return board;\n}\n\nBoard.prototype.init_pieces = function (size) {\n\tlet white_pieces = [];\n\tlet black_pieces = [];\n\tfor (let c = 0; c < size; c++) {\n\t\twhite_pieces.push({player: this.p1, cloned: false, row: 7, col: c, alive: true});\n\t\tblack_pieces.push({player: this.p2, cloned: false, row: 0, col: c, alive: true});\n\t}\n    return black_pieces.concat(white_pieces);\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n//Calls every time a clone is made\nBoard.prototype.insert_at_separation_index = function () {\n\tfor(let pi=this.pieces_separator; pi<this.pieces.length; pi++) {\n\t\t//Finds index that separates p1 and p2 pieces\n\t\tif(this.pieces[pi].player !== this.p2) {\n\t\t\tthis.pieces_separator = pi; //update\n\t\t\treturn pi;\n\t\t}\n\t}\n}\n\nBoard.prototype.make_clone = function (pi, row, col) {\n\tlet p = this.pieces[pi];\n\tp.cloned = true;\n\tlet clone = {player: p.player, cloned: true, row: row, col: col, alive: true};\n\tthis.pieces.splice(this.insert_at_separation_index(),0, clone);\n\treturn true;\n}\n\nBoard.prototype.can_clone = function (pi) {\n\tlet p = this.pieces[pi];\n\treturn (!p.cloned && p.col < 7 && p.col > 0 && ( (p.player === this.p1 && !p.row) || (p.player === this.p2 && p.row === 7) ));\n}\n\nBoard.prototype.is_clone_spawn = function (pi, row, col) {\n\tif (this.can_clone(pi)) return (this.board[row][col].who === null);\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\nBoard.prototype.get_player = function (pi) {\n\treturn this.pieces[pi].player;\n}\n\nBoard.prototype.is_leap = function (p, row_incr, col_incr, is_phase, cell_adj, bypass_condition) {\n\t//if neighbor cell is a phase, leap_cell clear, and (enemy piece on phase_adj XOR enemy piece on phase_far)\n\tlet destination_cell = this.board[7 - p.row][7 - p.col];\n\tif(is_phase && !destination_cell.who) {\n\t\tlet phase_adj = cell_adj.who;\n\t\tlet phase_far = this.board[7 - (p.row + row_incr)][7 - (p.col + col_incr)].who;\n\t\tif((phase_adj || phase_far) && !(phase_adj && phase_far)) { //xor filter. Only one may be true\n\t\t\tlet capt = phase_adj ? phase_adj : phase_far;\n\t\t\t//if 0, add to destination_cell.move, if 1,\n\t\t\tif (bypass_condition) return true;\n\t\t\telse destination_cell.move = capt;\n\t\t}\n\t}\n}\n\nBoard.prototype.is_jump = function (p, row_incr, col_incr, cell_adj, bypass_condition) {\n\t//if adj cell occupied, jump_cell in bounds, jump_cell clear, and jump_cell has enemy piece\n\tif(util.in_bounds(p.row + row_incr*2, p.col + col_incr*2)) {\n\t\tlet destination_cell = this.board[p.row + row_incr*2][p.col + col_incr*2];\n\t\tif (this.get_player(cell_adj.who) !== p.player && destination_cell.who === null) {\n\t\t\tif(bypass_condition%3) return true;\n\t\t\telse destination_cell.move = cell_adj.who;\n\t\t}\n\t}\n}\n\nBoard.prototype.is_phase = function (p, bypass_condition) {\n\tlet is_phase = util.cell_type(p.row, p.col) > 1;\n\tlet destination_cell = this.board[7 - p.row][7 - p.col];\n\tif(is_phase && destination_cell.who === null) {\n\t\tif (bypass_condition%3) return true;\n\t\telse destination_cell.move = true;\n\t}\n}\n\nBoard.prototype.get_clone_spawns = function (p, bypass_condition) {\n\tlet row = p.player === this.p1 ? 7 : 0;\n\tlet clone_spawns = [];\n\tfor(let col=1; col<7;col++) {\n\t\tlet destination_cell = this.board[row][col];\n\t\tif (destination_cell.who === null) {\n\t\t\tif (bypass_condition%3) return true;\n\t\t\telse destination_cell.move = true;\n\t\t}\n\t}\n}\n\nBoard.prototype.get_moves_in_direction = function (p, bypass_condition, r, c) {\n\t//check adjacent cells of piece p wrt the boundary\n\tif(util.in_bounds(p.row + r, p.col + c) && (r || c)) {\n\t\tlet cell_adj = this.board[p.row + r][p.col + c];\n\t\tlet is_phase = util.cell_type(p.row + r, p.col + c) > 1;\n\n\t\tif (this.is_leap(p, r, c, is_phase, cell_adj, bypass_condition)) return true;\n\t\tif (cell_adj.who !== null) {\n\t\t\tif (this.is_jump(p, r, c, cell_adj, bypass_condition)) return true;\n\t\t}\n\t\telse if (bypass_condition%3%2) return true;\t//adjacent moves\n\t\telse if (!bypass_condition) cell_adj.move = true;\n\t}\n\treturn false;\n}\n\n//bypass_condition (HIGHLIGHT BYPASS CONDITION): undefined - default (Store all), 1 - bypass all, 2 - bypass continuable moves, 3 - store continuable moves\nBoard.prototype.get_moves = function (pi, bypass_condition, r, c) {\n\n\tlet p = this.pieces[pi];\n\t//TODO: ref this.board[p.row + r][p.col + r].who, and set highlight = true for every destination\n\tif (this.is_phase(p, bypass_condition)) return true;\n\tif (this.can_clone(pi) && this.get_clone_spawns(p, bypass_condition)) return true;\n\n\tif (r != null && c != null) {\n\t\tif (this.get_moves_in_direction(p, bypass_condition, r, c)) return true;\n\t} else {\n\t\tfor(r=-1;r<2;r++) for(c=-1;c<2; c++) {\n\t\t\tif (this.get_moves_in_direction(p, bypass_condition, r, c)) return true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n//Performs move. returns true if caught piece in process, else false\nBoard.prototype.do_move = function (pi, row, col) {\n\tlet p = this.pieces[pi];\n\t//begin move\n\tthis.board[p.row][p.col].who = null;\n\n\tlet destination_cell = this.board[row][col];\n\tlet caught = typeof(destination_cell.move) === \"number\" ? destination_cell.move : false; //caught piece index\n\t// move_direction is defined if and only if any of the following is true (for moving piece p):\n\tlet move_direction;\n\t\t// (1) p caught a piece\n\tif (caught) {\n\t\tlet c = this.pieces[caught];\n\t\tc.alive = false;\n\t\tthis.board[c.row][c.col].who = null;\n\t\t//return direction of move\n\t\tmove_direction = {row_incr: Math.sign(row-c.row), col_incr: Math.sign(col-c.col)};\n\t}\t// (2) p LANDS on a phase cell. That is, this move is not a phase.\n\telse if (!this.same_phase(p,{row: row, col: col}))\tmove_direction = {row_incr: 0, col_incr: 0};\n\n\t//end move\n\tthis.board[row][col].who = pi;\n\tp.row = row;\n\tp.col = col;\n\n\t\t// (3) p is able to be cloned\n\tif (this.can_clone(pi)) move_direction = {row_incr: 0, col_incr:0};\n\n\treturn move_direction;\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tINTEGRITY\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\nBoard.prototype.same_phase = function (from, to) {\n\tlet is_destination_phase = util.cell_type(to.row, to.col);\n\treturn is_destination_phase > 1 && is_destination_phase === util.cell_type(from.row, from.col);\n}\n\nBoard.prototype.can_continue_move = function (pi, dir) {\n\n\treturn dir ? this.get_moves(pi, 2, dir.row_incr, dir.col_incr) : false;\n}\n\nBoard.prototype.has_moves = function (pi) {\n\treturn this.get_moves(pi, 1);\n}\n\n//Player has no more moves when (1): all player's pieces are dead (2): every piece has no moves\nBoard.prototype.moves_left = function (player) {\n\tfor(let pi=0; pi < this.pieces.length; pi++) {\n\t\tlet p = this.pieces[pi];\n\t\tif(p.alive && p.player === player) {\n\t\t\tif(this.has_moves(pi)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nBoard.prototype.valid_move = function (row, col) {\n\treturn this.board[row][col].move;\n}\n\nmodule.exports = Board;\n"]},"metadata":{},"sourceType":"module"}