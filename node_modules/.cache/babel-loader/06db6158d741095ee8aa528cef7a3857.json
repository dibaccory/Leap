{"ast":null,"code":"\"use strict\";\n/**\n * Copyright (c) 2018 Endel Dreyer\n * Copyright (c) 2014 Ion Drive Software Ltd.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * msgpack implementation highly based on notepack.io\n * https://github.com/darrachequesne/notepack\n */\n\nfunction utf8Length(str) {\n  var c = 0,\n      length = 0;\n\n  for (var i = 0, l = str.length; i < l; i++) {\n    c = str.charCodeAt(i);\n\n    if (c < 0x80) {\n      length += 1;\n    } else if (c < 0x800) {\n      length += 2;\n    } else if (c < 0xd800 || c >= 0xe000) {\n      length += 3;\n    } else {\n      i++;\n      length += 4;\n    }\n  }\n\n  return length;\n}\n\nfunction utf8Write(view, offset, str) {\n  var c = 0;\n\n  for (var i = 0, l = str.length; i < l; i++) {\n    c = str.charCodeAt(i);\n\n    if (c < 0x80) {\n      view[offset++] = c;\n    } else if (c < 0x800) {\n      view[offset++] = 0xc0 | c >> 6;\n      view[offset++] = 0x80 | c & 0x3f;\n    } else if (c < 0xd800 || c >= 0xe000) {\n      view[offset++] = 0xe0 | c >> 12;\n      view[offset++] = 0x80 | c >> 6 & 0x3f;\n      view[offset++] = 0x80 | c & 0x3f;\n    } else {\n      i++;\n      c = 0x10000 + ((c & 0x3ff) << 10 | str.charCodeAt(i) & 0x3ff);\n      view[offset++] = 0xf0 | c >> 18;\n      view[offset++] = 0x80 | c >> 12 & 0x3f;\n      view[offset++] = 0x80 | c >> 6 & 0x3f;\n      view[offset++] = 0x80 | c & 0x3f;\n    }\n  }\n}\n\nexports.utf8Write = utf8Write;\n\nfunction int8(bytes, value) {\n  bytes.push(value & 255);\n}\n\nexports.int8 = int8;\n;\n\nfunction uint8(bytes, value) {\n  bytes.push(value & 255);\n}\n\nexports.uint8 = uint8;\n;\n\nfunction int16(bytes, value) {\n  bytes.push(value & 255);\n  bytes.push(value >> 8 & 255);\n}\n\nexports.int16 = int16;\n;\n\nfunction uint16(bytes, value) {\n  bytes.push(value & 255);\n  bytes.push(value >> 8 & 255);\n}\n\nexports.uint16 = uint16;\n;\n\nfunction int32(bytes, value) {\n  bytes.push(value & 255);\n  bytes.push(value >> 8 & 255);\n  bytes.push(value >> 16 & 255);\n  bytes.push(value >> 24 & 255);\n}\n\nexports.int32 = int32;\n;\n\nfunction uint32(bytes, value) {\n  var b4 = value >> 24;\n  var b3 = value >> 16;\n  var b2 = value >> 8;\n  var b1 = value;\n  bytes.push(b1 & 255);\n  bytes.push(b2 & 255);\n  bytes.push(b3 & 255);\n  bytes.push(b4 & 255);\n}\n\nexports.uint32 = uint32;\n;\n\nfunction int64(bytes, value) {\n  var high = Math.floor(value / Math.pow(2, 32));\n  var low = value >>> 0;\n  uint32(bytes, low);\n  uint32(bytes, high);\n}\n\nexports.int64 = int64;\n;\n\nfunction uint64(bytes, value) {\n  var high = value / Math.pow(2, 32) >> 0;\n  var low = value >>> 0;\n  uint32(bytes, low);\n  uint32(bytes, high);\n}\n\nexports.uint64 = uint64;\n;\n\nfunction float32(bytes, value) {\n  writeFloat32(bytes, value);\n}\n\nexports.float32 = float32;\n\nfunction float64(bytes, value) {\n  writeFloat64(bytes, value);\n}\n\nexports.float64 = float64; // force little endian to facilitate decoding on multiple implementations\n\nvar _isLittleEndian = true; // new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n\nvar _int32 = new Int32Array(2);\n\nvar _float32 = new Float32Array(_int32.buffer);\n\nvar _float64 = new Float64Array(_int32.buffer);\n\nfunction writeFloat32(bytes, value) {\n  _float32[0] = value;\n  int32(bytes, _int32[0]);\n}\n\nexports.writeFloat32 = writeFloat32;\n;\n\nfunction writeFloat64(bytes, value) {\n  _float64[0] = value;\n  int32(bytes, _int32[_isLittleEndian ? 0 : 1]);\n  int32(bytes, _int32[_isLittleEndian ? 1 : 0]);\n}\n\nexports.writeFloat64 = writeFloat64;\n;\n\nfunction boolean(bytes, value) {\n  return uint8(bytes, value ? 1 : 0);\n}\n\nexports.boolean = boolean;\n;\n\nfunction string(bytes, value) {\n  // encode `null` strings as empty.\n  if (!value) {\n    value = \"\";\n  }\n\n  var length = utf8Length(value);\n  var size = 0; // fixstr\n\n  if (length < 0x20) {\n    bytes.push(length | 0xa0);\n    size = 1;\n  } // str 8\n  else if (length < 0x100) {\n      bytes.push(0xd9);\n      uint8(bytes, length);\n      size = 2;\n    } // str 16\n    else if (length < 0x10000) {\n        bytes.push(0xda);\n        uint16(bytes, length);\n        size = 3;\n      } // str 32\n      else if (length < 0x100000000) {\n          bytes.push(0xdb);\n          uint32(bytes, length);\n          size = 5;\n        } else {\n          throw new Error('String too long');\n        }\n\n  utf8Write(bytes, bytes.length, value);\n  return size + length;\n}\n\nexports.string = string;\n\nfunction number(bytes, value) {\n  if (isNaN(value)) {\n    return number(bytes, 0);\n  } else if (!isFinite(value)) {\n    return number(bytes, value > 0 ? Number.MAX_SAFE_INTEGER : -Number.MAX_SAFE_INTEGER);\n  } else if (value !== (value | 0)) {\n    bytes.push(0xcb);\n    writeFloat64(bytes, value);\n    return 9; // TODO: encode float 32?\n    // is it possible to differentiate between float32 / float64 here?\n    // // float 32\n    // bytes.push(0xca);\n    // writeFloat32(bytes, value);\n    // return 5;\n  }\n\n  if (value >= 0) {\n    // positive fixnum\n    if (value < 0x80) {\n      uint8(bytes, value);\n      return 1;\n    } // uint 8\n\n\n    if (value < 0x100) {\n      bytes.push(0xcc);\n      uint8(bytes, value);\n      return 2;\n    } // uint 16\n\n\n    if (value < 0x10000) {\n      bytes.push(0xcd);\n      uint16(bytes, value);\n      return 3;\n    } // uint 32\n\n\n    if (value < 0x100000000) {\n      bytes.push(0xce);\n      uint32(bytes, value);\n      return 5;\n    } // uint 64\n\n\n    bytes.push(0xcf);\n    uint64(bytes, value);\n    return 9;\n  } else {\n    // negative fixnum\n    if (value >= -0x20) {\n      bytes.push(value);\n      return 1;\n    } // int 8\n\n\n    if (value >= -0x80) {\n      bytes.push(0xd0);\n      int8(bytes, value);\n      return 2;\n    } // int 16\n\n\n    if (value >= -0x8000) {\n      bytes.push(0xd1);\n      int16(bytes, value);\n      return 3;\n    } // int 32\n\n\n    if (value >= -0x80000000) {\n      bytes.push(0xd2);\n      int32(bytes, value);\n      return 5;\n    } // int 64\n\n\n    bytes.push(0xd3);\n    int64(bytes, value);\n    return 9;\n  }\n}\n\nexports.number = number;","map":{"version":3,"sources":["../../src/encoding/encode.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;;;;;AAMA,SAAS,UAAT,CAAoB,GAApB,EAAuB;AACrB,MAAI,CAAC,GAAG,CAAR;AAAA,MAAW,MAAM,GAAG,CAApB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,CAAC,GAAG,GAAG,CAAC,MAAxB,EAAgC,CAAC,GAAG,CAApC,EAAuC,CAAC,EAAxC,EAA4C;AAC1C,IAAA,CAAC,GAAG,GAAG,CAAC,UAAJ,CAAe,CAAf,CAAJ;;AACA,QAAI,CAAC,GAAG,IAAR,EAAc;AACZ,MAAA,MAAM,IAAI,CAAV;AACD,KAFD,MAGK,IAAI,CAAC,GAAG,KAAR,EAAe;AAClB,MAAA,MAAM,IAAI,CAAV;AACD,KAFI,MAGA,IAAI,CAAC,GAAG,MAAJ,IAAc,CAAC,IAAI,MAAvB,EAA+B;AAClC,MAAA,MAAM,IAAI,CAAV;AACD,KAFI,MAGA;AACH,MAAA,CAAC;AACD,MAAA,MAAM,IAAI,CAAV;AACD;AACF;;AACD,SAAO,MAAP;AACD;;AAED,SAAgB,SAAhB,CAA0B,IAA1B,EAAgC,MAAhC,EAAwC,GAAxC,EAA2C;AACzC,MAAI,CAAC,GAAG,CAAR;;AACA,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,CAAC,GAAG,GAAG,CAAC,MAAxB,EAAgC,CAAC,GAAG,CAApC,EAAuC,CAAC,EAAxC,EAA4C;AAC1C,IAAA,CAAC,GAAG,GAAG,CAAC,UAAJ,CAAe,CAAf,CAAJ;;AACA,QAAI,CAAC,GAAG,IAAR,EAAc;AACZ,MAAA,IAAI,CAAC,MAAM,EAAP,CAAJ,GAAiB,CAAjB;AACD,KAFD,MAGK,IAAI,CAAC,GAAG,KAAR,EAAe;AAClB,MAAA,IAAI,CAAC,MAAM,EAAP,CAAJ,GAAiB,OAAQ,CAAC,IAAI,CAA9B;AACA,MAAA,IAAI,CAAC,MAAM,EAAP,CAAJ,GAAiB,OAAQ,CAAC,GAAG,IAA7B;AACD,KAHI,MAIA,IAAI,CAAC,GAAG,MAAJ,IAAc,CAAC,IAAI,MAAvB,EAA+B;AAClC,MAAA,IAAI,CAAC,MAAM,EAAP,CAAJ,GAAiB,OAAQ,CAAC,IAAI,EAA9B;AACA,MAAA,IAAI,CAAC,MAAM,EAAP,CAAJ,GAAiB,OAAQ,CAAC,IAAI,CAAL,GAAS,IAAlC;AACA,MAAA,IAAI,CAAC,MAAM,EAAP,CAAJ,GAAiB,OAAQ,CAAC,GAAG,IAA7B;AACD,KAJI,MAKA;AACH,MAAA,CAAC;AACD,MAAA,CAAC,GAAG,WAAY,CAAC,CAAC,GAAG,KAAL,KAAe,EAAhB,GAAuB,GAAG,CAAC,UAAJ,CAAe,CAAf,IAAoB,KAAtD,CAAJ;AACA,MAAA,IAAI,CAAC,MAAM,EAAP,CAAJ,GAAiB,OAAQ,CAAC,IAAI,EAA9B;AACA,MAAA,IAAI,CAAC,MAAM,EAAP,CAAJ,GAAiB,OAAQ,CAAC,IAAI,EAAL,GAAU,IAAnC;AACA,MAAA,IAAI,CAAC,MAAM,EAAP,CAAJ,GAAiB,OAAQ,CAAC,IAAI,CAAL,GAAS,IAAlC;AACA,MAAA,IAAI,CAAC,MAAM,EAAP,CAAJ,GAAiB,OAAQ,CAAC,GAAG,IAA7B;AACD;AACF;AACF;;AAzBD,OAAA,CAAA,SAAA,GAAA,SAAA;;AA2BA,SAAgB,IAAhB,CAAqB,KAArB,EAA4B,KAA5B,EAAiC;AAC/B,EAAA,KAAK,CAAC,IAAN,CAAW,KAAK,GAAG,GAAnB;AACD;;AAFD,OAAA,CAAA,IAAA,GAAA,IAAA;AAEC;;AAED,SAAgB,KAAhB,CAAsB,KAAtB,EAA6B,KAA7B,EAAkC;AAChC,EAAA,KAAK,CAAC,IAAN,CAAW,KAAK,GAAG,GAAnB;AACD;;AAFD,OAAA,CAAA,KAAA,GAAA,KAAA;AAEC;;AAED,SAAgB,KAAhB,CAAsB,KAAtB,EAA6B,KAA7B,EAAkC;AAChC,EAAA,KAAK,CAAC,IAAN,CAAW,KAAK,GAAG,GAAnB;AACA,EAAA,KAAK,CAAC,IAAN,CAAY,KAAK,IAAI,CAAV,GAAe,GAA1B;AACD;;AAHD,OAAA,CAAA,KAAA,GAAA,KAAA;AAGC;;AAED,SAAgB,MAAhB,CAAuB,KAAvB,EAA8B,KAA9B,EAAmC;AACjC,EAAA,KAAK,CAAC,IAAN,CAAW,KAAK,GAAG,GAAnB;AACA,EAAA,KAAK,CAAC,IAAN,CAAY,KAAK,IAAI,CAAV,GAAe,GAA1B;AACD;;AAHD,OAAA,CAAA,MAAA,GAAA,MAAA;AAGC;;AAED,SAAgB,KAAhB,CAAsB,KAAtB,EAA6B,KAA7B,EAAkC;AAChC,EAAA,KAAK,CAAC,IAAN,CAAW,KAAK,GAAG,GAAnB;AACA,EAAA,KAAK,CAAC,IAAN,CAAY,KAAK,IAAI,CAAV,GAAe,GAA1B;AACA,EAAA,KAAK,CAAC,IAAN,CAAY,KAAK,IAAI,EAAV,GAAgB,GAA3B;AACA,EAAA,KAAK,CAAC,IAAN,CAAY,KAAK,IAAI,EAAV,GAAgB,GAA3B;AACD;;AALD,OAAA,CAAA,KAAA,GAAA,KAAA;AAKC;;AAED,SAAgB,MAAhB,CAAuB,KAAvB,EAA8B,KAA9B,EAAmC;AACjC,MAAM,EAAE,GAAG,KAAK,IAAI,EAApB;AACA,MAAM,EAAE,GAAG,KAAK,IAAI,EAApB;AACA,MAAM,EAAE,GAAG,KAAK,IAAI,CAApB;AACA,MAAM,EAAE,GAAG,KAAX;AACA,EAAA,KAAK,CAAC,IAAN,CAAW,EAAE,GAAG,GAAhB;AACA,EAAA,KAAK,CAAC,IAAN,CAAW,EAAE,GAAG,GAAhB;AACA,EAAA,KAAK,CAAC,IAAN,CAAW,EAAE,GAAG,GAAhB;AACA,EAAA,KAAK,CAAC,IAAN,CAAW,EAAE,GAAG,GAAhB;AACD;;AATD,OAAA,CAAA,MAAA,GAAA,MAAA;AASC;;AAED,SAAgB,KAAhB,CAAsB,KAAtB,EAA6B,KAA7B,EAAkC;AAChC,MAAM,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,EAAZ,CAAnB,CAAb;AACA,MAAM,GAAG,GAAG,KAAK,KAAK,CAAtB;AACA,EAAA,MAAM,CAAC,KAAD,EAAQ,GAAR,CAAN;AACA,EAAA,MAAM,CAAC,KAAD,EAAQ,IAAR,CAAN;AACD;;AALD,OAAA,CAAA,KAAA,GAAA,KAAA;AAKC;;AAED,SAAgB,MAAhB,CAAuB,KAAvB,EAA8B,KAA9B,EAAmC;AACjC,MAAM,IAAI,GAAI,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,EAAZ,CAAT,IAA6B,CAA1C;AACA,MAAM,GAAG,GAAG,KAAK,KAAK,CAAtB;AACA,EAAA,MAAM,CAAC,KAAD,EAAQ,GAAR,CAAN;AACA,EAAA,MAAM,CAAC,KAAD,EAAQ,IAAR,CAAN;AACD;;AALD,OAAA,CAAA,MAAA,GAAA,MAAA;AAKC;;AAED,SAAgB,OAAhB,CAAwB,KAAxB,EAA+B,KAA/B,EAAoC;AAClC,EAAA,YAAY,CAAC,KAAD,EAAQ,KAAR,CAAZ;AACD;;AAFD,OAAA,CAAA,OAAA,GAAA,OAAA;;AAIA,SAAgB,OAAhB,CAAwB,KAAxB,EAA+B,KAA/B,EAAoC;AAClC,EAAA,YAAY,CAAC,KAAD,EAAQ,KAAR,CAAZ;AACD;;AAFD,OAAA,CAAA,OAAA,GAAA,OAAA,C,CAIA;;AACA,IAAM,eAAe,GAAG,IAAxB,C,CAA+B;;AAC/B,IAAM,MAAM,GAAG,IAAI,UAAJ,CAAe,CAAf,CAAf;;AACA,IAAM,QAAQ,GAAG,IAAI,YAAJ,CAAiB,MAAM,CAAC,MAAxB,CAAjB;;AACA,IAAM,QAAQ,GAAG,IAAI,YAAJ,CAAiB,MAAM,CAAC,MAAxB,CAAjB;;AAEA,SAAgB,YAAhB,CAA6B,KAA7B,EAAoC,KAApC,EAAyC;AACvC,EAAA,QAAQ,CAAC,CAAD,CAAR,GAAc,KAAd;AACA,EAAA,KAAK,CAAC,KAAD,EAAQ,MAAM,CAAC,CAAD,CAAd,CAAL;AACD;;AAHD,OAAA,CAAA,YAAA,GAAA,YAAA;AAGC;;AAED,SAAgB,YAAhB,CAA6B,KAA7B,EAAoC,KAApC,EAAyC;AACvC,EAAA,QAAQ,CAAC,CAAD,CAAR,GAAc,KAAd;AACA,EAAA,KAAK,CAAC,KAAD,EAAQ,MAAM,CAAC,eAAe,GAAG,CAAH,GAAO,CAAvB,CAAd,CAAL;AACA,EAAA,KAAK,CAAC,KAAD,EAAQ,MAAM,CAAC,eAAe,GAAG,CAAH,GAAO,CAAvB,CAAd,CAAL;AACD;;AAJD,OAAA,CAAA,YAAA,GAAA,YAAA;AAIC;;AAED,SAAgB,OAAhB,CAAwB,KAAxB,EAA+B,KAA/B,EAAoC;AAClC,SAAO,KAAK,CAAC,KAAD,EAAQ,KAAK,GAAG,CAAH,GAAO,CAApB,CAAZ;AACD;;AAFD,OAAA,CAAA,OAAA,GAAA,OAAA;AAEC;;AAED,SAAgB,MAAhB,CAAuB,KAAvB,EAA8B,KAA9B,EAAmC;AACjC;AACA,MAAI,CAAC,KAAL,EAAY;AAAE,IAAA,KAAK,GAAG,EAAR;AAAa;;AAE3B,MAAI,MAAM,GAAG,UAAU,CAAC,KAAD,CAAvB;AACA,MAAI,IAAI,GAAG,CAAX,CALiC,CAOjC;;AACA,MAAI,MAAM,GAAG,IAAb,EAAmB;AACjB,IAAA,KAAK,CAAC,IAAN,CAAW,MAAM,GAAG,IAApB;AACA,IAAA,IAAI,GAAG,CAAP;AACD,GAHD,CAIA;AAJA,OAKK,IAAI,MAAM,GAAG,KAAb,EAAoB;AACvB,MAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACA,MAAA,KAAK,CAAC,KAAD,EAAQ,MAAR,CAAL;AACA,MAAA,IAAI,GAAG,CAAP;AACD,KAJI,CAKL;AALK,SAMA,IAAI,MAAM,GAAG,OAAb,EAAsB;AACzB,QAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACA,QAAA,MAAM,CAAC,KAAD,EAAQ,MAAR,CAAN;AACA,QAAA,IAAI,GAAG,CAAP;AACD,OAJI,CAKL;AALK,WAMA,IAAI,MAAM,GAAG,WAAb,EAA0B;AAC7B,UAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACA,UAAA,MAAM,CAAC,KAAD,EAAQ,MAAR,CAAN;AACA,UAAA,IAAI,GAAG,CAAP;AACD,SAJI,MAIE;AACL,gBAAM,IAAI,KAAJ,CAAU,iBAAV,CAAN;AACD;;AAED,EAAA,SAAS,CAAC,KAAD,EAAQ,KAAK,CAAC,MAAd,EAAsB,KAAtB,CAAT;AAEA,SAAO,IAAI,GAAG,MAAd;AACD;;AApCD,OAAA,CAAA,MAAA,GAAA,MAAA;;AAsCA,SAAgB,MAAhB,CAAuB,KAAvB,EAA8B,KAA9B,EAAmC;AACjC,MAAI,KAAK,CAAC,KAAD,CAAT,EAAkB;AAChB,WAAO,MAAM,CAAC,KAAD,EAAQ,CAAR,CAAb;AAED,GAHD,MAGO,IAAI,CAAC,QAAQ,CAAC,KAAD,CAAb,EAAsB;AAC3B,WAAO,MAAM,CAAC,KAAD,EAAS,KAAK,GAAG,CAAT,GAAc,MAAM,CAAC,gBAArB,GAAwC,CAAC,MAAM,CAAC,gBAAxD,CAAb;AAED,GAHM,MAGA,IAAI,KAAK,MAAM,KAAK,GAAC,CAAZ,CAAT,EAAyB;AAC9B,IAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACA,IAAA,YAAY,CAAC,KAAD,EAAQ,KAAR,CAAZ;AACA,WAAO,CAAP,CAH8B,CAK9B;AACA;AAEA;AACA;AACA;AACA;AACD;;AAED,MAAI,KAAK,IAAI,CAAb,EAAgB;AACd;AACA,QAAI,KAAK,GAAG,IAAZ,EAAkB;AAChB,MAAA,KAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,aAAO,CAAP;AACD,KALa,CAOd;;;AACA,QAAI,KAAK,GAAG,KAAZ,EAAmB;AACjB,MAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACA,MAAA,KAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,aAAO,CAAP;AACD,KAZa,CAcd;;;AACA,QAAI,KAAK,GAAG,OAAZ,EAAqB;AACnB,MAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACA,MAAA,MAAM,CAAC,KAAD,EAAQ,KAAR,CAAN;AACA,aAAO,CAAP;AACD,KAnBa,CAqBd;;;AACA,QAAI,KAAK,GAAG,WAAZ,EAAyB;AACvB,MAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACA,MAAA,MAAM,CAAC,KAAD,EAAQ,KAAR,CAAN;AACA,aAAO,CAAP;AACD,KA1Ba,CA4Bd;;;AACA,IAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACA,IAAA,MAAM,CAAC,KAAD,EAAQ,KAAR,CAAN;AACA,WAAO,CAAP;AAED,GAjCD,MAiCO;AAEL;AACA,QAAI,KAAK,IAAI,CAAC,IAAd,EAAoB;AAClB,MAAA,KAAK,CAAC,IAAN,CAAW,KAAX;AACA,aAAO,CAAP;AACD,KANI,CAQL;;;AACA,QAAI,KAAK,IAAI,CAAC,IAAd,EAAoB;AAClB,MAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACA,MAAA,IAAI,CAAC,KAAD,EAAQ,KAAR,CAAJ;AACA,aAAO,CAAP;AACD,KAbI,CAeL;;;AACA,QAAI,KAAK,IAAI,CAAC,MAAd,EAAsB;AACpB,MAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACA,MAAA,KAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,aAAO,CAAP;AACD,KApBI,CAsBL;;;AACA,QAAI,KAAK,IAAI,CAAC,UAAd,EAA0B;AACxB,MAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACA,MAAA,KAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,aAAO,CAAP;AACD,KA3BI,CA6BL;;;AACA,IAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACA,IAAA,KAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,WAAO,CAAP;AACD;AACF;;AAxFD,OAAA,CAAA,MAAA,GAAA,MAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright (c) 2018 Endel Dreyer\n * Copyright (c) 2014 Ion Drive Software Ltd.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * msgpack implementation highly based on notepack.io\n * https://github.com/darrachequesne/notepack\n */\nfunction utf8Length(str) {\n    var c = 0, length = 0;\n    for (var i = 0, l = str.length; i < l; i++) {\n        c = str.charCodeAt(i);\n        if (c < 0x80) {\n            length += 1;\n        }\n        else if (c < 0x800) {\n            length += 2;\n        }\n        else if (c < 0xd800 || c >= 0xe000) {\n            length += 3;\n        }\n        else {\n            i++;\n            length += 4;\n        }\n    }\n    return length;\n}\nfunction utf8Write(view, offset, str) {\n    var c = 0;\n    for (var i = 0, l = str.length; i < l; i++) {\n        c = str.charCodeAt(i);\n        if (c < 0x80) {\n            view[offset++] = c;\n        }\n        else if (c < 0x800) {\n            view[offset++] = 0xc0 | (c >> 6);\n            view[offset++] = 0x80 | (c & 0x3f);\n        }\n        else if (c < 0xd800 || c >= 0xe000) {\n            view[offset++] = 0xe0 | (c >> 12);\n            view[offset++] = 0x80 | (c >> 6 & 0x3f);\n            view[offset++] = 0x80 | (c & 0x3f);\n        }\n        else {\n            i++;\n            c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));\n            view[offset++] = 0xf0 | (c >> 18);\n            view[offset++] = 0x80 | (c >> 12 & 0x3f);\n            view[offset++] = 0x80 | (c >> 6 & 0x3f);\n            view[offset++] = 0x80 | (c & 0x3f);\n        }\n    }\n}\nexports.utf8Write = utf8Write;\nfunction int8(bytes, value) {\n    bytes.push(value & 255);\n}\nexports.int8 = int8;\n;\nfunction uint8(bytes, value) {\n    bytes.push(value & 255);\n}\nexports.uint8 = uint8;\n;\nfunction int16(bytes, value) {\n    bytes.push(value & 255);\n    bytes.push((value >> 8) & 255);\n}\nexports.int16 = int16;\n;\nfunction uint16(bytes, value) {\n    bytes.push(value & 255);\n    bytes.push((value >> 8) & 255);\n}\nexports.uint16 = uint16;\n;\nfunction int32(bytes, value) {\n    bytes.push(value & 255);\n    bytes.push((value >> 8) & 255);\n    bytes.push((value >> 16) & 255);\n    bytes.push((value >> 24) & 255);\n}\nexports.int32 = int32;\n;\nfunction uint32(bytes, value) {\n    var b4 = value >> 24;\n    var b3 = value >> 16;\n    var b2 = value >> 8;\n    var b1 = value;\n    bytes.push(b1 & 255);\n    bytes.push(b2 & 255);\n    bytes.push(b3 & 255);\n    bytes.push(b4 & 255);\n}\nexports.uint32 = uint32;\n;\nfunction int64(bytes, value) {\n    var high = Math.floor(value / Math.pow(2, 32));\n    var low = value >>> 0;\n    uint32(bytes, low);\n    uint32(bytes, high);\n}\nexports.int64 = int64;\n;\nfunction uint64(bytes, value) {\n    var high = (value / Math.pow(2, 32)) >> 0;\n    var low = value >>> 0;\n    uint32(bytes, low);\n    uint32(bytes, high);\n}\nexports.uint64 = uint64;\n;\nfunction float32(bytes, value) {\n    writeFloat32(bytes, value);\n}\nexports.float32 = float32;\nfunction float64(bytes, value) {\n    writeFloat64(bytes, value);\n}\nexports.float64 = float64;\n// force little endian to facilitate decoding on multiple implementations\nvar _isLittleEndian = true; // new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\nvar _int32 = new Int32Array(2);\nvar _float32 = new Float32Array(_int32.buffer);\nvar _float64 = new Float64Array(_int32.buffer);\nfunction writeFloat32(bytes, value) {\n    _float32[0] = value;\n    int32(bytes, _int32[0]);\n}\nexports.writeFloat32 = writeFloat32;\n;\nfunction writeFloat64(bytes, value) {\n    _float64[0] = value;\n    int32(bytes, _int32[_isLittleEndian ? 0 : 1]);\n    int32(bytes, _int32[_isLittleEndian ? 1 : 0]);\n}\nexports.writeFloat64 = writeFloat64;\n;\nfunction boolean(bytes, value) {\n    return uint8(bytes, value ? 1 : 0);\n}\nexports.boolean = boolean;\n;\nfunction string(bytes, value) {\n    // encode `null` strings as empty.\n    if (!value) {\n        value = \"\";\n    }\n    var length = utf8Length(value);\n    var size = 0;\n    // fixstr\n    if (length < 0x20) {\n        bytes.push(length | 0xa0);\n        size = 1;\n    }\n    // str 8\n    else if (length < 0x100) {\n        bytes.push(0xd9);\n        uint8(bytes, length);\n        size = 2;\n    }\n    // str 16\n    else if (length < 0x10000) {\n        bytes.push(0xda);\n        uint16(bytes, length);\n        size = 3;\n    }\n    // str 32\n    else if (length < 0x100000000) {\n        bytes.push(0xdb);\n        uint32(bytes, length);\n        size = 5;\n    }\n    else {\n        throw new Error('String too long');\n    }\n    utf8Write(bytes, bytes.length, value);\n    return size + length;\n}\nexports.string = string;\nfunction number(bytes, value) {\n    if (isNaN(value)) {\n        return number(bytes, 0);\n    }\n    else if (!isFinite(value)) {\n        return number(bytes, (value > 0) ? Number.MAX_SAFE_INTEGER : -Number.MAX_SAFE_INTEGER);\n    }\n    else if (value !== (value | 0)) {\n        bytes.push(0xcb);\n        writeFloat64(bytes, value);\n        return 9;\n        // TODO: encode float 32?\n        // is it possible to differentiate between float32 / float64 here?\n        // // float 32\n        // bytes.push(0xca);\n        // writeFloat32(bytes, value);\n        // return 5;\n    }\n    if (value >= 0) {\n        // positive fixnum\n        if (value < 0x80) {\n            uint8(bytes, value);\n            return 1;\n        }\n        // uint 8\n        if (value < 0x100) {\n            bytes.push(0xcc);\n            uint8(bytes, value);\n            return 2;\n        }\n        // uint 16\n        if (value < 0x10000) {\n            bytes.push(0xcd);\n            uint16(bytes, value);\n            return 3;\n        }\n        // uint 32\n        if (value < 0x100000000) {\n            bytes.push(0xce);\n            uint32(bytes, value);\n            return 5;\n        }\n        // uint 64\n        bytes.push(0xcf);\n        uint64(bytes, value);\n        return 9;\n    }\n    else {\n        // negative fixnum\n        if (value >= -0x20) {\n            bytes.push(value);\n            return 1;\n        }\n        // int 8\n        if (value >= -0x80) {\n            bytes.push(0xd0);\n            int8(bytes, value);\n            return 2;\n        }\n        // int 16\n        if (value >= -0x8000) {\n            bytes.push(0xd1);\n            int16(bytes, value);\n            return 3;\n        }\n        // int 32\n        if (value >= -0x80000000) {\n            bytes.push(0xd2);\n            int32(bytes, value);\n            return 5;\n        }\n        // int 64\n        bytes.push(0xd3);\n        int64(bytes, value);\n        return 9;\n    }\n}\nexports.number = number;\n//# sourceMappingURL=encode.js.map"]},"metadata":{},"sourceType":"script"}