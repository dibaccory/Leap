{"ast":null,"code":"//single, phase, jump, super-jump\n\n/*\nadj: adjacent\nphase: change portal side\nleap: capture piece while jumping through a portal\njitch: jump, then phase\nswump: switch, then jump\n}\n*/\n\n/*\nLEGEND\npi = piece index in Board.pieces\np = piece Board.pieces[pi]\n*/\n\n/*\nPreviously, I assumed that if a uncloned piece reaches the end of the other player's side,\nthen that piece must duplicate before continuing the game. However, my assumption fails\nif the player's spawn row is full and hence I will give the player the option to choose.\n\nThis realization got me thinking about adding different game modes that\nmodify things like the board size, and side-wrapping.\n\nboard size: If board were 9x9, we can put a clone phaser in the center\nthat duplicates any non-clone pieces at most once.\n\nside wrapping: columns are cyclic: make board[row] = cyclic linked List?\n\n\n\nSpeaking of linked lists... Why am I not using them now?\nMaybe this is what I needed to store highlight;\n represent each of this.state.selected_piece's moves as a boolean for 'highlight' in\n this.board[row][col] = {who: p.player | null, highlight: true | false :: added in Board.get_moves(pi)}\n for some row,col,  and p = this.piece[pi]\n to Leap.set_piece(), add this.state.board.update_board()\n\n*/\nfunction cell_type(row, col) {\n  let type;\n\n  switch (true) {\n    case row == 1 && col == 2 || row == 6 && col == 5:\n      type = 2;\n      break;\n\n    case row == 3 && col == 2 || row == 4 && col == 5:\n      type = 3;\n      break;\n\n    case row == 4 && col == 2 || row == 3 && col == 5:\n      type = 4;\n      break;\n\n    case row == 5 && col == 3 || row == 2 && col == 4:\n      type = 5;\n      break;\n\n    case row == 5 && col == 4 || row == 2 && col == 3:\n      type = 6;\n      break;\n\n    case row == 6 && col == 2 || row == 1 && col == 5:\n      type = 7;\n      break;\n\n    default:\n      type = (row + col) % 2 == 0 ? 0 : 1;\n      break;\n  }\n\n  return type;\n}\n\nfunction in_bounds(row, col) {\n  return (row > -1 || row < 8) && (col > -1 || col < 8);\n}\n\nfunction Board(size, p1, p2) {\n  this.board = this.init_board(size);\n  this.p1 = p1;\n  this.p2 = p2;\n  this.pieces_separator = 8;\n  this.pieces = this.init_pieces(size, p1, p2);\n} //TODO:\n//this.board[row][col] = {who: p.player | null, highlight: {row: some_row, col: some_col} | null:: added in Board.get_moves(pi)}\n//update occurs when (1) piece is cloned (pieces index may change)\n// and when (2) set_piece is called\n//To make highlight function properly, I'll have to call this.get_moves() from here.\n//It follows that I will have to remove other calls to this.get_moves()\n\n\nBoard.prototype.update_board = function () {\n  this.board.map(row => row.map((cell, j) => cell !== null ? this.pieces[cell].alive ? this.pieces[cell] : null : null));\n};\n\nBoard.prototype.init_board = function (size) {\n  let b = [];\n\n  for (let i = 0; i < size; i++) b.push(Array(size).fill(null));\n\n  return b;\n};\n\nBoard.prototype.init_pieces = function (size) {\n  let white_pieces = [];\n  let black_pieces = [];\n\n  for (let i = 0; i < size; i++) {\n    white_pieces.push({\n      player: this.p1,\n      cloned: false,\n      row: 7,\n      col: 1,\n      alive: true\n    });\n    black_pieces.push({\n      player: this.p2,\n      cloned: false,\n      row: 0,\n      col: 1,\n      alive: true\n    });\n  }\n\n  this.update_board(); //add pieces to board\n\n  return white_pieces.concat(black_pieces);\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n//Calls every time a clone is made\n\n\nBoard.prototype.insert_at_separation_index = function () {\n  for (let pi = this.pieces_separator; pi < this.pieces.length; pi++) {\n    //Finds index that separates p1 and p2 pieces\n    if (this.pieces[pi].player != this.p1) {\n      this.pieces_separator = pi; //update\n\n      return pi;\n    }\n  }\n};\n\nBoard.prototype.make_clone = function (pi, row, col) {\n  this.pieces[pi].cloned = true; //row will only be 0 or 7, so we can use this to determine player and placement\n\n  let player = row ? this.p1 : this.p2;\n  let clone = {\n    player: player,\n    cloned: true,\n    row: row,\n    col: col,\n    alive: true\n  };\n  return this.pieces.splice(this.insert_at_separation_index(), 0, clone);\n};\n\nBoard.prototype.can_clone = function (pi) {\n  let p = this.pieces[pi];\n  return !p.cloned && p.col < 7 && p.col > 0(p.player == this.p1 && !p.row || p.player == this.p2 && p.row == 7);\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n\nBoard.prototype.get_player = function (pi) {\n  return this.pieces[pi].player;\n};\n\nBoard.prototype.is_leap = function (p, row_incr, col_incr, is_phase, cell_adj) {\n  //if neighbor cell is a phase, leap_cell clear, and (enemy piece on phase_adj XOR enemy piece on phase_far)\n  if (is_phase && !this.board[7 - p.row][7 - p.col]) {\n    let phase_adj = cell_adj;\n    let phase_far = this.board[7 - (p.row + row_incr)][7 - (p.col + col_incr)];\n\n    if ((phase_adj || phase_far) && !(phase_adj && phase_far)) {\n      //xor filter. Only one may be true\n      let capt = phase_adj ? phase_adj : phase_far;\n      return {\n        row: 7 - p.row,\n        col: 7 - p.col,\n        captured_pi: capt\n      };\n    }\n  }\n};\n\nBoard.prototype.is_jump = function (p, row_incr, col_incr, cell_adj) {\n  //if adj cell occupied, jump_cell in bounds, jump_cell clear, and jump_cell has enemy piece\n  if (in_bounds(p.row + row_incr * 2, p.col + col_incr * 2)) {\n    if (this.get_player(cell_adj) != p.player && !this.board[p.row + row_incr * 2][p.col + col_incr * 2]) {\n      return {\n        row: p.row + row_incr * 2,\n        col: p.col + col_incr * 2,\n        captured_pi: cell_adj\n      };\n    }\n  }\n};\n\nBoard.prototype.is_phase = function (p) {\n  let is_phase = cell_type(p.row, p.col) > 1;\n  if (is_phase && !this.board[7 - p.row][7 - p.col]) return {\n    row: 7 - p.row,\n    col: 7 - p.col\n  };\n};\n\nBoard.prototype.is_clone_spawn = function (pi, row, col) {\n  if (this.can_clone(pi)) return this.board[row][col] === null;\n};\n\nBoard.prototype.get_clone_spawns = function (p) {\n  let row = p.player == this.p1 ? 0 : 7;\n  let clone_spawns = [];\n\n  for (let col = 1; col < 7; col++) {\n    if (this.board[row][col] === null) clone_spawns.push({\n      row: row,\n      col: col\n    });\n  }\n\n  return clone_spawns;\n};\n\nBoard.prototype.get_moves = function (pi) {\n  let adjs = [],\n      jumps = [],\n      leaps = [];\n  let p = this.pieces[pi]; //TODO: ref this.board[p.row + r][p.col + r].who, and set highlight = true for every destination\n\n  let phase, jump, leap;\n\n  for (let r = -1; r < 2; r++) {\n    for (let c = -1; c < 2; c++) {\n      //check adjacent cells of piece p wrt the boundary\n      if (in_bounds(p.row + r, p.col + c) && (r || c)) {\n        let cell_adj = this.board[p.row + r][p.col + r];\n        let is_phase = cell_type(p.row + r, p.col + c) > 1;\n        leap = this.is_leap(p, r, c);\n        if (cell_adj) jump = this.is_jump(p, r, c);else adjs.push({\n          row: p.row + r,\n          col: p.col + c\n        }); //adjacent moves\n\n        if (leap !== undefined) leaps.push(leap);\n        if (jump !== undefined) jumps.push(jump);\n      }\n    }\n  } //add key clone_spawns if piece can be cloned\n\n\n  let piece_moves = {\n    phase: this.is_phase(p),\n    adjs: adjs,\n    jumps: jumps,\n    leaps: leaps\n  };\n\n  if (this.can_clone(pi)) {\n    let clone_spawns = this.get_clone_spawns(p);\n    if (clone_spawns.length) piece_moves.clone_spawns = clone_spawns; //Check if spawn row has at least one empty cell\n  }\n\n  return piece_moves;\n}; //Performs move. returns true if captured piece in process, else false\n\n\nBoard.prototype.do_move = function (pi, row, col) {\n  let p = this.pieces[pi]; //If piece (is on super cell) can phase, extend player turn to allow option\n  //if (this.is_phase(p))\n\n  this.board[p.row][p.col] = null;\n  this.board[row][col] = pi;\n  p.row = row;\n  p.col = col; //if piece p contains captured piece\n\n  let c = p.captured_pi !== undefined ? this.pieces[p.captured_pi] : null;\n\n  if (c) {\n    c.alive = false;\n    this.board[c.row][c.col] = null; //return direction of move\n\n    return {\n      row_incr: Math.sign(p.row - c.row),\n      col_incr: Math.sign(p.col - c.col)\n    };\n  }\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tINTEGRITY\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n\nBoard.prototype.can_continue_move = function (pi) {\n  let moves = this.get_moves(pi); //TODO: Only check moves in the same direction as the initial move\n\n  moves.adjs = []; //return !parseInt(Object.values(a).reduce( (j,i) => i.length !== undefined ? i.length + j: j));\n\n  return !moves.every(t => t == [] || t == {} || t == null);\n};\n\nBoard.prototype.has_moves = function (pi) {\n  let moves = this.get_moves(pi); //return !parseInt(Object.values(a).reduce( (j,i) => i.length !== undefined ? i.length + j: j));\n\n  return !moves.every(t => t == [] || t == {} || t == null);\n}; //Player has no more moves when (1): all player's pieces are dead (2): every piece has no moves\n\n\nBoard.prototype.moves_left = function (player) {\n  for (let pi = 0; pi < this.pieces.length; pi++) {\n    let p = this.pieces[pi];\n\n    if (p.alive && p.player == player) {\n      if (this.has_moves(pi)) return true;\n    }\n  }\n\n  return false;\n};\n\nBoard.prototype.valid_move = function (pi, row, col) {\n  let m = this.get_moves(pi); //** this.board[row][col].highlight\n\n  let moves = [];\n  moves = moves.concat(m.phase, m.adjs, m.jumps, m.leaps);\n\n  for (let type in moves) {\n    for (let move of type) {\n      if (move.row == row && move.col == col) return true;\n    }\n  }\n\n  return false;\n};\n\nmodule.exports = Board;","map":{"version":3,"sources":["/Users/bacchus/git/Leap/src/js/board.js"],"names":["cell_type","row","col","type","in_bounds","Board","size","p1","p2","board","init_board","pieces_separator","pieces","init_pieces","prototype","update_board","map","cell","j","alive","b","i","push","Array","fill","white_pieces","black_pieces","player","cloned","concat","insert_at_separation_index","pi","length","make_clone","clone","splice","can_clone","p","get_player","is_leap","row_incr","col_incr","is_phase","cell_adj","phase_adj","phase_far","capt","captured_pi","is_jump","is_clone_spawn","get_clone_spawns","clone_spawns","get_moves","adjs","jumps","leaps","phase","jump","leap","r","c","undefined","piece_moves","do_move","Math","sign","can_continue_move","moves","every","t","has_moves","moves_left","valid_move","m","move","module","exports"],"mappings":"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","sourcesContent":["//single, phase, jump, super-jump\n/*\nadj: adjacent\nphase: change portal side\nleap: capture piece while jumping through a portal\njitch: jump, then phase\nswump: switch, then jump\n}\n*/\n/*\nLEGEND\npi = piece index in Board.pieces\np = piece Board.pieces[pi]\n*/\n\n/*\nPreviously, I assumed that if a uncloned piece reaches the end of the other player's side,\nthen that piece must duplicate before continuing the game. However, my assumption fails\nif the player's spawn row is full and hence I will give the player the option to choose.\n\nThis realization got me thinking about adding different game modes that\nmodify things like the board size, and side-wrapping.\n\nboard size: If board were 9x9, we can put a clone phaser in the center\nthat duplicates any non-clone pieces at most once.\n\nside wrapping: columns are cyclic: make board[row] = cyclic linked List?\n\n\n\nSpeaking of linked lists... Why am I not using them now?\nMaybe this is what I needed to store highlight;\n represent each of this.state.selected_piece's moves as a boolean for 'highlight' in\n this.board[row][col] = {who: p.player | null, highlight: true | false :: added in Board.get_moves(pi)}\n for some row,col,  and p = this.piece[pi]\n to Leap.set_piece(), add this.state.board.update_board()\n\n*/\n\nfunction cell_type (row, col) {\n\tlet type;\n\tswitch (true) {\n\t\tcase (row == 1 && col == 2) || (row == 6 && col == 5):\n\t\t\ttype = 2;\n\t\t\tbreak;\n\t\tcase (row == 3 && col == 2) || (row == 4 && col == 5):\n\t\t\ttype = 3;\n\t\t\tbreak;\n\t\tcase (row == 4 && col == 2) || (row == 3 && col == 5):\n\t\t\ttype = 4;\n\t\t\tbreak;\n\t\tcase (row == 5 && col == 3) || (row == 2 && col == 4):\n\t\t\ttype = 5;\n\t\t\tbreak;\n\t\tcase (row == 5 && col == 4) || (row == 2 && col == 3):\n\t\t\ttype = 6;\n\t\t\tbreak;\n\t\tcase (row == 6 && col == 2) || (row == 1 && col == 5):\n\t\t\ttype = 7;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = (row + col) % 2 == 0 ? 0 : 1;\n\t\t\tbreak;\n\t}\n\treturn type;\n}\n\nfunction in_bounds (row, col) {\n\treturn ((row > -1 || row < 8) && (col > -1 || col < 8));\n}\n\n\n\n\nfunction Board(size, p1, p2) {\n\tthis.board = this.init_board(size);\n\tthis.p1 = p1;\n\tthis.p2 = p2;\n\tthis.pieces_separator = 8;\n\tthis.pieces = this.init_pieces(size, p1, p2);\n}\n\n\n\n\n\n//TODO:\n//this.board[row][col] = {who: p.player | null, highlight: {row: some_row, col: some_col} | null:: added in Board.get_moves(pi)}\n//update occurs when (1) piece is cloned (pieces index may change)\n// and when (2) set_piece is called\n//To make highlight function properly, I'll have to call this.get_moves() from here.\n//It follows that I will have to remove other calls to this.get_moves()\nBoard.prototype.update_board = function () {\n\tthis.board.map(row => row.map((cell, j) =>\n\t\tcell !== null ? (this.pieces[cell].alive ? this.pieces[cell] : null) : null ));\n}\n\nBoard.prototype.init_board = function (size) {\n    let b = [];\n    for (let i = 0; i < size; i++) b.push(Array(size).fill(null));\n    return b;\n}\n\nBoard.prototype.init_pieces = function (size) {\n\tlet white_pieces = [];\n\tlet black_pieces = [];\n\tfor (let i = 0; i < size; i++) {\n\t\twhite_pieces.push({player: this.p1, cloned: false, row: 7, col: 1, alive: true});\n\t\tblack_pieces.push({player: this.p2, cloned: false, row: 0, col: 1, alive: true});\n\t}\n\t\tthis.update_board(); //add pieces to board\n    return white_pieces.concat(black_pieces);\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n//Calls every time a clone is made\nBoard.prototype.insert_at_separation_index = function () {\n\tfor(let pi=this.pieces_separator; pi<this.pieces.length; pi++) {\n\t\t//Finds index that separates p1 and p2 pieces\n\t\tif(this.pieces[pi].player != this.p1) {\n\t\t\tthis.pieces_separator = pi; //update\n\t\t\treturn pi;\n\t\t}\n\t}\n}\n\nBoard.prototype.make_clone = function (pi, row, col) {\n\tthis.pieces[pi].cloned = true;\n\t//row will only be 0 or 7, so we can use this to determine player and placement\n\tlet player = row ? this.p1 : this.p2;\n\tlet clone = {player: player, cloned: true, row: row, col: col, alive: true};\n\treturn this.pieces.splice(this.insert_at_separation_index(),0, clone);\n}\n\nBoard.prototype.can_clone = function (pi) {\n\tlet p = this.pieces[pi];\n\treturn (!p.cloned && p.col < 7 && p.col > 0 ( (p.player == this.p1 && !p.row) || (p.player == this.p2 && p.row == 7) ));\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\nBoard.prototype.get_player = function (pi) {\n\treturn this.pieces[pi].player;\n}\n\nBoard.prototype.is_leap = function (p, row_incr, col_incr, is_phase, cell_adj) {\n\t//if neighbor cell is a phase, leap_cell clear, and (enemy piece on phase_adj XOR enemy piece on phase_far)\n\tif(is_phase && !this.board[7 - p.row][7 - p.col]) {\n\t\tlet phase_adj = cell_adj;\n\t\tlet phase_far = this.board[7 - (p.row + row_incr)][7 - (p.col + col_incr)];\n\t\tif((phase_adj || phase_far) && !(phase_adj && phase_far)) { //xor filter. Only one may be true\n\t\t\tlet capt = phase_adj ? phase_adj : phase_far;\n\t\t\treturn {row: 7 - p.row, col: 7 - p.col, captured_pi: capt};\n\t\t}\n\t}\n}\n\nBoard.prototype.is_jump = function (p, row_incr, col_incr, cell_adj) {\n\t//if adj cell occupied, jump_cell in bounds, jump_cell clear, and jump_cell has enemy piece\n\tif(in_bounds(p.row + row_incr*2, p.col + col_incr*2)) {\n\t\tif (this.get_player(cell_adj) != p.player && !this.board[p.row + row_incr*2][p.col + col_incr*2]) {\n\t\t\t\treturn {row: p.row + row_incr*2, col: p.col + col_incr*2, captured_pi: cell_adj};\n\t\t}\n\t}\n}\n\nBoard.prototype.is_phase = function (p) {\n\tlet is_phase = cell_type(p.row, p.col) > 1;\n\tif(is_phase && !this.board[7 - p.row][7 - p.col]) return {row: 7 - p.row, col: 7 - p.col};\n}\n\nBoard.prototype.is_clone_spawn = function (pi, row, col) {\n\tif (this.can_clone(pi)) return (this.board[row][col] === null);\n}\n\nBoard.prototype.get_clone_spawns = function (p) {\n\tlet row = p.player == this.p1 ? 0 : 7;\n\n\tlet clone_spawns = [];\n\tfor(let col=1; col<7;col++) {\n\t\tif (this.board[row][col] === null) clone_spawns.push({row: row, col: col});\n\t}\n\treturn clone_spawns;\n}\n\nBoard.prototype.get_moves = function (pi) {\n\tlet adjs = [], jumps = [], leaps = [];\n\tlet p = this.pieces[pi];\n\n\n\t//TODO: ref this.board[p.row + r][p.col + r].who, and set highlight = true for every destination\n\n\tlet phase, jump, leap;\n\tfor(let r=-1;r<2;r++) {\n\t\tfor(let c=-1;c<2; c++) {\n\t\t\t//check adjacent cells of piece p wrt the boundary\n\t\t\tif(in_bounds(p.row + r, p.col + c) && (r || c)) {\n\t\t\t\tlet cell_adj = this.board[p.row + r][p.col + r];\n\t\t\t\tlet is_phase = cell_type(p.row + r, p.col + c) > 1;\n\n\t\t\t\tleap = this.is_leap(p, r, c);\n\t\t\t\tif(cell_adj) jump = this.is_jump(p, r, c);\n\t\t\t\telse adjs.push({row: p.row + r, col: p.col + c});\t//adjacent moves\n\n\t\t\t\tif (leap !== undefined) leaps.push(leap);\n\t\t\t\tif (jump !== undefined) jumps.push(jump);\n\t\t\t}\n\t\t}\n\t}\n\n\t//add key clone_spawns if piece can be cloned\n\tlet piece_moves = {phase: this.is_phase(p), adjs: adjs, jumps: jumps, leaps: leaps};\n\tif (this.can_clone(pi)) {\n\t\tlet clone_spawns = this.get_clone_spawns(p);\n\t\tif (clone_spawns.length) piece_moves.clone_spawns = clone_spawns; //Check if spawn row has at least one empty cell\n\t}\n\treturn piece_moves;\n}\n\n//Performs move. returns true if captured piece in process, else false\nBoard.prototype.do_move = function (pi, row, col) {\n\tlet p = this.pieces[pi];\n\t//If piece (is on super cell) can phase, extend player turn to allow option\n\t//if (this.is_phase(p))\n\tthis.board[p.row][p.col] = null;\n\tthis.board[row][col] = pi;\n\tp.row = row;\n\tp.col = col;\n\n\t//if piece p contains captured piece\n\tlet c = p.captured_pi !== undefined ? this.pieces[p.captured_pi] : null;\n\tif (c) {\n\t\tc.alive = false;\n\t\tthis.board[c.row][c.col] = null;\n\n\t\t//return direction of move\n\t\treturn {row_incr: Math.sign(p.row-c.row), col_incr: Math.sign(p.col-c.col)};\n\t}\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tINTEGRITY\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\nBoard.prototype.can_continue_move = function (pi) {\n\tlet moves = this.get_moves(pi);\n\t//TODO: Only check moves in the same direction as the initial move\n\tmoves.adjs = [];\n\t//return !parseInt(Object.values(a).reduce( (j,i) => i.length !== undefined ? i.length + j: j));\n\treturn !moves.every(t => t == [] || t == {} || t == null);\n}\n\nBoard.prototype.has_moves = function (pi) {\n\tlet moves = this.get_moves(pi);\n\t//return !parseInt(Object.values(a).reduce( (j,i) => i.length !== undefined ? i.length + j: j));\n\treturn !moves.every(t => t == [] || t == {} || t == null);\n}\n\n//Player has no more moves when (1): all player's pieces are dead (2): every piece has no moves\nBoard.prototype.moves_left = function (player) {\n\tfor(let pi=0; pi < this.pieces.length; pi++) {\n\t\tlet p = this.pieces[pi];\n\t\tif(p.alive && p.player == player) {\n\t\t\tif(this.has_moves(pi)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nBoard.prototype.valid_move = function (pi, row, col) {\n\tlet m = this.get_moves(pi); //** this.board[row][col].highlight\n\tlet moves = [];\n\tmoves = moves.concat(m.phase, m.adjs, m.jumps, m.leaps);\n\t\tfor (let type in moves) {\n\t\t\tfor (let move of type) {\n\t\t\t\tif (move.row == row && move.col == col) return true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\n\nmodule.exports = Board;\n"]},"metadata":{},"sourceType":"module"}