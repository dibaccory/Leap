{"ast":null,"code":"import { BOARD_SIZE, BOARD_AREA, BIT_SIZE, BIT_MAX_PI, BIT_INDEX_SHIFT, BIT_AREA } from './board.js';\n\nfunction Node(from, to) {\n  this.visits = 1;\n  this.score = 0;\n  this.children = null;\n  this.to = to || -1;\n  this.from = from || -1;\n} //\n// Node.prototype.opponent = function () {\n//     return this.player ^ 8;\n// }\n\n\nNode.prototype.append = function (child) {\n  if (!this.children) this.children = [child];else this.children.push(child);\n};\n\nNode.prototype.branch = function (state) {\n  state.clearMoves();\n  state.getAllMoves(state.player);\n  const shift = state.player === 12 ? BIT_MAX_PI : 0;\n\n  for (let pi = shift; pi < BIT_MAX_PI + shift; pi++) {\n    const nMoves = state.moves[pi].length;\n    const from = state.board[BOARD_AREA + pi];\n\n    for (let i = 0; i < nMoves; i++) {\n      const to = state.moves[pi][i] & BIT_AREA - 1;\n      let child = new Node(from, to);\n      this.append(child);\n    }\n  }\n};\n\nNode.prototype.playFor = function (state) {\n  return state.doMove(this.from, this.to);\n};\n\nNode.prototype.ucb = function (coeff) {\n  var score = this.score / this.visits;\n  return score + Math.sqrt(coeff / this.visits);\n};\n\nNode.prototype.findBestChild = function () {\n  var coeff = 20 * Math.log(this.visits);\n  var bestScore = -Infinity;\n  var bestChild = null;\n\n  for (var i = 0; i < this.children.length; i++) {\n    var child = this.children[i];\n    var score = child.ucb(coeff);\n\n    if (score > bestScore) {\n      bestScore = score;\n      bestChild = child;\n    }\n  }\n\n  return bestChild;\n};\n\nexport function UCT(startState, maxTime) {\n  this.root = new Node();\n  this.startState = startState;\n  this.visitThreshold = 200; // Populate the first node.\n\n  this.root.branch(startState);\n  this.history = [this.root];\n  var totalPlayouts = 0;\n  var start = Date.now();\n  var elapsedTime;\n\n  while (elapsedTime < maxTime) {\n    for (var i = 0; i < 500; i++) this.run();\n\n    totalPlayouts += 500;\n    elapsedTime = Date.now() - start;\n  }\n\n  var bestChild = null;\n  var bestScore = -Infinity;\n\n  for (var i = 0; i < this.root.children.length; i++) {\n    var child = this.root.children[i];\n\n    if (child.visits > bestScore) {\n      bestChild = child;\n      bestScore = child.visits;\n    }\n  }\n\n  return {\n    elapsed: elapsedTime,\n    playouts: totalPlayouts,\n    from: bestChild.from,\n    to: bestChild.to\n  };\n}\n\nUCT.prototype.playout = function (state) {\n  var nmoves = 0;\n\n  while (++nmoves < 60) {\n    var result = state.moveRandom(); //returns if won\n\n    if (result) return result;\n  }\n\n  return state.score();\n};\n\nUCT.protoype.run = function () {\n  const state = this.startState.copy();\n  const node = this.root;\n  let depth = 1;\n  let winner = 0;\n\n  while (true) {\n    if (node.children === null) {\n      if (node.visits >= this.visitThreshold) {\n        node.branch(state); // Leaf node - go directly to update.\n\n        if (node.children === null) {\n          winner = node.opponent();\n          this.history[depth++] = node;\n          break;\n        }\n\n        continue;\n      }\n\n      winner = this.playout(state);\n      break;\n    }\n\n    node = node.findBestChild();\n    this.history[depth++] = node;\n\n    if (node.playFor(state)) {\n      winner = state.player;\n      break;\n    }\n  }\n\n  for (var i = 0; i < depth; i++) {\n    node = this.history[i];\n    node.visits++;\n    if (winner == node.player) node.score += 1;else if (winner != 0) node.score -= 1;\n  }\n};","map":{"version":3,"sources":["/Users/bacchus/git/Leap/src/js/ai.js"],"names":["BOARD_SIZE","BOARD_AREA","BIT_SIZE","BIT_MAX_PI","BIT_INDEX_SHIFT","BIT_AREA","Node","from","to","visits","score","children","prototype","append","child","push","branch","state","clearMoves","getAllMoves","player","shift","pi","nMoves","moves","length","board","i","playFor","doMove","ucb","coeff","Math","sqrt","findBestChild","log","bestScore","Infinity","bestChild","UCT","startState","maxTime","root","visitThreshold","history","totalPlayouts","start","Date","now","elapsedTime","run","elapsed","playouts","playout","nmoves","result","moveRandom","protoype","copy","node","depth","winner","opponent"],"mappings":"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","sourcesContent":["import {BOARD_SIZE, BOARD_AREA, BIT_SIZE, BIT_MAX_PI, BIT_INDEX_SHIFT, BIT_AREA} from './board.js';\n\nfunction Node(from, to) {\n    this.visits = 1;\n    this.score = 0;\n    this.children = null;\n    this.to = to || -1;\n    this.from = from || -1;\n}\n//\n// Node.prototype.opponent = function () {\n//     return this.player ^ 8;\n// }\n\nNode.prototype.append = function (child) {\n    if (!this.children) this.children = [child];\n    else this.children.push(child);\n}\n\nNode.prototype.branch = function (state) {\n    state.clearMoves();\n    state.getAllMoves(state.player);\n\n    const shift = (state.player === 12) ? BIT_MAX_PI : 0;\n    for (let pi = shift; pi < BIT_MAX_PI + shift; pi++) {\n      const nMoves = state.moves[pi].length;\n      const from = state.board[BOARD_AREA + pi];\n\n      for (let i = 0; i < nMoves; i++) {\n        const to = ( state.moves[pi][i] & (BIT_AREA - 1) );\n        let child = new Node(from, to);\n        this.append(child);\n      }\n  }\n}\n\nNode.prototype.playFor = function (state) {\n    return state.doMove(this.from, this.to);\n}\n\nNode.prototype.ucb = function (coeff) {\n    var score = (this.score / this.visits);\n    return score + Math.sqrt(coeff / this.visits);\n}\n\nNode.prototype.findBestChild = function () {\n    var coeff = 20 * Math.log(this.visits);\n    var bestScore = -Infinity;\n    var bestChild = null;\n    for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        var score = child.ucb(coeff);\n        if (score > bestScore) {\n            bestScore = score;\n            bestChild = child;\n        }\n    }\n    return bestChild;\n}\n\n\n\n\n\nexport function UCT(startState, maxTime) {\n  this.root = new Node();\n  this.startState = startState;\n  this.visitThreshold = 200;\n\n  // Populate the first node.\n  this.root.branch(startState);\n  this.history = [this.root];\n\n  var totalPlayouts = 0;\n  var start = Date.now();\n  var elapsedTime;\n  while (elapsedTime < maxTime) {\n      for (var i = 0; i < 500; i++) this.run();\n      totalPlayouts += 500;\n      elapsedTime = Date.now() - start;\n  }\n\n  var bestChild = null;\n  var bestScore = -Infinity;\n  for (var i = 0; i < this.root.children.length; i++) {\n      var child = this.root.children[i];\n      if (child.visits > bestScore) {\n          bestChild = child;\n          bestScore = child.visits;\n      }\n  }\n\n  return {\n    elapsed: elapsedTime,\n    playouts: totalPlayouts,\n    from: bestChild.from,\n    to: bestChild.to\n  };\n}\n\nUCT.prototype.playout = function (state) {\n    var nmoves = 0;\n\n    while (++nmoves < 60) {\n        var result = state.moveRandom(); //returns if won\n        if (result) return result;\n    }\n    return state.score();\n}\n\nUCT.protoype.run = function () {\n    const state = this.startState.copy();\n    const node = this.root;\n    let depth = 1;\n    let winner = 0;\n\n    while (true) {\n        if (node.children === null) {\n            if (node.visits >= this.visitThreshold) {\n                node.branch(state);\n\n                // Leaf node - go directly to update.\n                if (node.children === null) {\n                    winner = node.opponent();\n                    this.history[depth++] = node;\n                    break;\n                }\n                continue;\n            }\n            winner = this.playout(state);\n            break;\n        }\n        node = node.findBestChild();\n        this.history[depth++] = node;\n        if (node.playFor(state)) {\n            winner = state.player;\n            break;\n        }\n    }\n\n    for (var i = 0; i < depth; i++) {\n        node = this.history[i];\n        node.visits++;\n        if (winner == node.player)\n            node.score += 1;\n        else if (winner != 0)\n            node.score -= 1;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}