{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar spec_1 = require(\"./spec\");\n\nvar encode = require(\"./encoding/encode\");\n\nvar decode = require(\"./encoding/decode\");\n\nvar ArraySchema_1 = require(\"./types/ArraySchema\");\n\nvar MapSchema_1 = require(\"./types/MapSchema\");\n\nvar ChangeTree_1 = require(\"./ChangeTree\");\n\nvar EventEmitter_1 = require(\"./events/EventEmitter\");\n\nvar EncodeSchemaError =\n/** @class */\nfunction (_super) {\n  __extends(EncodeSchemaError, _super);\n\n  function EncodeSchemaError() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return EncodeSchemaError;\n}(Error);\n\nfunction assertType(value, type, klass, field) {\n  var typeofTarget;\n  var allowNull = false;\n\n  switch (type) {\n    case \"number\":\n    case \"int8\":\n    case \"uint8\":\n    case \"int16\":\n    case \"uint16\":\n    case \"int32\":\n    case \"uint32\":\n    case \"int64\":\n    case \"uint64\":\n    case \"float32\":\n    case \"float64\":\n      typeofTarget = \"number\";\n\n      if (isNaN(value)) {\n        console.log(\"trying to encode \\\"NaN\\\" in \" + klass.constructor.name + \"#\" + field);\n      }\n\n      break;\n\n    case \"string\":\n      typeofTarget = \"string\";\n      allowNull = true;\n      break;\n\n    case \"boolean\":\n      // boolean is always encoded as true/false based on truthiness\n      return;\n  }\n\n  if (typeof value !== typeofTarget && (!allowNull || allowNull && value !== null)) {\n    var foundValue = \"'\" + JSON.stringify(value) + \"'\" + (value && value.constructor && \" (\" + value.constructor.name + \")\");\n    throw new EncodeSchemaError(\"a '\" + typeofTarget + \"' was expected, but \" + foundValue + \" was provided in \" + klass.constructor.name + \"#\" + field);\n  }\n}\n\nfunction assertInstanceType(value, type, klass, field) {\n  if (!(value instanceof type)) {\n    throw new EncodeSchemaError(\"a '\" + type.name + \"' was expected, but '\" + value.constructor.name + \"' was provided in \" + klass.constructor.name + \"#\" + field);\n  }\n}\n\nfunction encodePrimitiveType(type, bytes, value, klass, field) {\n  assertType(value, type, klass, field);\n  var encodeFunc = encode[type];\n\n  if (encodeFunc) {\n    encodeFunc(bytes, value);\n  } else {\n    throw new EncodeSchemaError(\"a '\" + type + \"' was expected, but \" + value + \" was provided in \" + klass.constructor.name + \"#\" + field);\n  }\n}\n\nfunction decodePrimitiveType(type, bytes, it) {\n  return decode[type](bytes, it);\n}\n/**\n * Schema encoder / decoder\n */\n\n\nvar Schema =\n/** @class */\nfunction () {\n  // allow inherited classes to have a constructor\n  function Schema() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    } // fix enumerability of fields for end-user\n\n\n    Object.defineProperties(this, {\n      $changes: {\n        value: new ChangeTree_1.ChangeTree(this._indexes),\n        enumerable: false,\n        writable: true\n      },\n      $listeners: {\n        value: {},\n        enumerable: false,\n        writable: true\n      }\n    });\n    var descriptors = this._descriptors;\n\n    if (descriptors) {\n      Object.defineProperties(this, descriptors);\n    }\n  }\n\n  Schema.onError = function (e) {\n    console.error(e);\n  };\n\n  Object.defineProperty(Schema.prototype, \"_schema\", {\n    get: function () {\n      return this.constructor._schema;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Schema.prototype, \"_descriptors\", {\n    get: function () {\n      return this.constructor._descriptors;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Schema.prototype, \"_indexes\", {\n    get: function () {\n      return this.constructor._indexes;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Schema.prototype, \"_fieldsByIndex\", {\n    get: function () {\n      return this.constructor._fieldsByIndex;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Schema.prototype, \"_filters\", {\n    get: function () {\n      return this.constructor._filters;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Schema.prototype, \"_deprecated\", {\n    get: function () {\n      return this.constructor._deprecated;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Schema.prototype, \"$changed\", {\n    get: function () {\n      return this.$changes.changed;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Schema.prototype.listen = function (attr, callback) {\n    if (!this.$listeners[attr]) {\n      this.$listeners[attr] = new EventEmitter_1.EventEmitter();\n    }\n\n    this.$listeners[attr].register(callback);\n  };\n\n  Schema.prototype.decode = function (bytes, it) {\n    if (it === void 0) {\n      it = {\n        offset: 0\n      };\n    }\n\n    var changes = [];\n    var schema = this._schema;\n    var fieldsByIndex = this._fieldsByIndex;\n    var totalBytes = bytes.length; // skip TYPE_ID of existing instances\n\n    if (bytes[it.offset] === spec_1.TYPE_ID) {\n      it.offset += 2;\n    }\n\n    var _loop_1 = function () {\n      var isNil = decode.nilCheck(bytes, it) && ++it.offset;\n      var index = bytes[it.offset++];\n\n      if (index === spec_1.END_OF_STRUCTURE) {\n        return \"break\";\n      }\n\n      var field = fieldsByIndex[index];\n\n      var _field = \"_\" + field;\n\n      var type = schema[field];\n      var value = void 0;\n      var change = void 0; // for triggering onChange\n\n      var hasChange = false;\n\n      if (!field) {\n        return \"continue\";\n      } else if (isNil) {\n        value = null;\n        hasChange = true;\n      } else if (type._schema) {\n        value = this_1[_field] || this_1.createTypeInstance(bytes, it, type);\n        value.decode(bytes, it);\n        hasChange = true;\n      } else if (Array.isArray(type)) {\n        type = type[0];\n        change = [];\n        var valueRef_1 = this_1[_field] || new ArraySchema_1.ArraySchema();\n        value = valueRef_1.clone(true);\n        var newLength_1 = decode.number(bytes, it);\n        var numChanges = Math.min(decode.number(bytes, it), newLength_1);\n        hasChange = numChanges > 0; // FIXME: this may not be reliable. possibly need to encode this variable during serialization\n\n        var hasIndexChange = false; // ensure current array has the same length as encoded one\n\n        if (value.length > newLength_1) {\n          // decrease removed items from number of changes.\n          // no need to iterate through them, as they're going to be removed.\n          Array.prototype.splice.call(value, newLength_1).forEach(function (itemRemoved, i) {\n            if (itemRemoved && itemRemoved.onRemove) {\n              try {\n                itemRemoved.onRemove();\n              } catch (e) {\n                Schema.onError(e);\n              }\n            }\n\n            if (valueRef_1.onRemove) {\n              try {\n                valueRef_1.onRemove(itemRemoved, newLength_1 + i);\n              } catch (e) {\n                Schema.onError(e);\n              }\n            }\n          });\n        }\n\n        for (var i = 0; i < numChanges; i++) {\n          var newIndex = decode.number(bytes, it);\n          var indexChangedFrom = void 0; // index change check\n\n          if (decode.indexChangeCheck(bytes, it)) {\n            decode.uint8(bytes, it);\n            indexChangedFrom = decode.number(bytes, it);\n            hasIndexChange = true;\n          }\n\n          var isNew = !hasIndexChange && value[newIndex] === undefined || hasIndexChange && indexChangedFrom === undefined;\n\n          if (type.prototype instanceof Schema) {\n            var item = void 0;\n\n            if (isNew) {\n              item = this_1.createTypeInstance(bytes, it, type);\n            } else if (indexChangedFrom !== undefined) {\n              item = valueRef_1[indexChangedFrom];\n            } else {\n              item = valueRef_1[newIndex];\n            }\n\n            if (!item) {\n              item = this_1.createTypeInstance(bytes, it, type);\n              isNew = true;\n            }\n\n            item.decode(bytes, it);\n            value[newIndex] = item;\n          } else {\n            value[newIndex] = decodePrimitiveType(type, bytes, it);\n          }\n\n          if (isNew) {\n            if (valueRef_1.onAdd) {\n              try {\n                valueRef_1.onAdd(value[newIndex], newIndex);\n              } catch (e) {\n                Schema.onError(e);\n              }\n            }\n          } else if (valueRef_1.onChange) {\n            try {\n              valueRef_1.onChange(value[newIndex], newIndex);\n            } catch (e) {\n              Schema.onError(e);\n            }\n          }\n\n          change.push(value[newIndex]);\n        }\n      } else if (type.map) {\n        type = type.map;\n        var valueRef = this_1[_field] || new MapSchema_1.MapSchema();\n        value = valueRef.clone(true);\n        var length = decode.number(bytes, it);\n        hasChange = length > 0; // FIXME: this may not be reliable. possibly need to encode this variable during\n        // serializagion\n\n        var hasIndexChange = false;\n        var previousKeys = Object.keys(valueRef);\n\n        for (var i = 0; i < length; i++) {\n          // `encodeAll` may indicate a higher number of indexes it actually encodes\n          // TODO: do not encode a higher number than actual encoded entries\n          if (bytes[it.offset] === undefined || bytes[it.offset] === spec_1.END_OF_STRUCTURE) {\n            break;\n          }\n\n          var isNilItem = decode.nilCheck(bytes, it) && ++it.offset; // index change check\n\n          var previousKey = void 0;\n\n          if (decode.indexChangeCheck(bytes, it)) {\n            decode.uint8(bytes, it);\n            previousKey = previousKeys[decode.number(bytes, it)];\n            hasIndexChange = true;\n          }\n\n          var hasMapIndex = decode.numberCheck(bytes, it);\n          var isSchemaType = typeof type !== \"string\";\n          var newKey = hasMapIndex ? previousKeys[decode.number(bytes, it)] : decode.string(bytes, it);\n          var item = void 0;\n          var isNew = !hasIndexChange && valueRef[newKey] === undefined || hasIndexChange && previousKey === undefined && hasMapIndex;\n\n          if (isNew && isSchemaType) {\n            item = this_1.createTypeInstance(bytes, it, type);\n          } else if (previousKey !== undefined) {\n            item = valueRef[previousKey];\n          } else {\n            item = valueRef[newKey];\n          }\n\n          if (isNilItem) {\n            if (item && item.onRemove) {\n              try {\n                item.onRemove();\n              } catch (e) {\n                Schema.onError(e);\n              }\n            }\n\n            if (valueRef.onRemove) {\n              try {\n                valueRef.onRemove(item, newKey);\n              } catch (e) {\n                Schema.onError(e);\n              }\n            }\n\n            delete value[newKey];\n            continue;\n          } else if (!isSchemaType) {\n            value[newKey] = decodePrimitiveType(type, bytes, it);\n          } else {\n            item.decode(bytes, it);\n            value[newKey] = item;\n          }\n\n          if (isNew) {\n            if (valueRef.onAdd) {\n              try {\n                valueRef.onAdd(value[newKey], newKey);\n              } catch (e) {\n                Schema.onError(e);\n              }\n            }\n          } else if (valueRef.onChange) {\n            try {\n              valueRef.onChange(value[newKey], newKey);\n            } catch (e) {\n              Schema.onError(e);\n            }\n          }\n        }\n      } else {\n        value = decodePrimitiveType(type, bytes, it); // FIXME: should not even have encoded if value haven't changed in the first place!\n        // check FilterTest.ts: \"should not trigger `onChange` if field haven't changed\"\n\n        hasChange = value !== this_1[_field];\n      }\n\n      if (hasChange && (this_1.onChange || this_1.$listeners[field])) {\n        changes.push({\n          field: field,\n          value: change || value,\n          previousValue: this_1[_field]\n        });\n      }\n\n      this_1[_field] = value;\n    };\n\n    var this_1 = this;\n\n    while (it.offset < totalBytes) {\n      var state_1 = _loop_1();\n\n      if (state_1 === \"break\") break;\n    }\n\n    this._triggerChanges(changes);\n\n    return this;\n  };\n\n  Schema.prototype.encode = function (root, encodeAll, client, bytes) {\n    var _this = this;\n\n    if (root === void 0) {\n      root = this;\n    }\n\n    if (encodeAll === void 0) {\n      encodeAll = false;\n    }\n\n    if (bytes === void 0) {\n      bytes = [];\n    } // skip if nothing has changed\n\n\n    if (!this.$changes.changed && !encodeAll) {\n      this._encodeEndOfStructure(this, root, bytes);\n\n      return bytes;\n    }\n\n    var schema = this._schema;\n    var indexes = this._indexes;\n    var fieldsByIndex = this._fieldsByIndex;\n    var filters = this._filters;\n    var changes = Array.from(encodeAll || client ? this.$changes.allChanges : this.$changes.changes).sort();\n\n    var _loop_2 = function (i, l) {\n      var field = fieldsByIndex[changes[i]] || changes[i];\n\n      var _field = \"_\" + field;\n\n      var type = schema[field];\n      var filter = filters && filters[field]; // const value = (filter && this.$allChanges[field]) || changes[field];\n\n      var value = this_2[_field];\n      var fieldIndex = indexes[field];\n\n      if (value === undefined) {\n        encode.uint8(bytes, spec_1.NIL);\n        encode.number(bytes, fieldIndex);\n      } else if (type._schema) {\n        if (client && filter) {\n          // skip if not allowed by custom filter\n          if (!filter.call(this_2, client, value, root)) {\n            return \"continue\";\n          }\n        }\n\n        if (!value) {\n          // value has been removed\n          encode.uint8(bytes, spec_1.NIL);\n          encode.number(bytes, fieldIndex);\n        } else {\n          // encode child object\n          encode.number(bytes, fieldIndex);\n          assertInstanceType(value, type, this_2, field);\n          this_2.tryEncodeTypeId(bytes, type, value.constructor);\n          value.encode(root, encodeAll, client, bytes);\n        }\n      } else if (Array.isArray(type)) {\n        var $changes = value.$changes;\n        encode.number(bytes, fieldIndex); // total number of items in the array\n\n        encode.number(bytes, value.length);\n        var arrayChanges = Array.from(encodeAll || client ? $changes.allChanges : $changes.changes).filter(function (index) {\n          return _this[_field][index] !== undefined;\n        }).sort(function (a, b) {\n          return a - b;\n        }); // ensure number of changes doesn't exceed array length\n\n        var numChanges = arrayChanges.length; // number of changed items\n\n        encode.number(bytes, numChanges);\n        var isChildSchema = typeof type[0] !== \"string\"; // assert ArraySchema was provided\n\n        assertInstanceType(this_2[_field], ArraySchema_1.ArraySchema, this_2, field); // encode Array of type\n\n        for (var j = 0; j < numChanges; j++) {\n          var index = arrayChanges[j];\n          var item = this_2[_field][index];\n\n          if (client && filter) {\n            // skip if not allowed by custom filter\n            if (!filter.call(this_2, client, item, root)) {\n              continue;\n            }\n          }\n\n          if (isChildSchema) {\n            // is array of Schema\n            encode.number(bytes, index);\n\n            if (!encodeAll) {\n              var indexChange = $changes.getIndexChange(item);\n\n              if (indexChange !== undefined) {\n                encode.uint8(bytes, spec_1.INDEX_CHANGE);\n                encode.number(bytes, indexChange);\n              }\n            }\n\n            assertInstanceType(item, type[0], this_2, field);\n            this_2.tryEncodeTypeId(bytes, type[0], item.constructor);\n            item.encode(root, encodeAll, client, bytes);\n          } else if (item !== undefined) {\n            // is array of primitives\n            encode.number(bytes, index);\n            encodePrimitiveType(type[0], bytes, item, this_2, field);\n          }\n        }\n\n        if (!encodeAll) {\n          $changes.discard();\n        }\n      } else if (type.map) {\n        var $changes = value.$changes; // encode Map of type\n\n        encode.number(bytes, fieldIndex); // TODO: during `encodeAll`, removed entries are not going to be encoded\n\n        var keys = Array.from(encodeAll || client ? $changes.allChanges : $changes.changes);\n        encode.number(bytes, keys.length); // const previousKeys = Object.keys(this[_field]); // this is costly!\n\n        var previousKeys = Array.from($changes.allChanges);\n        var isChildSchema = typeof type.map !== \"string\";\n        var numChanges = keys.length; // assert MapSchema was provided\n\n        assertInstanceType(this_2[_field], MapSchema_1.MapSchema, this_2, field);\n\n        for (var i_1 = 0; i_1 < numChanges; i_1++) {\n          var key = keys[i_1];\n          var item = this_2[_field][key];\n          var mapItemIndex = undefined;\n\n          if (client && filter) {\n            // skip if not allowed by custom filter\n            if (!filter.call(this_2, client, item, root)) {\n              continue;\n            }\n          }\n\n          if (encodeAll) {\n            if (item === undefined) {\n              // previously deleted items are skipped during `encodeAll`\n              continue;\n            }\n          } else {\n            // encode index change\n            var indexChange = $changes.getIndexChange(item);\n\n            if (item && indexChange !== undefined) {\n              encode.uint8(bytes, spec_1.INDEX_CHANGE);\n              encode.number(bytes, this_2[_field]._indexes.get(indexChange));\n            }\n            /**\n             * - Allow item replacement\n             * - Allow to use the index of a deleted item to encode as NIL\n             */\n\n\n            mapItemIndex = !$changes.isDeleted(key) || !item ? this_2[_field]._indexes.get(key) : undefined;\n          }\n\n          var isNil = item === undefined;\n          /**\n           * Invert NIL to prevent collision with data starting with NIL byte\n           */\n\n          if (isNil) {\n            // TODO: remove item\n            // console.log(\"REMOVE KEY INDEX\", { key });\n            // this[_field]._indexes.delete(key);\n            encode.uint8(bytes, spec_1.NIL);\n          }\n\n          if (mapItemIndex !== undefined) {\n            encode.number(bytes, mapItemIndex);\n          } else {\n            encode.string(bytes, key);\n          }\n\n          if (item && isChildSchema) {\n            assertInstanceType(item, type.map, this_2, field);\n            this_2.tryEncodeTypeId(bytes, type.map, item.constructor);\n            item.encode(root, encodeAll, client, bytes);\n          } else if (!isNil) {\n            encodePrimitiveType(type.map, bytes, item, this_2, field);\n          }\n        }\n\n        if (!encodeAll) {\n          $changes.discard(); // TODO: track array/map indexes per client (for filtering)?\n\n          if (!client) {\n            // TODO: do not iterate though all MapSchema indexes here.\n            this_2[_field]._updateIndexes(previousKeys);\n          }\n        }\n      } else {\n        if (client && filter) {\n          // skip if not allowed by custom filter\n          if (!filter.call(this_2, client, value, root)) {\n            return \"continue\";\n          }\n        }\n\n        encode.number(bytes, fieldIndex);\n        encodePrimitiveType(type, bytes, value, this_2, field);\n      }\n    };\n\n    var this_2 = this;\n\n    for (var i = 0, l = changes.length; i < l; i++) {\n      _loop_2(i, l);\n    } // flag end of Schema object structure\n\n\n    this._encodeEndOfStructure(this, root, bytes);\n\n    if (!encodeAll && !client) {\n      this.$changes.discard();\n    }\n\n    return bytes;\n  };\n\n  Schema.prototype.encodeFiltered = function (client, bytes) {\n    return this.encode(this, false, client, bytes);\n  };\n\n  Schema.prototype.encodeAll = function (bytes) {\n    return this.encode(this, true, undefined, bytes);\n  };\n\n  Schema.prototype.encodeAllFiltered = function (client, bytes) {\n    return this.encode(this, true, client, bytes);\n  };\n\n  Schema.prototype.clone = function () {\n    var cloned = new this.constructor();\n    var schema = this._schema;\n\n    for (var field in schema) {\n      if (typeof this[field] === \"object\" && typeof this[field].clone === \"function\") {\n        // deep clone\n        cloned[field] = this[field].clone();\n      } else {\n        // primitive values\n        cloned[field] = this[field];\n      }\n    }\n\n    return cloned;\n  };\n\n  Schema.prototype.triggerAll = function () {\n    if (!this.onChange) {\n      return;\n    }\n\n    var changes = [];\n    var schema = this._schema;\n\n    for (var field in schema) {\n      if (this[field] !== undefined) {\n        changes.push({\n          field: field,\n          value: this[field],\n          previousValue: undefined\n        });\n      }\n    }\n\n    try {\n      this.onChange(changes);\n    } catch (e) {\n      Schema.onError(e);\n    }\n  };\n\n  Schema.prototype.toJSON = function () {\n    var schema = this._schema;\n    var deprecated = this._deprecated;\n    var obj = {};\n\n    for (var field in schema) {\n      if (!deprecated[field] && this[field] !== null && typeof this[field] !== \"undefined\") {\n        obj[field] = typeof this[field].toJSON === \"function\" ? this[field].toJSON() : this[\"_\" + field];\n      }\n    }\n\n    return obj;\n  };\n\n  Schema.prototype.discardAllChanges = function () {\n    var schema = this._schema;\n    var changes = Array.from(this.$changes.changes);\n    var fieldsByIndex = this._fieldsByIndex;\n\n    for (var index in changes) {\n      var field = fieldsByIndex[index];\n      var type = schema[field];\n      var value = this[field]; // skip unchagned fields\n\n      if (value === undefined) {\n        continue;\n      }\n\n      if (type._schema) {\n        value.discardAllChanges();\n      } else if (Array.isArray(type)) {\n        // encode Array of type\n        for (var i = 0, l = value.length; i < l; i++) {\n          var index_1 = value[i];\n          var item = this[\"_\" + field][index_1];\n\n          if (typeof type[0] !== \"string\") {\n            // is array of Schema\n            item.discardAllChanges();\n          }\n        }\n      } else if (type.map) {\n        var keys = value;\n        var mapKeys = Object.keys(this[\"_\" + field]);\n\n        for (var i = 0; i < keys.length; i++) {\n          var key = mapKeys[keys[i]] || keys[i];\n          var item = this[\"_\" + field][key];\n\n          if (item instanceof Schema) {\n            item.discardAllChanges();\n          }\n        }\n      }\n    }\n\n    this.$changes.discard();\n  };\n\n  Schema.prototype._encodeEndOfStructure = function (instance, root, bytes) {\n    if (instance !== root) {\n      bytes.push(spec_1.END_OF_STRUCTURE);\n    }\n  };\n\n  Schema.prototype.tryEncodeTypeId = function (bytes, type, targetType) {\n    if (type._typeid !== targetType._typeid) {\n      encode.uint8(bytes, spec_1.TYPE_ID);\n      encode.uint8(bytes, targetType._typeid);\n    }\n  };\n\n  Schema.prototype.createTypeInstance = function (bytes, it, type) {\n    if (bytes[it.offset] === spec_1.TYPE_ID) {\n      it.offset++;\n\n      var anotherType = this.constructor._context.get(decode.uint8(bytes, it));\n\n      return new anotherType();\n    } else {\n      return new type();\n    }\n  };\n\n  Schema.prototype._triggerChanges = function (changes) {\n    if (changes.length > 0) {\n      for (var i = 0; i < changes.length; i++) {\n        var change = changes[i];\n        var listener = this.$listeners[change.field];\n\n        if (listener) {\n          try {\n            listener.invoke(change.value, change.previousValue);\n          } catch (e) {\n            Schema.onError(e);\n          }\n        }\n      }\n\n      if (this.onChange) {\n        try {\n          this.onChange(changes);\n        } catch (e) {\n          Schema.onError(e);\n        }\n      }\n    }\n  };\n\n  return Schema;\n}();\n\nexports.Schema = Schema;","map":{"version":3,"sources":["../src/Schema.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar spec_1 = require(\"./spec\");\nvar encode = require(\"./encoding/encode\");\nvar decode = require(\"./encoding/decode\");\nvar ArraySchema_1 = require(\"./types/ArraySchema\");\nvar MapSchema_1 = require(\"./types/MapSchema\");\nvar ChangeTree_1 = require(\"./ChangeTree\");\nvar EventEmitter_1 = require(\"./events/EventEmitter\");\nvar EncodeSchemaError = /** @class */ (function (_super) {\n    __extends(EncodeSchemaError, _super);\n    function EncodeSchemaError() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return EncodeSchemaError;\n}(Error));\nfunction assertType(value, type, klass, field) {\n    var typeofTarget;\n    var allowNull = false;\n    switch (type) {\n        case \"number\":\n        case \"int8\":\n        case \"uint8\":\n        case \"int16\":\n        case \"uint16\":\n        case \"int32\":\n        case \"uint32\":\n        case \"int64\":\n        case \"uint64\":\n        case \"float32\":\n        case \"float64\":\n            typeofTarget = \"number\";\n            if (isNaN(value)) {\n                console.log(\"trying to encode \\\"NaN\\\" in \" + klass.constructor.name + \"#\" + field);\n            }\n            break;\n        case \"string\":\n            typeofTarget = \"string\";\n            allowNull = true;\n            break;\n        case \"boolean\":\n            // boolean is always encoded as true/false based on truthiness\n            return;\n    }\n    if (typeof (value) !== typeofTarget && (!allowNull || (allowNull && value !== null))) {\n        var foundValue = \"'\" + JSON.stringify(value) + \"'\" + (value && value.constructor && \" (\" + value.constructor.name + \")\");\n        throw new EncodeSchemaError(\"a '\" + typeofTarget + \"' was expected, but \" + foundValue + \" was provided in \" + klass.constructor.name + \"#\" + field);\n    }\n}\nfunction assertInstanceType(value, type, klass, field) {\n    if (!(value instanceof type)) {\n        throw new EncodeSchemaError(\"a '\" + type.name + \"' was expected, but '\" + value.constructor.name + \"' was provided in \" + klass.constructor.name + \"#\" + field);\n    }\n}\nfunction encodePrimitiveType(type, bytes, value, klass, field) {\n    assertType(value, type, klass, field);\n    var encodeFunc = encode[type];\n    if (encodeFunc) {\n        encodeFunc(bytes, value);\n    }\n    else {\n        throw new EncodeSchemaError(\"a '\" + type + \"' was expected, but \" + value + \" was provided in \" + klass.constructor.name + \"#\" + field);\n    }\n}\nfunction decodePrimitiveType(type, bytes, it) {\n    return decode[type](bytes, it);\n}\n/**\n * Schema encoder / decoder\n */\nvar Schema = /** @class */ (function () {\n    // allow inherited classes to have a constructor\n    function Schema() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // fix enumerability of fields for end-user\n        Object.defineProperties(this, {\n            $changes: {\n                value: new ChangeTree_1.ChangeTree(this._indexes),\n                enumerable: false,\n                writable: true\n            },\n            $listeners: {\n                value: {},\n                enumerable: false,\n                writable: true\n            },\n        });\n        var descriptors = this._descriptors;\n        if (descriptors) {\n            Object.defineProperties(this, descriptors);\n        }\n    }\n    Schema.onError = function (e) {\n        console.error(e);\n    };\n    Object.defineProperty(Schema.prototype, \"_schema\", {\n        get: function () { return this.constructor._schema; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Schema.prototype, \"_descriptors\", {\n        get: function () { return this.constructor._descriptors; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Schema.prototype, \"_indexes\", {\n        get: function () { return this.constructor._indexes; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Schema.prototype, \"_fieldsByIndex\", {\n        get: function () { return this.constructor._fieldsByIndex; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Schema.prototype, \"_filters\", {\n        get: function () { return this.constructor._filters; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Schema.prototype, \"_deprecated\", {\n        get: function () { return this.constructor._deprecated; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Schema.prototype, \"$changed\", {\n        get: function () { return this.$changes.changed; },\n        enumerable: true,\n        configurable: true\n    });\n    Schema.prototype.listen = function (attr, callback) {\n        if (!this.$listeners[attr]) {\n            this.$listeners[attr] = new EventEmitter_1.EventEmitter();\n        }\n        this.$listeners[attr].register(callback);\n    };\n    Schema.prototype.decode = function (bytes, it) {\n        if (it === void 0) { it = { offset: 0 }; }\n        var changes = [];\n        var schema = this._schema;\n        var fieldsByIndex = this._fieldsByIndex;\n        var totalBytes = bytes.length;\n        // skip TYPE_ID of existing instances\n        if (bytes[it.offset] === spec_1.TYPE_ID) {\n            it.offset += 2;\n        }\n        var _loop_1 = function () {\n            var isNil = decode.nilCheck(bytes, it) && ++it.offset;\n            var index = bytes[it.offset++];\n            if (index === spec_1.END_OF_STRUCTURE) {\n                return \"break\";\n            }\n            var field = fieldsByIndex[index];\n            var _field = \"_\" + field;\n            var type = schema[field];\n            var value = void 0;\n            var change = void 0; // for triggering onChange\n            var hasChange = false;\n            if (!field) {\n                return \"continue\";\n            }\n            else if (isNil) {\n                value = null;\n                hasChange = true;\n            }\n            else if (type._schema) {\n                value = this_1[_field] || this_1.createTypeInstance(bytes, it, type);\n                value.decode(bytes, it);\n                hasChange = true;\n            }\n            else if (Array.isArray(type)) {\n                type = type[0];\n                change = [];\n                var valueRef_1 = this_1[_field] || new ArraySchema_1.ArraySchema();\n                value = valueRef_1.clone(true);\n                var newLength_1 = decode.number(bytes, it);\n                var numChanges = Math.min(decode.number(bytes, it), newLength_1);\n                hasChange = (numChanges > 0);\n                // FIXME: this may not be reliable. possibly need to encode this variable during serialization\n                var hasIndexChange = false;\n                // ensure current array has the same length as encoded one\n                if (value.length > newLength_1) {\n                    // decrease removed items from number of changes.\n                    // no need to iterate through them, as they're going to be removed.\n                    Array.prototype.splice.call(value, newLength_1).forEach(function (itemRemoved, i) {\n                        if (itemRemoved && itemRemoved.onRemove) {\n                            try {\n                                itemRemoved.onRemove();\n                            }\n                            catch (e) {\n                                Schema.onError(e);\n                            }\n                        }\n                        if (valueRef_1.onRemove) {\n                            try {\n                                valueRef_1.onRemove(itemRemoved, newLength_1 + i);\n                            }\n                            catch (e) {\n                                Schema.onError(e);\n                            }\n                        }\n                    });\n                }\n                for (var i = 0; i < numChanges; i++) {\n                    var newIndex = decode.number(bytes, it);\n                    var indexChangedFrom = void 0; // index change check\n                    if (decode.indexChangeCheck(bytes, it)) {\n                        decode.uint8(bytes, it);\n                        indexChangedFrom = decode.number(bytes, it);\n                        hasIndexChange = true;\n                    }\n                    var isNew = (!hasIndexChange && value[newIndex] === undefined) || (hasIndexChange && indexChangedFrom === undefined);\n                    if (type.prototype instanceof Schema) {\n                        var item = void 0;\n                        if (isNew) {\n                            item = this_1.createTypeInstance(bytes, it, type);\n                        }\n                        else if (indexChangedFrom !== undefined) {\n                            item = valueRef_1[indexChangedFrom];\n                        }\n                        else {\n                            item = valueRef_1[newIndex];\n                        }\n                        if (!item) {\n                            item = this_1.createTypeInstance(bytes, it, type);\n                            isNew = true;\n                        }\n                        item.decode(bytes, it);\n                        value[newIndex] = item;\n                    }\n                    else {\n                        value[newIndex] = decodePrimitiveType(type, bytes, it);\n                    }\n                    if (isNew) {\n                        if (valueRef_1.onAdd) {\n                            try {\n                                valueRef_1.onAdd(value[newIndex], newIndex);\n                            }\n                            catch (e) {\n                                Schema.onError(e);\n                            }\n                        }\n                    }\n                    else if (valueRef_1.onChange) {\n                        try {\n                            valueRef_1.onChange(value[newIndex], newIndex);\n                        }\n                        catch (e) {\n                            Schema.onError(e);\n                        }\n                    }\n                    change.push(value[newIndex]);\n                }\n            }\n            else if (type.map) {\n                type = type.map;\n                var valueRef = this_1[_field] || new MapSchema_1.MapSchema();\n                value = valueRef.clone(true);\n                var length = decode.number(bytes, it);\n                hasChange = (length > 0);\n                // FIXME: this may not be reliable. possibly need to encode this variable during\n                // serializagion\n                var hasIndexChange = false;\n                var previousKeys = Object.keys(valueRef);\n                for (var i = 0; i < length; i++) {\n                    // `encodeAll` may indicate a higher number of indexes it actually encodes\n                    // TODO: do not encode a higher number than actual encoded entries\n                    if (bytes[it.offset] === undefined ||\n                        bytes[it.offset] === spec_1.END_OF_STRUCTURE) {\n                        break;\n                    }\n                    var isNilItem = decode.nilCheck(bytes, it) && ++it.offset;\n                    // index change check\n                    var previousKey = void 0;\n                    if (decode.indexChangeCheck(bytes, it)) {\n                        decode.uint8(bytes, it);\n                        previousKey = previousKeys[decode.number(bytes, it)];\n                        hasIndexChange = true;\n                    }\n                    var hasMapIndex = decode.numberCheck(bytes, it);\n                    var isSchemaType = typeof (type) !== \"string\";\n                    var newKey = (hasMapIndex)\n                        ? previousKeys[decode.number(bytes, it)]\n                        : decode.string(bytes, it);\n                    var item = void 0;\n                    var isNew = (!hasIndexChange && valueRef[newKey] === undefined) || (hasIndexChange && previousKey === undefined && hasMapIndex);\n                    if (isNew && isSchemaType) {\n                        item = this_1.createTypeInstance(bytes, it, type);\n                    }\n                    else if (previousKey !== undefined) {\n                        item = valueRef[previousKey];\n                    }\n                    else {\n                        item = valueRef[newKey];\n                    }\n                    if (isNilItem) {\n                        if (item && item.onRemove) {\n                            try {\n                                item.onRemove();\n                            }\n                            catch (e) {\n                                Schema.onError(e);\n                            }\n                        }\n                        if (valueRef.onRemove) {\n                            try {\n                                valueRef.onRemove(item, newKey);\n                            }\n                            catch (e) {\n                                Schema.onError(e);\n                            }\n                        }\n                        delete value[newKey];\n                        continue;\n                    }\n                    else if (!isSchemaType) {\n                        value[newKey] = decodePrimitiveType(type, bytes, it);\n                    }\n                    else {\n                        item.decode(bytes, it);\n                        value[newKey] = item;\n                    }\n                    if (isNew) {\n                        if (valueRef.onAdd) {\n                            try {\n                                valueRef.onAdd(value[newKey], newKey);\n                            }\n                            catch (e) {\n                                Schema.onError(e);\n                            }\n                        }\n                    }\n                    else if (valueRef.onChange) {\n                        try {\n                            valueRef.onChange(value[newKey], newKey);\n                        }\n                        catch (e) {\n                            Schema.onError(e);\n                        }\n                    }\n                }\n            }\n            else {\n                value = decodePrimitiveType(type, bytes, it);\n                // FIXME: should not even have encoded if value haven't changed in the first place!\n                // check FilterTest.ts: \"should not trigger `onChange` if field haven't changed\"\n                hasChange = (value !== this_1[_field]);\n            }\n            if (hasChange && (this_1.onChange || this_1.$listeners[field])) {\n                changes.push({\n                    field: field,\n                    value: change || value,\n                    previousValue: this_1[_field]\n                });\n            }\n            this_1[_field] = value;\n        };\n        var this_1 = this;\n        while (it.offset < totalBytes) {\n            var state_1 = _loop_1();\n            if (state_1 === \"break\")\n                break;\n        }\n        this._triggerChanges(changes);\n        return this;\n    };\n    Schema.prototype.encode = function (root, encodeAll, client, bytes) {\n        var _this = this;\n        if (root === void 0) { root = this; }\n        if (encodeAll === void 0) { encodeAll = false; }\n        if (bytes === void 0) { bytes = []; }\n        // skip if nothing has changed\n        if (!this.$changes.changed && !encodeAll) {\n            this._encodeEndOfStructure(this, root, bytes);\n            return bytes;\n        }\n        var schema = this._schema;\n        var indexes = this._indexes;\n        var fieldsByIndex = this._fieldsByIndex;\n        var filters = this._filters;\n        var changes = Array.from((encodeAll || client)\n            ? this.$changes.allChanges\n            : this.$changes.changes).sort();\n        var _loop_2 = function (i, l) {\n            var field = fieldsByIndex[changes[i]] || changes[i];\n            var _field = \"_\" + field;\n            var type = schema[field];\n            var filter = (filters && filters[field]);\n            // const value = (filter && this.$allChanges[field]) || changes[field];\n            var value = this_2[_field];\n            var fieldIndex = indexes[field];\n            if (value === undefined) {\n                encode.uint8(bytes, spec_1.NIL);\n                encode.number(bytes, fieldIndex);\n            }\n            else if (type._schema) {\n                if (client && filter) {\n                    // skip if not allowed by custom filter\n                    if (!filter.call(this_2, client, value, root)) {\n                        return \"continue\";\n                    }\n                }\n                if (!value) {\n                    // value has been removed\n                    encode.uint8(bytes, spec_1.NIL);\n                    encode.number(bytes, fieldIndex);\n                }\n                else {\n                    // encode child object\n                    encode.number(bytes, fieldIndex);\n                    assertInstanceType(value, type, this_2, field);\n                    this_2.tryEncodeTypeId(bytes, type, value.constructor);\n                    value.encode(root, encodeAll, client, bytes);\n                }\n            }\n            else if (Array.isArray(type)) {\n                var $changes = value.$changes;\n                encode.number(bytes, fieldIndex);\n                // total number of items in the array\n                encode.number(bytes, value.length);\n                var arrayChanges = Array.from((encodeAll || client)\n                    ? $changes.allChanges\n                    : $changes.changes)\n                    .filter(function (index) { return _this[_field][index] !== undefined; })\n                    .sort(function (a, b) { return a - b; });\n                // ensure number of changes doesn't exceed array length\n                var numChanges = arrayChanges.length;\n                // number of changed items\n                encode.number(bytes, numChanges);\n                var isChildSchema = typeof (type[0]) !== \"string\";\n                // assert ArraySchema was provided\n                assertInstanceType(this_2[_field], ArraySchema_1.ArraySchema, this_2, field);\n                // encode Array of type\n                for (var j = 0; j < numChanges; j++) {\n                    var index = arrayChanges[j];\n                    var item = this_2[_field][index];\n                    if (client && filter) {\n                        // skip if not allowed by custom filter\n                        if (!filter.call(this_2, client, item, root)) {\n                            continue;\n                        }\n                    }\n                    if (isChildSchema) { // is array of Schema\n                        encode.number(bytes, index);\n                        if (!encodeAll) {\n                            var indexChange = $changes.getIndexChange(item);\n                            if (indexChange !== undefined) {\n                                encode.uint8(bytes, spec_1.INDEX_CHANGE);\n                                encode.number(bytes, indexChange);\n                            }\n                        }\n                        assertInstanceType(item, type[0], this_2, field);\n                        this_2.tryEncodeTypeId(bytes, type[0], item.constructor);\n                        item.encode(root, encodeAll, client, bytes);\n                    }\n                    else if (item !== undefined) { // is array of primitives\n                        encode.number(bytes, index);\n                        encodePrimitiveType(type[0], bytes, item, this_2, field);\n                    }\n                }\n                if (!encodeAll) {\n                    $changes.discard();\n                }\n            }\n            else if (type.map) {\n                var $changes = value.$changes;\n                // encode Map of type\n                encode.number(bytes, fieldIndex);\n                // TODO: during `encodeAll`, removed entries are not going to be encoded\n                var keys = Array.from((encodeAll || client)\n                    ? $changes.allChanges\n                    : $changes.changes);\n                encode.number(bytes, keys.length);\n                // const previousKeys = Object.keys(this[_field]); // this is costly!\n                var previousKeys = Array.from($changes.allChanges);\n                var isChildSchema = typeof (type.map) !== \"string\";\n                var numChanges = keys.length;\n                // assert MapSchema was provided\n                assertInstanceType(this_2[_field], MapSchema_1.MapSchema, this_2, field);\n                for (var i_1 = 0; i_1 < numChanges; i_1++) {\n                    var key = keys[i_1];\n                    var item = this_2[_field][key];\n                    var mapItemIndex = undefined;\n                    if (client && filter) {\n                        // skip if not allowed by custom filter\n                        if (!filter.call(this_2, client, item, root)) {\n                            continue;\n                        }\n                    }\n                    if (encodeAll) {\n                        if (item === undefined) {\n                            // previously deleted items are skipped during `encodeAll`\n                            continue;\n                        }\n                    }\n                    else {\n                        // encode index change\n                        var indexChange = $changes.getIndexChange(item);\n                        if (item && indexChange !== undefined) {\n                            encode.uint8(bytes, spec_1.INDEX_CHANGE);\n                            encode.number(bytes, this_2[_field]._indexes.get(indexChange));\n                        }\n                        /**\n                         * - Allow item replacement\n                         * - Allow to use the index of a deleted item to encode as NIL\n                         */\n                        mapItemIndex = (!$changes.isDeleted(key) || !item)\n                            ? this_2[_field]._indexes.get(key)\n                            : undefined;\n                    }\n                    var isNil = (item === undefined);\n                    /**\n                     * Invert NIL to prevent collision with data starting with NIL byte\n                     */\n                    if (isNil) {\n                        // TODO: remove item\n                        // console.log(\"REMOVE KEY INDEX\", { key });\n                        // this[_field]._indexes.delete(key);\n                        encode.uint8(bytes, spec_1.NIL);\n                    }\n                    if (mapItemIndex !== undefined) {\n                        encode.number(bytes, mapItemIndex);\n                    }\n                    else {\n                        encode.string(bytes, key);\n                    }\n                    if (item && isChildSchema) {\n                        assertInstanceType(item, type.map, this_2, field);\n                        this_2.tryEncodeTypeId(bytes, type.map, item.constructor);\n                        item.encode(root, encodeAll, client, bytes);\n                    }\n                    else if (!isNil) {\n                        encodePrimitiveType(type.map, bytes, item, this_2, field);\n                    }\n                }\n                if (!encodeAll) {\n                    $changes.discard();\n                    // TODO: track array/map indexes per client (for filtering)?\n                    if (!client) {\n                        // TODO: do not iterate though all MapSchema indexes here.\n                        this_2[_field]._updateIndexes(previousKeys);\n                    }\n                }\n            }\n            else {\n                if (client && filter) {\n                    // skip if not allowed by custom filter\n                    if (!filter.call(this_2, client, value, root)) {\n                        return \"continue\";\n                    }\n                }\n                encode.number(bytes, fieldIndex);\n                encodePrimitiveType(type, bytes, value, this_2, field);\n            }\n        };\n        var this_2 = this;\n        for (var i = 0, l = changes.length; i < l; i++) {\n            _loop_2(i, l);\n        }\n        // flag end of Schema object structure\n        this._encodeEndOfStructure(this, root, bytes);\n        if (!encodeAll && !client) {\n            this.$changes.discard();\n        }\n        return bytes;\n    };\n    Schema.prototype.encodeFiltered = function (client, bytes) {\n        return this.encode(this, false, client, bytes);\n    };\n    Schema.prototype.encodeAll = function (bytes) {\n        return this.encode(this, true, undefined, bytes);\n    };\n    Schema.prototype.encodeAllFiltered = function (client, bytes) {\n        return this.encode(this, true, client, bytes);\n    };\n    Schema.prototype.clone = function () {\n        var cloned = new (this.constructor);\n        var schema = this._schema;\n        for (var field in schema) {\n            if (typeof (this[field]) === \"object\" &&\n                typeof (this[field].clone) === \"function\") {\n                // deep clone\n                cloned[field] = this[field].clone();\n            }\n            else {\n                // primitive values\n                cloned[field] = this[field];\n            }\n        }\n        return cloned;\n    };\n    Schema.prototype.triggerAll = function () {\n        if (!this.onChange) {\n            return;\n        }\n        var changes = [];\n        var schema = this._schema;\n        for (var field in schema) {\n            if (this[field] !== undefined) {\n                changes.push({\n                    field: field,\n                    value: this[field],\n                    previousValue: undefined\n                });\n            }\n        }\n        try {\n            this.onChange(changes);\n        }\n        catch (e) {\n            Schema.onError(e);\n        }\n    };\n    Schema.prototype.toJSON = function () {\n        var schema = this._schema;\n        var deprecated = this._deprecated;\n        var obj = {};\n        for (var field in schema) {\n            if (!deprecated[field] && this[field] !== null && typeof (this[field]) !== \"undefined\") {\n                obj[field] = (typeof (this[field].toJSON) === \"function\")\n                    ? this[field].toJSON()\n                    : this[\"_\" + field];\n            }\n        }\n        return obj;\n    };\n    Schema.prototype.discardAllChanges = function () {\n        var schema = this._schema;\n        var changes = Array.from(this.$changes.changes);\n        var fieldsByIndex = this._fieldsByIndex;\n        for (var index in changes) {\n            var field = fieldsByIndex[index];\n            var type = schema[field];\n            var value = this[field];\n            // skip unchagned fields\n            if (value === undefined) {\n                continue;\n            }\n            if (type._schema) {\n                value.discardAllChanges();\n            }\n            else if (Array.isArray(type)) {\n                // encode Array of type\n                for (var i = 0, l = value.length; i < l; i++) {\n                    var index_1 = value[i];\n                    var item = this[\"_\" + field][index_1];\n                    if (typeof (type[0]) !== \"string\") { // is array of Schema\n                        item.discardAllChanges();\n                    }\n                }\n            }\n            else if (type.map) {\n                var keys = value;\n                var mapKeys = Object.keys(this[\"_\" + field]);\n                for (var i = 0; i < keys.length; i++) {\n                    var key = mapKeys[keys[i]] || keys[i];\n                    var item = this[\"_\" + field][key];\n                    if (item instanceof Schema) {\n                        item.discardAllChanges();\n                    }\n                }\n            }\n        }\n        this.$changes.discard();\n    };\n    Schema.prototype._encodeEndOfStructure = function (instance, root, bytes) {\n        if (instance !== root) {\n            bytes.push(spec_1.END_OF_STRUCTURE);\n        }\n    };\n    Schema.prototype.tryEncodeTypeId = function (bytes, type, targetType) {\n        if (type._typeid !== targetType._typeid) {\n            encode.uint8(bytes, spec_1.TYPE_ID);\n            encode.uint8(bytes, targetType._typeid);\n        }\n    };\n    Schema.prototype.createTypeInstance = function (bytes, it, type) {\n        if (bytes[it.offset] === spec_1.TYPE_ID) {\n            it.offset++;\n            var anotherType = this.constructor._context.get(decode.uint8(bytes, it));\n            return new anotherType();\n        }\n        else {\n            return new type();\n        }\n    };\n    Schema.prototype._triggerChanges = function (changes) {\n        if (changes.length > 0) {\n            for (var i = 0; i < changes.length; i++) {\n                var change = changes[i];\n                var listener = this.$listeners[change.field];\n                if (listener) {\n                    try {\n                        listener.invoke(change.value, change.previousValue);\n                    }\n                    catch (e) {\n                        Schema.onError(e);\n                    }\n                }\n            }\n            if (this.onChange) {\n                try {\n                    this.onChange(changes);\n                }\n                catch (e) {\n                    Schema.onError(e);\n                }\n            }\n        }\n    };\n    return Schema;\n}());\nexports.Schema = Schema;\n//# sourceMappingURL=Schema.js.map"]},"metadata":{},"sourceType":"script"}