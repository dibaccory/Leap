{"ast":null,"code":"var util = require('./util.js'); //single, phase, jump, super-jump\n\n/*\nadj: adjacent\nphase: change portal side\nleap: capture piece while jumping through a portal\njitch: jump, then phase\nswump: switch, then jump\n}\n\nREFACTOR CHANGES:\nLeap.js -> Game.js\n\t<Leap> -> <GameController>\nboard.js -> leap.js\n\n\nBITWISE:\n\nBOARD:\nbit\t\t\t\titem\n0\t\t\t\t\tcellType\t{regular, phase}\n1-2\t\t\t\tcellState\t\t{00: empty, 10: SPECIAL, 01: p1, 11: p2, }   NOTE, if '10' for bits 1 and 2, then it should be a SPECIAL THING???  lmao what if a piece can be moved by either player for a few turns?\n3\t\t\t\t\tisCloned\n4-8\t\t\t\tkey\t\t\t\tIf piece on cell, this is index to reach it\n\nboard[i] = (key << 4 | isCloned << 3 | cellState << 1 | cellType);\nfor i = row * SIZE + col \t\twhere row, col wtr a given piece\n\nPIECE INDEX:\nbit \t\t\titem\n0-2\t\t\t\tcol\n3-(5,6)\t\trow\n\nboard[i] = (row << 4 | col);\nfor i = SIZE*SIZE + key\t\t\twher\n\n*/\n\n/*TODO: 17, 19, 22 are based on the default layout,\n\tThis function assumes the phases are symmetric on both axes\n\tNeed to have a function that checks if only symmetric on at least one\t\t\t//7x9 (row x col) relative origin = (4,5)\n\t\t-calculates offsets\n\t\t\t\t17\n\t\t\t\t17 + (len-1-bufferSize)/nRowPartitions x len\n\t\t\t\t17 + (len-1-bufferSize)/nColPartitions\n\t\t\t\t17 + (len-1-bufferSize)/nRowPartitions + (len-1-bufferSize)/nColPartitions x len\n\t\t\t\tboard[i + j*len] = 1^(\n\t\t\t\t\t(i + j*len)^17 & (i + j*len)^19 & (i + j*len)^26\n\t\t\t\t&\t(i + j*len)^41 & (i + j*len)^34 & (i + j*len)^43\n\t\t\t\t&\t(i + j*len)^20 & (i + j*len)^29 & (i + j*len)^22\n\t\t\t\t&\t(i + j*len)^44 & (i + j*len)^37 & (i + j*len)^46 );\n\t\t\t}\n*/\n//can I generate layouts on seeds? lmao\n\n\nfunction Board(len, phaseLayout) {\n  this.p1 = 1;\n  this.p2 = 3;\n  this.len = len;\n  this.area = len * len;\n  (this.board = []).length = this.area + 4 * len;\n  this.board.fill(0);\n  this.bufferSize = 1;\n  this.init(phaseLayout); //this.update();\n}\n\nBoard.prototype.init = function (layout) {\n  let key = 0;\n  const len = this.len;\n\n  const calcPhases = index => {\n    let acc = 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1;\n\n    for (let k; k < util.phaseLayouts[layout].length; k++) {\n      acc &= index ^ util.phaseLayouts[layout][k];\n    }\n\n    return 1 ^ acc;\n  };\n\n  for (let i = 0; i < len; i++) {\n    this.board[i] = key << 4 | this.p1 << 1; //000000 0 01 0\n\n    this.initPiece(this.area + key, 0, i);\n    this.board[i + (len - 1) * len] = key + 2 * len << 4 | this.p2 << 1; //100000 0 11 0\n\n    this.initPiece(this.area + key, (len - 1) * len, i);\n    key++;\n\n    for (let j = 1 + this.bufferSize; j < len - 1 - this.bufferSize; j++) {\n      this.board[i + j * len] = calcPhases(i + j * len);\n    }\n  }\n};\n\nBoard.prototype.initPiece = function (i, row, col) {\n  this.board[i] = row << 4 | col;\n};\n\nBoard.prototype.getPlayer = function (row, col) {\n  this.board[row * this.len + col];\n};\n\nBoard.prototype.update = function (newPiece) {\n  if (newPiece) {\n    //find out which player this piece belongs to then add it within that player's key range (00000)\n    this.board = this.board.map(row => row.map((cell, j) => {\n      if (cell.who != null) {\n        //increment all pi in board after piecesSeparator by one\n        if (cell.who >= this.piecesSeparator) cell.who++; //if piece alive, keep on board\n\n        return this.pieces[cell.who].alive ? {\n          who: cell.who,\n          move: false\n        } : {\n          who: null,\n          move: false\n        };\n      } else return {\n        who: null,\n        move: false\n      };\n    }));\n  } else {\n    this.board = this.board.map(row => row.map((cell, j) => cell.who != null ? this.pieces[cell.who].alive ? {\n      who: cell.who,\n      move: false\n    } : {\n      who: null,\n      move: false\n    } : {\n      who: null,\n      move: false\n    }));\n  }\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n//Calls every time a clone is made\n\n\nBoard.prototype.insertAtSeparationIndex = function () {\n  for (let pi = this.piecesSeparator; pi < this.pieces.length; pi++) {\n    //Finds index that separates p1 and p2 pieces\n    if (this.pieces[pi].player !== this.p2) {\n      this.piecesSeparator = pi; //update\n\n      return pi;\n    }\n  }\n};\n\nBoard.prototype.makeClone = function (pi, row, col) {\n  /*\n  getPlayer bit\n  */\n  this.board[row * this.len + col] |= this.getPlayer(row, col);\n  this.updateBoard(true);\n  this.board[row][col].who = this.piecesSeparator;\n  return true;\n};\n\nBoard.prototype.canClone = function (pi) {\n  let p = this.pieces[pi];\n  return !p.cloned && p.col < 7 && p.col > 0 && (p.player === this.p1 && !p.row || p.player === this.p2 && p.row === 7);\n};\n\nBoard.prototype.isCloneSpawn = function (pi, row, col) {\n  return this.canClone(pi) && this.board[row][col].who === null;\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n// Board.prototype.getPlayer = function (pi) {\n// \treturn this.pieces[pi].player;\n// }\n\n\nBoard.prototype.isLeap = function (p, rowIncr, colIncr, isPhase, cellAdj, bypassCondition) {\n  //if neighbor cell is a phase, leap_cell clear, and (enemy piece on phaseAdj XOR enemy piece on phaseFar)\n  let destinationCell = this.board[7 - p.row][7 - p.col];\n\n  if (isPhase && !destinationCell.who) {\n    let phaseAdj = cellAdj.who;\n    let phaseFar = this.board[7 - (p.row + rowIncr)][7 - (p.col + colIncr)].who;\n\n    if ((phaseAdj || phaseFar) && !(phaseAdj && phaseFar)) {\n      //xor filter. Only one may be true\n      let capt = phaseAdj ? phaseAdj : phaseFar; //if 0, add to destinationCell.move, if 1,\n\n      if (bypassCondition) return true;else destinationCell.move = capt;\n    }\n  }\n};\n\nBoard.prototype.isJump = function (p, rowIncr, colIncr, cellAdj, bypassCondition) {\n  //if adj cell occupied, jumpCell in bounds, jumpCell clear, and jumpCell has enemy piece\n  if (util.inBounds(p.row + rowIncr * 2, p.col + colIncr * 2)) {\n    let destinationCell = this.board[p.row + rowIncr * 2][p.col + colIncr * 2];\n\n    if (this.getPlayer(cellAdj.who) !== p.player && destinationCell.who === null) {\n      if (bypassCondition % 3) return true;else destinationCell.move = cellAdj.who;\n    }\n  }\n};\n\nBoard.prototype.isPhase = function (p, bypassCondition) {\n  let isPhase = util.cellType(p.row, p.col) > 1;\n  let destinationCell = this.board[7 - p.row][7 - p.col];\n\n  if (isPhase && destinationCell.who === null) {\n    if (bypassCondition % 3) return true;else destinationCell.move = true;\n  }\n};\n\nBoard.prototype.getCloneSpawns = function (p, bypassCondition) {\n  let row = p.player === this.p1 ? 7 : 0;\n\n  for (let col = 1; col < 7; col++) {\n    let destinationCell = this.board[row][col];\n\n    if (destinationCell.who === null) {\n      if (bypassCondition % 3) return true;else destinationCell.move = true;\n    }\n  }\n};\n\nBoard.prototype.getMovesInDirection = function (p, bypassCondition, r, c) {\n  //check adjacent cells of piece p wrt the boundary\n  if (util.inBounds(p.row + r, p.col + c) && (r || c)) {\n    let cellAdj = this.board[p.row + r][p.col + c];\n    let isPhase = util.cellType(p.row + r, p.col + c) > 1;\n    if (this.isLeap(p, r, c, isPhase, cellAdj, bypassCondition)) return true;\n\n    if (cellAdj.who !== null) {\n      if (this.isJump(p, r, c, cellAdj, bypassCondition)) return true;\n    } else if (bypassCondition % 3 % 2) return true; //adjacent moves\n    else if (!bypassCondition) cellAdj.move = true;\n  }\n\n  return false;\n};\n/* bypassCondition (HIGHLIGHT BYPASS CONDITION):\n\t\tundefined - default (Store all),\n\t\t1 - bypass all,\n\t\t2 - bypass continuable moves,\n\t\t3 - store continuable moves\n*/\n\n\nBoard.prototype.getMoves = function (pi, bypassCondition, r, c) {\n  let p = this.pieces[pi]; //TODO: ref this.board[p.row + r][p.col + r].who, and set highlight = true for every destination\n\n  if (this.isPhase(p, bypassCondition)) return true;\n  if (this.canClone(pi) && this.getCloneSpawns(p, bypassCondition)) return true;\n\n  if (r != null && c != null) {\n    if (this.getMovesInDirection(p, bypassCondition, r, c)) return true;\n  } else {\n    for (r = -1; r < 2; r++) for (c = -1; c < 2; c++) {\n      if (this.getMovesInDirection(p, bypassCondition, r, c)) return true;\n    }\n  }\n\n  return false;\n}; //Performs move. returns true if caught piece in process, else false\n\n\nBoard.prototype.doMove = function (pi, row, col) {\n  let p = this.pieces[pi]; //begin move\n\n  this.board[p.row][p.col].who = null;\n  let destinationCell = this.board[row][col];\n  let caught = typeof destinationCell.move === \"number\" ? destinationCell.move : false; //caught piece index\n  // moveDirection is defined if and only if any of the following is true (for moving piece p):\n\n  let moveDirection; // (1) p caught a piece\n\n  if (caught) {\n    let c = this.pieces[caught];\n    c.alive = false;\n    this.board[c.row][c.col].who = null; //return direction of move\n    //If leap, then c adjacent at start XOR c adjacent at end\n    //Check adjacency of moving piece to captured piece on starting position and ending position\n\n    let cellAdjStartPos = Math.abs(c.row - p.row) < 2 && Math.abs(c.col - p.col) < 2;\n    let cellAdjEndPos = Math.abs(row - c.row) < 2 && Math.abs(col - c.col) < 2;\n    moveDirection = cellAdjStartPos && cellAdjEndPos ? {\n      rowIncr: Math.sign(row - c.row),\n      colIncr: Math.sign(col - c.col)\n    } //jump\n    : cellAdjStartPos ? {\n      rowIncr: Math.sign(c.row - p.row),\n      colIncr: Math.sign(c.col - p.row)\n    } //leap-> piece adj to capture on start\n    : {\n      rowIncr: Math.sign(row - c.row),\n      colIncr: Math.sign(col - c.col)\n    };\n  } // (2) p LANDS on a phase cell. That is, this move is not a phase.\n  else if (!this.samePhase(p, {\n      row: row,\n      col: col\n    })) moveDirection = {\n      rowIncr: 0,\n      colIncr: 0\n    }; //end move\n\n\n  this.board[row][col].who = pi;\n  p.row = row;\n  p.col = col; // (3) p is able to be cloned\n\n  if (this.canClone(pi)) moveDirection = {\n    rowIncr: 0,\n    colIncr: 0\n  };\n  this.updateBoard();\n  return moveDirection;\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tINTEGRITY\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n\nBoard.prototype.samePhase = function (from, to) {\n  let isDestinationPhase = util.cellType(to.row, to.col);\n  return isDestinationPhase > 1 && isDestinationPhase === util.cellType(from.row, from.col);\n};\n\nBoard.prototype.canContinueMove = function (pi, dir) {\n  return dir ? this.getMoves(pi, 2, dir.rowIncr, dir.colIncr) : false;\n};\n\nBoard.prototype.hasMoves = function (pi) {\n  return this.getMoves(pi, 1);\n}; //Player has no more moves when (1): all player's pieces are dead (2): every piece has no moves\n\n\nBoard.prototype.movesLeft = function (player) {\n  for (let pi = 0; pi < this.pieces.length; pi++) {\n    let p = this.pieces[pi];\n\n    if (p.alive && p.player === player) {\n      if (this.hasMoves(pi)) return true;\n    }\n  }\n\n  return false;\n};\n\nBoard.prototype.validMove = function (row, col) {\n  return this.board[row][col].move;\n};\n\nmodule.exports = Board;","map":{"version":3,"sources":["/Users/bacchus/git/Leap/src/js/board.js"],"names":["util","require","Board","len","phaseLayout","p1","p2","area","board","length","fill","bufferSize","init","prototype","layout","key","calcPhases","index","acc","k","phaseLayouts","i","initPiece","j","row","col","getPlayer","update","newPiece","map","cell","who","piecesSeparator","pieces","alive","move","insertAtSeparationIndex","pi","player","makeClone","updateBoard","canClone","p","cloned","isCloneSpawn","isLeap","rowIncr","colIncr","isPhase","cellAdj","bypassCondition","destinationCell","phaseAdj","phaseFar","capt","isJump","inBounds","cellType","getCloneSpawns","getMovesInDirection","r","c","getMoves","doMove","caught","moveDirection","cellAdjStartPos","Math","abs","cellAdjEndPos","sign","samePhase","from","to","isDestinationPhase","canContinueMove","dir","hasMoves","movesLeft","validMove","module","exports"],"mappings":"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","sourcesContent":["var util = require('./util.js');\n//single, phase, jump, super-jump\n/*\nadj: adjacent\nphase: change portal side\nleap: capture piece while jumping through a portal\njitch: jump, then phase\nswump: switch, then jump\n}\n\nREFACTOR CHANGES:\nLeap.js -> Game.js\n\t<Leap> -> <GameController>\nboard.js -> leap.js\n\n\nBITWISE:\n\nBOARD:\nbit\t\t\t\titem\n0\t\t\t\t\tcellType\t{regular, phase}\n1-2\t\t\t\tcellState\t\t{00: empty, 10: SPECIAL, 01: p1, 11: p2, }   NOTE, if '10' for bits 1 and 2, then it should be a SPECIAL THING???  lmao what if a piece can be moved by either player for a few turns?\n3\t\t\t\t\tisCloned\n4-8\t\t\t\tkey\t\t\t\tIf piece on cell, this is index to reach it\n\nboard[i] = (key << 4 | isCloned << 3 | cellState << 1 | cellType);\nfor i = row * SIZE + col \t\twhere row, col wtr a given piece\n\nPIECE INDEX:\nbit \t\t\titem\n0-2\t\t\t\tcol\n3-(5,6)\t\trow\n\nboard[i] = (row << 4 | col);\nfor i = SIZE*SIZE + key\t\t\twher\n\n*/\n\n\n\t/*TODO: 17, 19, 22 are based on the default layout,\n\t\tThis function assumes the phases are symmetric on both axes\n\t\tNeed to have a function that checks if only symmetric on at least one\t\t\t//7x9 (row x col) relative origin = (4,5)\n\t\t\t-calculates offsets\n\t\t\t\t\t17\n\t\t\t\t\t17 + (len-1-bufferSize)/nRowPartitions x len\n\t\t\t\t\t17 + (len-1-bufferSize)/nColPartitions\n\t\t\t\t\t17 + (len-1-bufferSize)/nRowPartitions + (len-1-bufferSize)/nColPartitions x len\n\t\t\t\t\tboard[i + j*len] = 1^(\n\t\t\t\t\t\t(i + j*len)^17 & (i + j*len)^19 & (i + j*len)^26\n\t\t\t\t\t&\t(i + j*len)^41 & (i + j*len)^34 & (i + j*len)^43\n\t\t\t\t\t&\t(i + j*len)^20 & (i + j*len)^29 & (i + j*len)^22\n\t\t\t\t\t&\t(i + j*len)^44 & (i + j*len)^37 & (i + j*len)^46 );\n\t\t\t\t}\n\t*/\n//can I generate layouts on seeds? lmao\n\n\nfunction Board(len, phaseLayout) {\n\tthis.p1 = 1;\n\tthis.p2 = 3;\n\tthis.len = len;\n\tthis.area = len*len;\n\t(this.board = []).length = this.area + 4*len;\n\tthis.board.fill(0);\n\tthis.bufferSize = 1;\n\tthis.init(phaseLayout);\n\t//this.update();\n}\n\n\n\nBoard.prototype.init = function (layout) {\n    let key=0;\n\t\tconst len = this.len;\n\n\t\tconst calcPhases = (index) => {\n\t\t\tlet acc = 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1;\n\t\t\tfor(let k; k<util.phaseLayouts[layout].length; k++) {\n\t\t\t\tacc &= index^util.phaseLayouts[layout][k];\n\t\t\t}\n\t\t\treturn 1^acc;\n\t\t};\n\n\t\tfor(let i=0; i<len; i++) {\n\t\t\tthis.board[i] = (key << 4 | this.p1 << 1); //000000 0 01 0\n\t\t\tthis.initPiece(this.area + key, 0, i);\n\t\t\tthis.board[i + (len-1)*len] = ((key + 2*len) << 4 | this.p2 << 1); //100000 0 11 0\n\t\t\tthis.initPiece(this.area + key, (len-1)*len, i);\n\t\t\tkey++;\n\n\t\t\tfor(let j=1+this.bufferSize; j<len-1-this.bufferSize; j++) {\n\t\t\t\tthis.board[i + j*len] = calcPhases(i+j*len);\n\t\t\t}\n\t\t}\n}\n\nBoard.prototype.initPiece = function (i, row, col) {\n\tthis.board[i] = row << 4 | col;\n}\n\nBoard.prototype.getPlayer = function (row, col) {\n\tthis.board[row*this.len + col];\n}\n\nBoard.prototype.update = function (newPiece) {\n\tif (newPiece) {\n\t\t//find out which player this piece belongs to then add it within that player's key range (00000)\n\t\tthis.board = this.board.map(row => row.map((cell, j) => {\n\t\t\tif (cell.who != null) { //increment all pi in board after piecesSeparator by one\n\t\t\t\tif (cell.who >= this.piecesSeparator) cell.who++;\n\t\t\t\t//if piece alive, keep on board\n\t\t\t\treturn this.pieces[cell.who].alive ? {who: cell.who, move:false} : {who: null, move:false};\n\t\t\t} else return {who: null, move: false};\n\t\t}));\n\t} else {\n\t\tthis.board = this.board.map(row => row.map((cell, j) =>\n\t\t\t(cell.who != null)\n\t\t\t? (this.pieces[cell.who].alive\n\t\t\t\t? {who: cell.who, move:false}\n\t\t\t\t: {who: null, move:false})\n\t\t\t: {who: null, move: false}\n\t\t));\n\t}\n}\n\n\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n//Calls every time a clone is made\nBoard.prototype.insertAtSeparationIndex = function () {\n\tfor(let pi=this.piecesSeparator; pi<this.pieces.length; pi++) {\n\t\t//Finds index that separates p1 and p2 pieces\n\t\tif(this.pieces[pi].player !== this.p2) {\n\t\t\tthis.piecesSeparator = pi; //update\n\t\t\treturn pi;\n\t\t}\n\t}\n}\n\nBoard.prototype.makeClone = function (pi, row, col) {\n\t/*\n\tgetPlayer bit\n\t*/\n\tthis.board[row*this.len + col] |= this.getPlayer(row, col)\n\tthis.updateBoard(true);\n\tthis.board[row][col].who = this.piecesSeparator;\n\treturn true;\n}\n\nBoard.prototype.canClone = function (pi) {\n\tlet p = this.pieces[pi];\n\treturn (!p.cloned && p.col < 7 && p.col > 0\n\t\t&& ( (p.player === this.p1 && !p.row)\n\t\t|| (p.player === this.p2 && p.row === 7) ));\n}\n\nBoard.prototype.isCloneSpawn = function (pi, row, col) {\n\treturn this.canClone(pi) && this.board[row][col].who === null;\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n// Board.prototype.getPlayer = function (pi) {\n// \treturn this.pieces[pi].player;\n// }\n\nBoard.prototype.isLeap = function (p, rowIncr, colIncr, isPhase, cellAdj, bypassCondition) {\n\t//if neighbor cell is a phase, leap_cell clear, and (enemy piece on phaseAdj XOR enemy piece on phaseFar)\n\tlet destinationCell = this.board[7 - p.row][7 - p.col];\n\tif(isPhase && !destinationCell.who) {\n\t\tlet phaseAdj = cellAdj.who;\n\t\tlet phaseFar = this.board[7 - (p.row + rowIncr)][7 - (p.col + colIncr)].who;\n\t\tif((phaseAdj || phaseFar) && !(phaseAdj && phaseFar)) { //xor filter. Only one may be true\n\t\t\tlet capt = phaseAdj ? phaseAdj : phaseFar;\n\t\t\t//if 0, add to destinationCell.move, if 1,\n\t\t\tif (bypassCondition) return true;\n\t\t\telse destinationCell.move = capt;\n\t\t}\n\t}\n}\n\nBoard.prototype.isJump = function (p, rowIncr, colIncr, cellAdj, bypassCondition) {\n\t//if adj cell occupied, jumpCell in bounds, jumpCell clear, and jumpCell has enemy piece\n\tif(util.inBounds(p.row + rowIncr*2, p.col + colIncr*2)) {\n\t\tlet destinationCell = this.board[p.row + rowIncr*2][p.col + colIncr*2];\n\t\tif (this.getPlayer(cellAdj.who) !== p.player && destinationCell.who === null) {\n\t\t\tif(bypassCondition%3) return true;\n\t\t\telse destinationCell.move = cellAdj.who;\n\t\t}\n\t}\n}\n\nBoard.prototype.isPhase = function (p, bypassCondition) {\n\tlet isPhase = util.cellType(p.row, p.col) > 1;\n\tlet destinationCell = this.board[7 - p.row][7 - p.col];\n\tif(isPhase && destinationCell.who === null) {\n\t\tif (bypassCondition%3) return true;\n\t\telse destinationCell.move = true;\n\t}\n}\n\nBoard.prototype.getCloneSpawns = function (p, bypassCondition) {\n\tlet row = p.player === this.p1 ? 7 : 0;\n\tfor(let col=1; col<7;col++) {\n\t\tlet destinationCell = this.board[row][col];\n\t\tif (destinationCell.who === null) {\n\t\t\tif (bypassCondition%3) return true;\n\t\t\telse destinationCell.move = true;\n\t\t}\n\t}\n}\n\nBoard.prototype.getMovesInDirection = function (p, bypassCondition, r, c) {\n\t//check adjacent cells of piece p wrt the boundary\n\tif(util.inBounds(p.row + r, p.col + c) && (r || c)) {\n\t\tlet cellAdj = this.board[p.row + r][p.col + c];\n\t\tlet isPhase = util.cellType(p.row + r, p.col + c) > 1;\n\n\t\tif (this.isLeap(p, r, c, isPhase, cellAdj, bypassCondition)) return true;\n\t\tif (cellAdj.who !== null) {\n\t\t\tif (this.isJump(p, r, c, cellAdj, bypassCondition)) return true;\n\t\t}\n\t\telse if (bypassCondition%3%2) return true;\t//adjacent moves\n\t\telse if (!bypassCondition) cellAdj.move = true;\n\t}\n\treturn false;\n}\n\n/* bypassCondition (HIGHLIGHT BYPASS CONDITION):\n\t\tundefined - default (Store all),\n\t\t1 - bypass all,\n\t\t2 - bypass continuable moves,\n\t\t3 - store continuable moves\n*/\nBoard.prototype.getMoves = function (pi, bypassCondition, r, c) {\n\n\tlet p = this.pieces[pi];\n\t//TODO: ref this.board[p.row + r][p.col + r].who, and set highlight = true for every destination\n\tif (this.isPhase(p, bypassCondition)) return true;\n\tif (this.canClone(pi) && this.getCloneSpawns(p, bypassCondition)) return true;\n\n\tif (r != null && c != null) {\n\t\tif (this.getMovesInDirection(p, bypassCondition, r, c)) return true;\n\t} else {\n\t\tfor(r=-1;r<2;r++) for(c=-1;c<2; c++) {\n\t\t\tif (this.getMovesInDirection(p, bypassCondition, r, c)) return true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n//Performs move. returns true if caught piece in process, else false\nBoard.prototype.doMove = function (pi, row, col) {\n\tlet p = this.pieces[pi];\n\t//begin move\n\tthis.board[p.row][p.col].who = null;\n\n\tlet destinationCell = this.board[row][col];\n\tlet caught = typeof(destinationCell.move) === \"number\" ? destinationCell.move : false; //caught piece index\n\t// moveDirection is defined if and only if any of the following is true (for moving piece p):\n\tlet moveDirection;\n\t\t// (1) p caught a piece\n\tif (caught) {\n\t\tlet c = this.pieces[caught];\n\t\tc.alive = false;\n\t\tthis.board[c.row][c.col].who = null;\n\t\t//return direction of move\n\t\t//If leap, then c adjacent at start XOR c adjacent at end\n\t\t//Check adjacency of moving piece to captured piece on starting position and ending position\n\t\tlet cellAdjStartPos = Math.abs(c.row - p.row) < 2 && Math.abs(c.col - p.col) < 2;\n\t\tlet cellAdjEndPos = Math.abs(row - c.row) < 2 && Math.abs(col - c.col) < 2;\n\n\t\tmoveDirection = (cellAdjStartPos && cellAdjEndPos)\n\t\t\t? {rowIncr: Math.sign(row-c.row), colIncr: Math.sign(col-c.col)}\t//jump\n\t\t\t: (cellAdjStartPos\n\t\t\t\t? {rowIncr: Math.sign(c.row-p.row), colIncr: Math.sign(c.col-p.row)}\t//leap-> piece adj to capture on start\n\t\t\t\t: {rowIncr: Math.sign(row-c.row), colIncr: Math.sign(col-c.col)});\n\t}\t// (2) p LANDS on a phase cell. That is, this move is not a phase.\n\telse if (!this.samePhase(p,{row: row, col: col}))\tmoveDirection = {rowIncr: 0, colIncr: 0};\n\n\t//end move\n\tthis.board[row][col].who = pi;\n\tp.row = row;\n\tp.col = col;\n\n\t\t// (3) p is able to be cloned\n\tif (this.canClone(pi)) moveDirection = {rowIncr: 0, colIncr:0};\n\tthis.updateBoard();\n\treturn moveDirection;\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tINTEGRITY\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\nBoard.prototype.samePhase = function (from, to) {\n\tlet isDestinationPhase = util.cellType(to.row, to.col);\n\treturn isDestinationPhase > 1 && isDestinationPhase === util.cellType(from.row, from.col);\n}\n\nBoard.prototype.canContinueMove = function (pi, dir) {\n\n\treturn dir ? this.getMoves(pi, 2, dir.rowIncr, dir.colIncr) : false;\n}\n\nBoard.prototype.hasMoves = function (pi) {\n\treturn this.getMoves(pi, 1);\n}\n\n//Player has no more moves when (1): all player's pieces are dead (2): every piece has no moves\nBoard.prototype.movesLeft = function (player) {\n\tfor(let pi=0; pi < this.pieces.length; pi++) {\n\t\tlet p = this.pieces[pi];\n\t\tif(p.alive && p.player === player) {\n\t\t\tif(this.hasMoves(pi)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nBoard.prototype.validMove = function (row, col) {\n\treturn this.board[row][col].move;\n}\n\nmodule.exports = Board;\n"]},"metadata":{},"sourceType":"module"}