{"ast":null,"code":"// Fossil SCM delta compression algorithm\n// ======================================\n//\n// Format:\n// http://www.fossil-scm.org/index.html/doc/tip/www/delta_format.wiki\n//\n// Algorithm:\n// http://www.fossil-scm.org/index.html/doc/tip/www/delta_encoder_algorithm.wiki\n//\n// Original implementation:\n// http://www.fossil-scm.org/index.html/artifact/d1b0598adcd650b3551f63b17dfc864e73775c3d\n//\n// LICENSE\n// -------\n//\n// Copyright 2014 Dmitry Chestnykh (JavaScript port)\n// Copyright 2007 D. Richard Hipp  (original C version)\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the\n// following conditions are met:\n//\n//   1. Redistributions of source code must retain the above\n//      copyright notice, this list of conditions and the\n//      following disclaimer.\n//\n//   2. Redistributions in binary form must reproduce the above\n//      copyright notice, this list of conditions and the\n//      following disclaimer in the documentation and/or other\n//      materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS\n// OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n// BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n// OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// The views and conclusions contained in the software and documentation\n// are those of the authors and contributors and should not be interpreted\n// as representing official policies, either expressed or implied, of anybody\n// else.\n//\n(function (root, factory) {\n  if (typeof module !== 'undefined' && module.exports) module.exports = factory();else root.fossilDelta = factory();\n})(this, function () {\n  'use strict';\n\n  var fossilDelta = {}; // Hash window width in bytes. Must be a power of two.\n\n  var NHASH = 16;\n\n  function RollingHash() {\n    this.a = 0; // hash     (16-bit unsigned)\n\n    this.b = 0; // values   (16-bit unsigned)\n\n    this.i = 0; // start of the hash window (16-bit unsigned)\n\n    this.z = new Array(NHASH); // the values that have been hashed.\n  } // Initialize the rolling hash using the first NHASH bytes of\n  // z at the given position.\n\n\n  RollingHash.prototype.init = function (z, pos) {\n    var a = 0,\n        b = 0,\n        i,\n        x;\n\n    for (i = 0; i < NHASH; i++) {\n      x = z[pos + i];\n      a = a + x & 0xffff;\n      b = b + (NHASH - i) * x & 0xffff;\n      this.z[i] = x;\n    }\n\n    this.a = a & 0xffff;\n    this.b = b & 0xffff;\n    this.i = 0;\n  }; // Advance the rolling hash by a single byte \"c\".\n\n\n  RollingHash.prototype.next = function (c) {\n    var old = this.z[this.i];\n    this.z[this.i] = c;\n    this.i = this.i + 1 & NHASH - 1;\n    this.a = this.a - old + c & 0xffff;\n    this.b = this.b - NHASH * old + this.a & 0xffff;\n  }; // Return a 32-bit hash value.\n\n\n  RollingHash.prototype.value = function () {\n    return (this.a & 0xffff | (this.b & 0xffff) << 16) >>> 0;\n  };\n\n  var zDigits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~\".split('').map(function (x) {\n    return x.charCodeAt(0);\n  });\n  var zValue = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, 36, -1, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, -1, -1, -1, 63, -1]; // Reader reads bytes, chars, ints from array.\n\n  function Reader(array) {\n    this.a = array; // source array\n\n    this.pos = 0; // current position in array\n  }\n\n  Reader.prototype.haveBytes = function () {\n    return this.pos < this.a.length;\n  };\n\n  Reader.prototype.getByte = function () {\n    var b = this.a[this.pos];\n    this.pos++;\n    if (this.pos > this.a.length) throw new RangeError('out of bounds');\n    return b;\n  };\n\n  Reader.prototype.getChar = function () {\n    return String.fromCharCode(this.getByte());\n  }; // Read base64-encoded unsigned integer.\n\n\n  Reader.prototype.getInt = function () {\n    var v = 0,\n        c;\n\n    while (this.haveBytes() && (c = zValue[0x7f & this.getByte()]) >= 0) {\n      v = (v << 6) + c;\n    }\n\n    this.pos--;\n    return v >>> 0;\n  }; // Write writes an array.\n\n\n  function Writer() {\n    this.a = [];\n  }\n\n  Writer.prototype.toArray = function () {\n    return this.a;\n  };\n\n  Writer.prototype.putByte = function (b) {\n    this.a.push(b & 0xff);\n  }; // Write an ASCII character (s is a one-char string).\n\n\n  Writer.prototype.putChar = function (s) {\n    this.putByte(s.charCodeAt(0));\n  }; // Write a base64 unsigned integer.\n\n\n  Writer.prototype.putInt = function (v) {\n    var i,\n        j,\n        zBuf = [];\n\n    if (v === 0) {\n      this.putChar('0');\n      return;\n    }\n\n    for (i = 0; v > 0; i++, v >>>= 6) zBuf.push(zDigits[v & 0x3f]);\n\n    for (j = i - 1; j >= 0; j--) this.putByte(zBuf[j]);\n  }; // Copy from array at start to end.\n\n\n  Writer.prototype.putArray = function (a, start, end) {\n    for (var i = start; i < end; i++) this.a.push(a[i]);\n  }; // Return the number digits in the base64 representation of a positive integer.\n\n\n  function digitCount(v) {\n    var i, x;\n\n    for (i = 1, x = 64; v >= x; i++, x <<= 6) {\n      /* nothing */\n    }\n\n    return i;\n  } // Return a 32-bit checksum of the array.\n\n\n  function checksum(arr) {\n    var sum0 = 0,\n        sum1 = 0,\n        sum2 = 0,\n        sum3 = 0,\n        z = 0,\n        N = arr.length; //TODO measure if this unrolling is helpful.\n\n    while (N >= 16) {\n      sum0 = sum0 + arr[z + 0] | 0;\n      sum1 = sum1 + arr[z + 1] | 0;\n      sum2 = sum2 + arr[z + 2] | 0;\n      sum3 = sum3 + arr[z + 3] | 0;\n      sum0 = sum0 + arr[z + 4] | 0;\n      sum1 = sum1 + arr[z + 5] | 0;\n      sum2 = sum2 + arr[z + 6] | 0;\n      sum3 = sum3 + arr[z + 7] | 0;\n      sum0 = sum0 + arr[z + 8] | 0;\n      sum1 = sum1 + arr[z + 9] | 0;\n      sum2 = sum2 + arr[z + 10] | 0;\n      sum3 = sum3 + arr[z + 11] | 0;\n      sum0 = sum0 + arr[z + 12] | 0;\n      sum1 = sum1 + arr[z + 13] | 0;\n      sum2 = sum2 + arr[z + 14] | 0;\n      sum3 = sum3 + arr[z + 15] | 0;\n      z += 16;\n      N -= 16;\n    }\n\n    while (N >= 4) {\n      sum0 = sum0 + arr[z + 0] | 0;\n      sum1 = sum1 + arr[z + 1] | 0;\n      sum2 = sum2 + arr[z + 2] | 0;\n      sum3 = sum3 + arr[z + 3] | 0;\n      z += 4;\n      N -= 4;\n    }\n\n    sum3 = ((sum3 + (sum2 << 8) | 0) + (sum1 << 16) | 0) + (sum0 << 24) | 0;\n    /* jshint -W086 */\n\n    switch (N) {\n      case 3:\n        sum3 = sum3 + (arr[z + 2] << 8) | 0;\n\n      /* falls through */\n\n      case 2:\n        sum3 = sum3 + (arr[z + 1] << 16) | 0;\n\n      /* falls through */\n\n      case 1:\n        sum3 = sum3 + (arr[z + 0] << 24) | 0;\n\n      /* falls through */\n    }\n\n    return sum3 >>> 0;\n  } // Create a new delta from src to out.\n\n\n  fossilDelta.create = function (src, out) {\n    var zDelta = new Writer();\n    var lenOut = out.length;\n    var lenSrc = src.length;\n    var i,\n        lastRead = -1;\n    zDelta.putInt(lenOut);\n    zDelta.putChar('\\n'); // If the source is very small, it means that we have no\n    // chance of ever doing a copy command.  Just output a single\n    // literal segment for the entire target and exit.\n\n    if (lenSrc <= NHASH) {\n      zDelta.putInt(lenOut);\n      zDelta.putChar(':');\n      zDelta.putArray(out, 0, lenOut);\n      zDelta.putInt(checksum(out));\n      zDelta.putChar(';');\n      return zDelta.toArray();\n    } // Compute the hash table used to locate matching sections in the source.\n\n\n    var nHash = Math.ceil(lenSrc / NHASH);\n    var collide = new Array(nHash);\n    var landmark = new Array(nHash);\n\n    for (i = 0; i < collide.length; i++) collide[i] = -1;\n\n    for (i = 0; i < landmark.length; i++) landmark[i] = -1;\n\n    var hv,\n        h = new RollingHash();\n\n    for (i = 0; i < lenSrc - NHASH; i += NHASH) {\n      h.init(src, i);\n      hv = h.value() % nHash;\n      collide[i / NHASH] = landmark[hv];\n      landmark[hv] = i / NHASH;\n    }\n\n    var base = 0;\n    var iSrc, iBlock, bestCnt, bestOfst, bestLitsz;\n\n    while (base + NHASH < lenOut) {\n      bestOfst = 0;\n      bestLitsz = 0;\n      h.init(out, base);\n      i = 0; // Trying to match a landmark against zOut[base+i]\n\n      bestCnt = 0;\n\n      while (1) {\n        var limit = 250;\n        hv = h.value() % nHash;\n        iBlock = landmark[hv];\n\n        while (iBlock >= 0 && limit-- > 0) {\n          //\n          // The hash window has identified a potential match against\n          // landmark block iBlock.  But we need to investigate further.\n          //\n          // Look for a region in zOut that matches zSrc. Anchor the search\n          // at zSrc[iSrc] and zOut[base+i].  Do not include anything prior to\n          // zOut[base] or after zOut[outLen] nor anything after zSrc[srcLen].\n          //\n          // Set cnt equal to the length of the match and set ofst so that\n          // zSrc[ofst] is the first element of the match.  litsz is the number\n          // of characters between zOut[base] and the beginning of the match.\n          // sz will be the overhead (in bytes) needed to encode the copy\n          // command.  Only generate copy command if the overhead of the\n          // copy command is less than the amount of literal text to be copied.\n          //\n          var cnt, ofst, litsz;\n          var j, k, x, y;\n          var sz; // Beginning at iSrc, match forwards as far as we can.\n          // j counts the number of characters that match.\n\n          iSrc = iBlock * NHASH;\n\n          for (j = 0, x = iSrc, y = base + i; x < lenSrc && y < lenOut; j++, x++, y++) {\n            if (src[x] !== out[y]) break;\n          }\n\n          j--; // Beginning at iSrc-1, match backwards as far as we can.\n          // k counts the number of characters that match.\n\n          for (k = 1; k < iSrc && k <= i; k++) {\n            if (src[iSrc - k] !== out[base + i - k]) break;\n          }\n\n          k--; // Compute the offset and size of the matching region.\n\n          ofst = iSrc - k;\n          cnt = j + k + 1;\n          litsz = i - k; // Number of bytes of literal text before the copy\n          // sz will hold the number of bytes needed to encode the \"insert\"\n          // command and the copy command, not counting the \"insert\" text.\n\n          sz = digitCount(i - k) + digitCount(cnt) + digitCount(ofst) + 3;\n\n          if (cnt >= sz && cnt > bestCnt) {\n            // Remember this match only if it is the best so far and it\n            // does not increase the file size.\n            bestCnt = cnt;\n            bestOfst = iSrc - k;\n            bestLitsz = litsz;\n          } // Check the next matching block\n\n\n          iBlock = collide[iBlock];\n        } // We have a copy command that does not cause the delta to be larger\n        // than a literal insert.  So add the copy command to the delta.\n\n\n        if (bestCnt > 0) {\n          if (bestLitsz > 0) {\n            // Add an insert command before the copy.\n            zDelta.putInt(bestLitsz);\n            zDelta.putChar(':');\n            zDelta.putArray(out, base, base + bestLitsz);\n            base += bestLitsz;\n          }\n\n          base += bestCnt;\n          zDelta.putInt(bestCnt);\n          zDelta.putChar('@');\n          zDelta.putInt(bestOfst);\n          zDelta.putChar(',');\n\n          if (bestOfst + bestCnt - 1 > lastRead) {\n            lastRead = bestOfst + bestCnt - 1;\n          }\n\n          bestCnt = 0;\n          break;\n        } // If we reach this point, it means no match is found so far\n\n\n        if (base + i + NHASH >= lenOut) {\n          // We have reached the end and have not found any\n          // matches.  Do an \"insert\" for everything that does not match\n          zDelta.putInt(lenOut - base);\n          zDelta.putChar(':');\n          zDelta.putArray(out, base, base + lenOut - base);\n          base = lenOut;\n          break;\n        } // Advance the hash by one character. Keep looking for a match.\n\n\n        h.next(out[base + i + NHASH]);\n        i++;\n      }\n    } // Output a final \"insert\" record to get all the text at the end of\n    // the file that does not match anything in the source.\n\n\n    if (base < lenOut) {\n      zDelta.putInt(lenOut - base);\n      zDelta.putChar(':');\n      zDelta.putArray(out, base, base + lenOut - base);\n    } // Output the final checksum record.\n\n\n    zDelta.putInt(checksum(out));\n    zDelta.putChar(';');\n    return zDelta.toArray();\n  }; // Return the size (in bytes) of the output from applying a delta.\n\n\n  fossilDelta.outputSize = function (delta) {\n    var zDelta = new Reader(delta);\n    var size = zDelta.getInt();\n    if (zDelta.getChar() !== '\\n') throw new Error('size integer not terminated by \\'\\\\n\\'');\n    return size;\n  }; // Apply a delta.\n\n\n  fossilDelta.apply = function (src, delta, opts) {\n    var limit,\n        total = 0;\n    var zDelta = new Reader(delta);\n    var lenSrc = src.length;\n    var lenDelta = delta.length;\n    limit = zDelta.getInt();\n    if (zDelta.getChar() !== '\\n') throw new Error('size integer not terminated by \\'\\\\n\\'');\n    var zOut = new Writer();\n\n    while (zDelta.haveBytes()) {\n      var cnt, ofst;\n      cnt = zDelta.getInt();\n\n      switch (zDelta.getChar()) {\n        case '@':\n          ofst = zDelta.getInt();\n          if (zDelta.haveBytes() && zDelta.getChar() !== ',') throw new Error('copy command not terminated by \\',\\'');\n          total += cnt;\n          if (total > limit) throw new Error('copy exceeds output file size');\n          if (ofst + cnt > lenSrc) throw new Error('copy extends past end of input');\n          zOut.putArray(src, ofst, ofst + cnt);\n          break;\n\n        case ':':\n          total += cnt;\n          if (total > limit) throw new Error('insert command gives an output larger than predicted');\n          if (cnt > lenDelta) throw new Error('insert count exceeds size of delta');\n          zOut.putArray(zDelta.a, zDelta.pos, zDelta.pos + cnt);\n          zDelta.pos += cnt;\n          break;\n\n        case ';':\n          var out = zOut.toArray();\n          if ((!opts || opts.verifyChecksum !== false) && cnt !== checksum(out)) throw new Error('bad checksum');\n          if (total !== limit) throw new Error('generated size does not match predicted size');\n          return out;\n\n        default:\n          throw new Error('unknown delta operator');\n      }\n    }\n\n    throw new Error('unterminated delta');\n  };\n\n  return fossilDelta;\n});","map":{"version":3,"sources":["/Users/bacchus/git/Leap/node_modules/fossil-delta/fossil-delta.js"],"names":["root","factory","module","exports","fossilDelta","NHASH","RollingHash","a","b","i","z","Array","prototype","init","pos","x","next","c","old","value","zDigits","split","map","charCodeAt","zValue","Reader","array","haveBytes","length","getByte","RangeError","getChar","String","fromCharCode","getInt","v","Writer","toArray","putByte","push","putChar","s","putInt","j","zBuf","putArray","start","end","digitCount","checksum","arr","sum0","sum1","sum2","sum3","N","create","src","out","zDelta","lenOut","lenSrc","lastRead","nHash","Math","ceil","collide","landmark","hv","h","base","iSrc","iBlock","bestCnt","bestOfst","bestLitsz","limit","cnt","ofst","litsz","k","y","sz","outputSize","delta","size","Error","apply","opts","total","lenDelta","zOut","verifyChecksum"],"mappings":"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","sourcesContent":["// Fossil SCM delta compression algorithm\n// ======================================\n//\n// Format:\n// http://www.fossil-scm.org/index.html/doc/tip/www/delta_format.wiki\n//\n// Algorithm:\n// http://www.fossil-scm.org/index.html/doc/tip/www/delta_encoder_algorithm.wiki\n//\n// Original implementation:\n// http://www.fossil-scm.org/index.html/artifact/d1b0598adcd650b3551f63b17dfc864e73775c3d\n//\n// LICENSE\n// -------\n//\n// Copyright 2014 Dmitry Chestnykh (JavaScript port)\n// Copyright 2007 D. Richard Hipp  (original C version)\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the\n// following conditions are met:\n//\n//   1. Redistributions of source code must retain the above\n//      copyright notice, this list of conditions and the\n//      following disclaimer.\n//\n//   2. Redistributions in binary form must reproduce the above\n//      copyright notice, this list of conditions and the\n//      following disclaimer in the documentation and/or other\n//      materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS\n// OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n// BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n// OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// The views and conclusions contained in the software and documentation\n// are those of the authors and contributors and should not be interpreted\n// as representing official policies, either expressed or implied, of anybody\n// else.\n//\n(function(root, factory) {\n  if (typeof module !== 'undefined' && module.exports) module.exports = factory();\n  else root.fossilDelta = factory();\n})(this, function() {\n'use strict';\n\nvar fossilDelta = {};\n\n// Hash window width in bytes. Must be a power of two.\nvar NHASH = 16;\n\nfunction RollingHash() {\n  this.a = 0; // hash     (16-bit unsigned)\n  this.b = 0; // values   (16-bit unsigned)\n  this.i = 0; // start of the hash window (16-bit unsigned)\n  this.z = new Array(NHASH); // the values that have been hashed.\n}\n\n// Initialize the rolling hash using the first NHASH bytes of\n// z at the given position.\nRollingHash.prototype.init = function(z, pos) {\n  var a = 0, b = 0, i, x;\n  for(i = 0; i < NHASH; i++){\n    x = z[pos+i];\n    a = (a + x) & 0xffff;\n    b = (b + (NHASH-i)*x) & 0xffff;\n    this.z[i] = x;\n  }\n  this.a = a & 0xffff;\n  this.b = b & 0xffff;\n  this.i = 0;\n};\n\n// Advance the rolling hash by a single byte \"c\".\nRollingHash.prototype.next = function(c) {\n  var old = this.z[this.i];\n  this.z[this.i] = c;\n  this.i = (this.i+1)&(NHASH-1);\n  this.a = (this.a - old + c) & 0xffff;\n  this.b = (this.b - NHASH*old + this.a) & 0xffff;\n};\n\n// Return a 32-bit hash value.\nRollingHash.prototype.value = function() {\n  return ((this.a & 0xffff) | (this.b & 0xffff)<<16)>>>0;\n};\n\nvar zDigits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~\".\n                split('').map(function (x) { return x.charCodeAt(0); });\n\nvar zValue = [\n  -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,\n   0,  1,  2,  3,  4,  5,  6,  7,    8,  9, -1, -1, -1, -1, -1, -1,\n  -1, 10, 11, 12, 13, 14, 15, 16,   17, 18, 19, 20, 21, 22, 23, 24,\n  25, 26, 27, 28, 29, 30, 31, 32,   33, 34, 35, -1, -1, -1, -1, 36,\n  -1, 37, 38, 39, 40, 41, 42, 43,   44, 45, 46, 47, 48, 49, 50, 51,\n  52, 53, 54, 55, 56, 57, 58, 59,   60, 61, 62, -1, -1, -1, 63, -1\n];\n\n// Reader reads bytes, chars, ints from array.\nfunction Reader(array) {\n  this.a = array; // source array\n  this.pos = 0;   // current position in array\n}\n\nReader.prototype.haveBytes = function() {\n  return this.pos < this.a.length;\n};\n\nReader.prototype.getByte = function() {\n  var b = this.a[this.pos];\n  this.pos++;\n  if (this.pos > this.a.length) throw new RangeError('out of bounds');\n  return b;\n};\n\nReader.prototype.getChar = function() {\n  return String.fromCharCode(this.getByte());\n};\n\n// Read base64-encoded unsigned integer.\nReader.prototype.getInt = function(){\n  var v = 0, c;\n  while(this.haveBytes() && (c = zValue[0x7f & this.getByte()]) >= 0) {\n     v = (v<<6) + c;\n  }\n  this.pos--;\n  return v >>> 0;\n};\n\n\n// Write writes an array.\nfunction Writer() {\n  this.a = [];\n}\n\nWriter.prototype.toArray = function() {\n  return this.a;\n};\n\nWriter.prototype.putByte = function(b) {\n  this.a.push(b & 0xff);\n};\n\n// Write an ASCII character (s is a one-char string).\nWriter.prototype.putChar = function(s) {\n  this.putByte(s.charCodeAt(0));\n};\n\n// Write a base64 unsigned integer.\nWriter.prototype.putInt = function(v){\n  var i, j, zBuf = [];\n  if (v === 0) {\n    this.putChar('0');\n    return;\n  }\n  for (i = 0; v > 0; i++, v >>>= 6)\n    zBuf.push(zDigits[v&0x3f]);\n  for (j = i-1; j >= 0; j--)\n    this.putByte(zBuf[j]);\n};\n\n// Copy from array at start to end.\nWriter.prototype.putArray = function(a, start, end) {\n  for (var i = start; i < end; i++) this.a.push(a[i]);\n};\n\n// Return the number digits in the base64 representation of a positive integer.\nfunction digitCount(v){\n  var i, x;\n  for (i = 1, x = 64; v >= x; i++, x <<= 6){ /* nothing */ }\n  return i;\n}\n\n// Return a 32-bit checksum of the array.\nfunction checksum(arr) {\n  var sum0 = 0, sum1 = 0, sum2 = 0, sum3 = 0,\n      z = 0, N = arr.length;\n  //TODO measure if this unrolling is helpful.\n  while (N >= 16) {\n    sum0 = sum0 + arr[z+0] | 0;\n    sum1 = sum1 + arr[z+1] | 0;\n    sum2 = sum2 + arr[z+2] | 0;\n    sum3 = sum3 + arr[z+3] | 0;\n\n    sum0 = sum0 + arr[z+4] | 0;\n    sum1 = sum1 + arr[z+5] | 0;\n    sum2 = sum2 + arr[z+6] | 0;\n    sum3 = sum3 + arr[z+7] | 0;\n\n    sum0 = sum0 + arr[z+8] | 0;\n    sum1 = sum1 + arr[z+9] | 0;\n    sum2 = sum2 + arr[z+10] | 0;\n    sum3 = sum3 + arr[z+11] | 0;\n\n    sum0 = sum0 + arr[z+12] | 0;\n    sum1 = sum1 + arr[z+13] | 0;\n    sum2 = sum2 + arr[z+14] | 0;\n    sum3 = sum3 + arr[z+15] | 0;\n\n    z += 16;\n    N -= 16;\n  }\n  while (N >= 4) {\n    sum0 = sum0 + arr[z+0] | 0;\n    sum1 = sum1 + arr[z+1] | 0;\n    sum2 = sum2 + arr[z+2] | 0;\n    sum3 = sum3 + arr[z+3] | 0;\n    z += 4;\n    N -= 4;\n  }\n  sum3 = (((sum3 + (sum2 << 8) | 0) + (sum1 << 16) | 0) + (sum0 << 24) | 0);\n  /* jshint -W086 */\n  switch (N) {\n    case 3: sum3 = sum3 + (arr[z+2] <<  8) | 0; /* falls through */\n    case 2: sum3 = sum3 + (arr[z+1] << 16) | 0; /* falls through */\n    case 1: sum3 = sum3 + (arr[z+0] << 24) | 0; /* falls through */\n  }\n  return sum3 >>> 0;\n}\n\n// Create a new delta from src to out.\nfossilDelta.create = function(src, out) {\n  var zDelta = new Writer();\n  var lenOut = out.length;\n  var lenSrc = src.length;\n  var i, lastRead = -1;\n\n  zDelta.putInt(lenOut);\n  zDelta.putChar('\\n');\n\n  // If the source is very small, it means that we have no\n  // chance of ever doing a copy command.  Just output a single\n  // literal segment for the entire target and exit.\n  if (lenSrc <= NHASH) {\n    zDelta.putInt(lenOut);\n    zDelta.putChar(':');\n    zDelta.putArray(out, 0, lenOut);\n    zDelta.putInt(checksum(out));\n    zDelta.putChar(';');\n    return zDelta.toArray();\n  }\n\n  // Compute the hash table used to locate matching sections in the source.\n  var nHash = Math.ceil(lenSrc / NHASH);\n  var collide =  new Array(nHash);\n  var landmark = new Array(nHash);\n  for (i = 0; i < collide.length; i++) collide[i] = -1;\n  for (i = 0; i < landmark.length; i++) landmark[i] = -1;\n  var hv, h = new RollingHash();\n  for (i = 0; i < lenSrc-NHASH; i += NHASH) {\n    h.init(src, i);\n    hv = h.value() % nHash;\n    collide[i/NHASH] = landmark[hv];\n    landmark[hv] = i/NHASH;\n  }\n\n  var base = 0;\n  var iSrc, iBlock, bestCnt, bestOfst, bestLitsz;\n  while (base+NHASH<lenOut) {\n    bestOfst=0;\n    bestLitsz=0;\n    h.init(out, base);\n    i = 0; // Trying to match a landmark against zOut[base+i]\n    bestCnt = 0;\n    while(1) {\n      var limit = 250;\n      hv = h.value() % nHash;\n      iBlock = landmark[hv];\n      while (iBlock >= 0 && (limit--)>0 ) {\n        //\n        // The hash window has identified a potential match against\n        // landmark block iBlock.  But we need to investigate further.\n        //\n        // Look for a region in zOut that matches zSrc. Anchor the search\n        // at zSrc[iSrc] and zOut[base+i].  Do not include anything prior to\n        // zOut[base] or after zOut[outLen] nor anything after zSrc[srcLen].\n        //\n        // Set cnt equal to the length of the match and set ofst so that\n        // zSrc[ofst] is the first element of the match.  litsz is the number\n        // of characters between zOut[base] and the beginning of the match.\n        // sz will be the overhead (in bytes) needed to encode the copy\n        // command.  Only generate copy command if the overhead of the\n        // copy command is less than the amount of literal text to be copied.\n        //\n        var cnt, ofst, litsz;\n        var j, k, x, y;\n        var sz;\n\n        // Beginning at iSrc, match forwards as far as we can.\n        // j counts the number of characters that match.\n        iSrc = iBlock*NHASH;\n        for (j = 0, x = iSrc, y = base+i; x < lenSrc && y < lenOut; j++, x++, y++) {\n          if (src[x] !== out[y]) break;\n        }\n        j--;\n\n        // Beginning at iSrc-1, match backwards as far as we can.\n        // k counts the number of characters that match.\n        for (k = 1; k < iSrc && k <= i; k++) {\n          if (src[iSrc-k] !== out[base+i-k]) break;\n        }\n        k--;\n\n        // Compute the offset and size of the matching region.\n        ofst = iSrc-k;\n        cnt = j+k+1;\n        litsz = i-k;  // Number of bytes of literal text before the copy\n        // sz will hold the number of bytes needed to encode the \"insert\"\n        // command and the copy command, not counting the \"insert\" text.\n        sz = digitCount(i-k)+digitCount(cnt)+digitCount(ofst)+3;\n        if (cnt >= sz && cnt > bestCnt) {\n          // Remember this match only if it is the best so far and it\n          // does not increase the file size.\n          bestCnt = cnt;\n          bestOfst = iSrc-k;\n          bestLitsz = litsz;\n        }\n\n        // Check the next matching block\n        iBlock = collide[iBlock];\n      }\n\n      // We have a copy command that does not cause the delta to be larger\n      // than a literal insert.  So add the copy command to the delta.\n      if (bestCnt > 0) {\n        if (bestLitsz > 0) {\n          // Add an insert command before the copy.\n          zDelta.putInt(bestLitsz);\n          zDelta.putChar(':');\n          zDelta.putArray(out, base, base+bestLitsz);\n          base += bestLitsz;\n        }\n        base += bestCnt;\n        zDelta.putInt(bestCnt);\n        zDelta.putChar('@');\n        zDelta.putInt(bestOfst);\n        zDelta.putChar(',');\n        if (bestOfst + bestCnt -1 > lastRead) {\n          lastRead = bestOfst + bestCnt - 1;\n        }\n        bestCnt = 0;\n        break;\n      }\n\n      // If we reach this point, it means no match is found so far\n      if (base+i+NHASH >= lenOut){\n        // We have reached the end and have not found any\n        // matches.  Do an \"insert\" for everything that does not match\n        zDelta.putInt(lenOut-base);\n        zDelta.putChar(':');\n        zDelta.putArray(out, base, base+lenOut-base);\n        base = lenOut;\n        break;\n      }\n\n      // Advance the hash by one character. Keep looking for a match.\n      h.next(out[base+i+NHASH]);\n      i++;\n    }\n  }\n  // Output a final \"insert\" record to get all the text at the end of\n  // the file that does not match anything in the source.\n  if(base < lenOut) {\n    zDelta.putInt(lenOut-base);\n    zDelta.putChar(':');\n    zDelta.putArray(out, base, base+lenOut-base);\n  }\n  // Output the final checksum record.\n  zDelta.putInt(checksum(out));\n  zDelta.putChar(';');\n  return zDelta.toArray();\n};\n\n// Return the size (in bytes) of the output from applying a delta.\nfossilDelta.outputSize = function(delta){\n  var zDelta = new Reader(delta);\n  var size = zDelta.getInt();\n  if (zDelta.getChar() !== '\\n')\n    throw new Error('size integer not terminated by \\'\\\\n\\'');\n  return size;\n};\n\n// Apply a delta.\nfossilDelta.apply = function(src, delta, opts) {\n  var limit, total = 0;\n  var zDelta = new Reader(delta);\n  var lenSrc = src.length;\n  var lenDelta = delta.length;\n\n  limit = zDelta.getInt();\n  if (zDelta.getChar() !== '\\n')\n    throw new Error('size integer not terminated by \\'\\\\n\\'');\n  var zOut = new Writer();\n  while(zDelta.haveBytes()) {\n    var cnt, ofst;\n    cnt = zDelta.getInt();\n\n    switch (zDelta.getChar()) {\n      case '@':\n        ofst = zDelta.getInt();\n        if (zDelta.haveBytes() && zDelta.getChar() !== ',')\n          throw new Error('copy command not terminated by \\',\\'');\n        total += cnt;\n        if (total > limit)\n          throw new Error('copy exceeds output file size');\n        if (ofst+cnt > lenSrc)\n          throw new Error('copy extends past end of input');\n        zOut.putArray(src, ofst, ofst+cnt);\n        break;\n\n      case ':':\n        total += cnt;\n        if (total > limit)\n          throw new Error('insert command gives an output larger than predicted');\n        if (cnt > lenDelta)\n          throw new Error('insert count exceeds size of delta');\n        zOut.putArray(zDelta.a, zDelta.pos, zDelta.pos+cnt);\n        zDelta.pos += cnt;\n        break;\n\n      case ';':\n        var out = zOut.toArray();\n        if ((!opts || opts.verifyChecksum !== false) && cnt !== checksum(out))\n          throw new Error('bad checksum');\n        if (total !== limit)\n          throw new Error('generated size does not match predicted size');\n        return out;\n\n      default:\n        throw new Error('unknown delta operator');\n    }\n  }\n  throw new Error('unterminated delta');\n};\n\nreturn fossilDelta;\n\n});\n"]},"metadata":{},"sourceType":"script"}