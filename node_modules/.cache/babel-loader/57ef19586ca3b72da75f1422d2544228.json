{"ast":null,"code":"import { cellType, phaseLayouts } from './util';\n/*\n\nREFACTOR CHANGES:\nLeap.js -> Game.js\n\t<Leap> -> <GameController>\nboard.js -> leap.js\n\n\nBITWISE:\n\nBOARD:\nbit\t\t\t\titem\n0-1\t\t\t\tcellType\t{regular, phase} x {highlight, no highlight}\n2-3\t\t\tcellState\t\t{00: empty, 10: SPECIAL, 01: p1, 11: p2, }   NOTE, if '10' for bits 1 and 2, then it should be a SPECIAL THING???  lmao what if a piece can be moved by either player for a few turns?\n4\t\t\t\t\tisCloned\n5-9\t\t\t\tkey\t\t\t\tIf piece on cell, this is index to reach it\n\nboard[i] = (key << 4 | isCloned << 3 | cellState << 1 | cellType);\nfor i = row * SIZE + col \t\twhere row, col wtr a given piece\n\nPIECE INDEX:\nbit \t\t\titem\n0-2\t\t\t\tcol\n3-(5,6)\t\trow\n\nboard[i] = (row << 4 | col);\nfor i = SIZE*SIZE + key\t\t\twhere\n\n\nhow to store moves\nmoves[i] = [ 0 <= board_index < SIZE*SIZE, ... , ... ] all possible moves for associated piece.\nfor i = SIZE*SIZE\n\n\nindex = cell number\nkey = piece index\n\n*/\n\nconst toIndex = (row, col) => (row << BIT_SHIFT) + col;\n\nconst getRow = index => index >> BIT_SHIFT;\n\nconst getCol = index => index & BIT_LENGTH - 1;\n\nfunction getBitShift(b) {\n  return b >> 1 ? 1 + getBitShift(b >> 1) : 0;\n}\n\nvar BOARD_SIZE, BOARD_AREA, BIT_SHIFT, BIT_LENGTH, BIT_AREA;\n\nfunction Board(len, phaseLayout) {\n  this.p1 = 4;\n  this.p2 = 12;\n  BOARD_SIZE = len;\n  BOARD_AREA = BOARD_SIZE ** 2;\n  BIT_SHIFT = getBitShift(BOARD_SIZE);\n  BIT_LENGTH = 2 ** BIT_SHIFT;\n  BIT_AREA = 2 ** BIT_LENGTH;\n  (this.board = []).length = BOARD_AREA;\n  (this.moves = []).length = 4 * len;\n  this.board.fill(0);\n  this.bufferSize = 1; //how many rows between the pieces' starting location and the nearest phases\n\n  this.init(phaseLayout); //this.update();\n}\n\nBoard.prototype.init = function (layout) {\n  let pi = 0; //piece Index (ID)\n\n  const len = BOARD_SIZE;\n\n  const calcPhases = index => {\n    let k = 0;\n\n    while (k < phaseLayouts[layout].length) {\n      if ((index ^ phaseLayouts[layout][k]) === 0) return 1;\n      k++;\n    }\n\n    return 0;\n  };\n\n  for (let i = 0; i < len; i++) {\n    this.board[i] = pi << 5 | this.p1; //00000 0 01 00\n\n    this.initPiece(pi);\n    this.board[i + (len - 1) * len] = pi + 2 * BIT_LENGTH << 5 | this.p2; //100000 0 11 00\n\n    this.initPiece(pi + 2 * len);\n    pi++;\n\n    for (let j = 1 + this.bufferSize; j < len - 1 - this.bufferSize; j++) {\n      this.board[i + j * len] |= calcPhases(i + j * len);\n    }\n  }\n};\n\nBoard.prototype.initPiece = function (pi) {\n  this.moves[pi] = [];\n};\n\nBoard.prototype.getPlayer = function (index) {\n  let pid = this.board[index] & 12;\n\n  switch (pid) {\n    case 12:\n      return this.p2;\n\n    case 4:\n      return this.p1;\n\n    default:\n      return 0;\n  } //return ( (this.board[index] & 12) < 12 ) ? this.p1 : this.p2;\n\n};\n\nBoard.prototype.getCapturedPiece = function (pid, to) {\n  let nMoves = this.moves[pid].length;\n\n  for (let i = 0; i < nMoves; i++) {\n    let move = this.moves[pid][i];\n    if ((move & BIT_AREA - 1) === to) return move >> BIT_LENGTH + 1;\n  }\n}; // moves[pi] = [0000000 0000000] --> [board index of captured piece + board index of destination cell]\n\n\nBoard.prototype.addMove = function (from, to, captured) {\n  captured = captured || 0;\n  let pi = this.board[from] >> 5;\n  this.moves[pi].push((captured << BIT_LENGTH + 1) + to);\n};\n\nBoard.prototype.update = function (newPiece) {\n  if (newPiece) {\n    //find out which player this piece belongs to then add it within that player's key range (00000)\n    this.board = this.board.map(row => row.map((cell, j) => {\n      if (cell.who != null) {\n        //increment all pi in board after piecesSeparator by one\n        if (cell.who >= this.piecesSeparator) cell.who++; //if piece alive, keep on board\n\n        return this.pieces[cell.who].alive ? {\n          who: cell.who,\n          move: false\n        } : {\n          who: null,\n          move: false\n        };\n      } else return {\n        who: null,\n        move: false\n      };\n    }));\n  } else {\n    this.board = this.board.map(row => row.map((cell, j) => cell.who != null ? this.pieces[cell.who].alive ? {\n      who: cell.who,\n      move: false\n    } : {\n      who: null,\n      move: false\n    } : {\n      who: null,\n      move: false\n    }));\n  }\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n\nBoard.prototype.makeClone = function (pi, row, col) {\n  /*\n  getPlayer bit\n  */\n  this.board[row * BOARD_SIZE + col] |= this.getPlayer(row, col);\n  this.updateBoard(true);\n  this.board[row][col].who = this.piecesSeparator;\n  return true;\n};\n\nBoard.prototype.canClone = function (from) {\n  let onRow = from / BOARD_SIZE,\n      piece = this.board[from];\n  let onBoundaryColumn = (from + 1) % BOARD_SIZE < 2;\n  let onBoundaryRow = (onRow + 1) % BOARD_SIZE < 2; //To clone: NOT be on boundary column, BE on boundary row, NOT be cloned yet\n\n  if (onBoundaryColumn || !onBoundaryRow || piece ^ 16) return false;\n  let spawnRow = ((piece >> 5 & 2 * BIT_LENGTH) - 1) / 2;\n  return onRow ^ spawnRow;\n}; //Assumes valid move\n\n\nBoard.prototype.isCloneMove = function (to, from) {\n  //suffice to show if to and from are on opposing boundary rows\n  let toRow = to / BOARD_SIZE,\n      fromRow = from / BOARD_SIZE;\n  return this.canClone(from) && toRow ^ fromRow;\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n// Board.prototype.getPlayer = function (pi) {\n// \treturn this.pieces[pi].player;\n// }\n\n\nBoard.prototype.canLeap = function (from, adj, isPhase, bypassCondition) {\n  let to = this.getInverseIndex(from);\n\n  if (isPhase && !this.getPlayer(to)) {\n    let inv = this.getInverseIndex(adj);\n    let phaseAdj = this.getPlayer(adj) & 8;\n    let phaseFar = this.getPlayer(inv) & 8;\n\n    if (phaseAdj ^ phaseFar) {\n      if (bypassCondition) return true;\n      let captured = phaseAdj ? adj : inv;\n      this.addMove(from, to, captured);\n    }\n  } //if neighbor cell is a phase, leap_cell clear, and (enemy piece on phaseAdj XOR enemy piece on phaseFar)\n\n};\n\nBoard.prototype.isJump = function (from, adj, direction, bypassCondition) {\n  //if adj cell occupied, jumpCell in bounds, jumpCell clear, and jumpCell has enemy piece\n  let to = adj + direction;\n\n  if (this.inBounds(to)) {\n    if (!this.getPlayer(to)) {\n      if (bypassCondition % 3) return true;else this.addMove(from, to, adj);\n    }\n  }\n};\n\nBoard.prototype.canPhase = function (from, to, bypassCondition) {\n  //j = 7-row_index + 7-col_index\n  //let to = ( (len - row) << BIT_SHIFT ) + (len - col);\n  let isPhase = this.board[to] & 1;\n  let isDestinationEmpty = this.board[from] & 3; //1 if player piece\n\n  if (isPhase && isDestinationEmpty) {\n    if (bypassCondition % 3) return true;else this.addMove(from, to);\n  }\n}; //reaching this function implies selected piece can be cloned, so piece is on an bounding row\n\n\nBoard.prototype.getCloneSpawnCells = function (from, bypassCondition) {\n  let spawnRow = from / BOARD_SIZE ^ BIT_LENGTH - 1;\n\n  for (let col = 1; col < 7; col++) {\n    let to = spawnRow + col;\n    let spawnCell = this.board[to]; //if spawnCell doesn't have a player on it\n\n    if (spawnCell ^ 4) {\n      if (bypassCondition % 3) return true;else this.addMove(from, to);\n    }\n  }\n};\n\nBoard.prototype.getMovesInDirection = function (from, adj, bypassCondition) {\n  //check adjacent cells of piece p wrt the boundary\n  let direction = adj - from;\n  let isPhase = this.board[adj] & 1;\n  if (this.canLeap(from, adj, isPhase, bypassCondition)) return true;\n\n  if (this.getPlayer(adj)) {\n    if (this.isJump(from, adj, direction, bypassCondition)) return true;\n  } else if (bypassCondition % 3 % 2) return true; //adjacent moves\n  else if (!bypassCondition) this.addMove(from, adj);\n\n  return false;\n};\n/* bypassCondition (HIGHLIGHT BYPASS CONDITION):\n\t\tundefined - default (Store all),\n\t\t1 - bypass all,\n\t\t2 - bypass continuable moves,\n\t\t3 - store continuable moves\n*/\n\n\nBoard.prototype.getMoves = function (from, bypassCondition, r, c) {\n  let row = getRow(from),\n      col = getCol(from); // move continuation AND has a move in specified direction\n\n  if (bypassCondition === 2 && this.getMovesInDirection(from, toIndex(row + r, col + c), bypassCondition)) return true; // on a phase\n\n  if (this.canPhase(from, this.getInverseIndex(from), bypassCondition)) return true; // able to clone\n\n  if (this.canClone(from) && this.getCloneSpawnCells(from, bypassCondition)) return true; //step, jump, leap\n\n  for (r = -1; r < 2; r++) for (c = -1; c < 2; c++) {\n    let adj = toIndex(row + r, col + c);\n    let validDirection = this.getPlayer(adj) ^ this.getPlayer(from) && //enemy or empty cell\n    this.inBounds(adj) && adj - from;\n    if (validDirection && this.getMovesInDirection(from, adj, bypassCondition)) return true;\n  }\n\n  return false;\n}; //Performs move. returns true if caught piece in process, else false\n//NOTE: it is impossible to capture a piece at board index 0\n\n\nBoard.prototype.doMove = function (from, to) {\n  if (this.isCloneMove(from, to)) {\n    this.makeClone(to);\n    return false;\n  }\n\n  let capturedPiece = getCapturedPiece;\n  let p = this.pieces[pi]; //begin move\n\n  this.board[p.row][p.col].who = null;\n  let destinationCell = this.board[row][col];\n  let caught = typeof destinationCell.move === \"number\" ? destinationCell.move : false; //caught piece index\n  // moveDirection is defined if and only if any of the following is true (for moving piece p):\n\n  let moveDirection; // (1) p caught a piece\n\n  if (caught) {\n    let c = this.pieces[caught];\n    c.alive = false;\n    this.board[c.row][c.col].who = null; //return direction of move\n    //If leap, then c adjacent at start XOR c adjacent at end\n    //Check adjacency of moving piece to captured piece on starting position and ending position\n\n    let cellAdjStartPos = Math.abs(c.row - p.row) < 2 && Math.abs(c.col - p.col) < 2;\n    let cellAdjEndPos = Math.abs(row - c.row) < 2 && Math.abs(col - c.col) < 2;\n    moveDirection = cellAdjStartPos && cellAdjEndPos ? {\n      rowIncr: Math.sign(row - c.row),\n      colIncr: Math.sign(col - c.col)\n    } //jump\n    : cellAdjStartPos ? {\n      rowIncr: Math.sign(c.row - p.row),\n      colIncr: Math.sign(c.col - p.row)\n    } //leap-> piece adj to capture on start\n    : {\n      rowIncr: Math.sign(row - c.row),\n      colIncr: Math.sign(col - c.col)\n    };\n  } // (2) p LANDS on a phase cell. That is, this move is not a phase.\n  else if (!this.samePhase(p, {\n      row: row,\n      col: col\n    })) moveDirection = {\n      rowIncr: 0,\n      colIncr: 0\n    }; //end move\n\n\n  this.board[row][col].who = pi;\n  p.row = row;\n  p.col = col; // (3) p is able to be cloned\n\n  if (this.canClone(pi)) moveDirection = {\n    rowIncr: 0,\n    colIncr: 0\n  };\n  this.updateBoard();\n  return moveDirection;\n};\n\nBoard.prototype.highlightMoves = function (piece) {\n  let nMoves = this.moves[piece].length;\n\n  for (let i = 0; i < nMoves; i++) {\n    let destinationIndex = this.moves[piece][i] & BIT_AREA - 1;\n    this.board[destinationIndex] |= 2;\n  }\n};\n\nBoard.prototype.removeHighlight = function () {\n  for (let i = 0; i < BOARD_AREA; i++) {\n    if (this.board[i] & 2) this.board[i] = this.board[i] ^ 2;\n  }\n};\n/*==========\t\t\t\t\t\t\t\t\t\t\tINTEGRITY\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n\nBoard.prototype.getInverseIndex = function (index) {\n  let len = BOARD_SIZE - 1;\n  let row = getRow(index),\n      col = getCol(index);\n  return toIndex(len - row, len - col);\n}; //Don't need -> can use dest cell shit\n\n\nBoard.prototype.samePhase = function (from, to) {\n  let isDestinationPhase = cellType(to.row, to.col);\n  return isDestinationPhase > 1 && isDestinationPhase === cellType(from.row, from.col);\n};\n\nBoard.prototype.inBounds = function (index) {\n  return 0 <= index && index < BOARD_AREA;\n};\n\nBoard.prototype.canContinueMove = function (pi, dir) {\n  return dir ? this.getMoves(pi, 2, dir.rowIncr, dir.colIncr) : false;\n};\n\nBoard.prototype.hasMoves = function (pi) {\n  return this.getMoves(pi, 1);\n}; //Player has no more moves when (1): all player's pieces are dead (2): every piece has no moves\n\n\nBoard.prototype.movesLeft = function (player) {\n  for (let pi = 0; pi < this.pieces.length; pi++) {\n    let p = this.pieces[pi];\n\n    if (p.alive && p.player === player) {\n      if (this.hasMoves(pi)) return true;\n    }\n  }\n\n  return false;\n};\n\nBoard.prototype.validMove = function (piece, index) {\n  let n = this.moves[piece].length;\n  let isAvailableMove = 0;\n\n  for (let i = 0; i < n; i++) {\n    if ((this.moves[piece][i] & BIT_AREA - 1) === index) isAvailableMove++;\n  }\n\n  return !!isAvailableMove;\n};\n\nexport default Board;","map":{"version":3,"sources":["/Users/bacchus/git/Leap/src/js/board.js"],"names":["cellType","phaseLayouts","toIndex","row","col","BIT_SHIFT","getRow","index","getCol","BIT_LENGTH","getBitShift","b","BOARD_SIZE","BOARD_AREA","BIT_AREA","Board","len","phaseLayout","p1","p2","board","length","moves","fill","bufferSize","init","prototype","layout","pi","calcPhases","k","i","initPiece","j","getPlayer","pid","getCapturedPiece","to","nMoves","move","addMove","from","captured","push","update","newPiece","map","cell","who","piecesSeparator","pieces","alive","makeClone","updateBoard","canClone","onRow","piece","onBoundaryColumn","onBoundaryRow","spawnRow","isCloneMove","toRow","fromRow","canLeap","adj","isPhase","bypassCondition","getInverseIndex","inv","phaseAdj","phaseFar","isJump","direction","inBounds","canPhase","isDestinationEmpty","getCloneSpawnCells","spawnCell","getMovesInDirection","getMoves","r","c","validDirection","doMove","capturedPiece","p","destinationCell","caught","moveDirection","cellAdjStartPos","Math","abs","cellAdjEndPos","rowIncr","sign","colIncr","samePhase","highlightMoves","destinationIndex","removeHighlight","isDestinationPhase","canContinueMove","dir","hasMoves","movesLeft","player","validMove","n","isAvailableMove"],"mappings":"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","sourcesContent":["import {cellType, phaseLayouts} from './util';\n/*\n\nREFACTOR CHANGES:\nLeap.js -> Game.js\n\t<Leap> -> <GameController>\nboard.js -> leap.js\n\n\nBITWISE:\n\nBOARD:\nbit\t\t\t\titem\n0-1\t\t\t\tcellType\t{regular, phase} x {highlight, no highlight}\n2-3\t\t\tcellState\t\t{00: empty, 10: SPECIAL, 01: p1, 11: p2, }   NOTE, if '10' for bits 1 and 2, then it should be a SPECIAL THING???  lmao what if a piece can be moved by either player for a few turns?\n4\t\t\t\t\tisCloned\n5-9\t\t\t\tkey\t\t\t\tIf piece on cell, this is index to reach it\n\nboard[i] = (key << 4 | isCloned << 3 | cellState << 1 | cellType);\nfor i = row * SIZE + col \t\twhere row, col wtr a given piece\n\nPIECE INDEX:\nbit \t\t\titem\n0-2\t\t\t\tcol\n3-(5,6)\t\trow\n\nboard[i] = (row << 4 | col);\nfor i = SIZE*SIZE + key\t\t\twhere\n\n\nhow to store moves\nmoves[i] = [ 0 <= board_index < SIZE*SIZE, ... , ... ] all possible moves for associated piece.\nfor i = SIZE*SIZE\n\n\nindex = cell number\nkey = piece index\n\n*/\nconst toIndex = (row, col) => (row << BIT_SHIFT) + col;\n\nconst getRow = (index) => (index >> BIT_SHIFT);\nconst getCol = (index) => (index & (BIT_LENGTH-1));\n\nfunction getBitShift(b) {\n  return (b >> 1) ? (1 + getBitShift(b >> 1)) : 0;\n}\nvar BOARD_SIZE, BOARD_AREA, BIT_SHIFT, BIT_LENGTH, BIT_AREA;\n\nfunction Board(len, phaseLayout) {\n\n\tthis.p1 = 4;\n\tthis.p2 = 12;\n\n\tBOARD_SIZE = len;\n\tBOARD_AREA = BOARD_SIZE**2;\n\tBIT_SHIFT = getBitShift(BOARD_SIZE);\n\tBIT_LENGTH = 2**BIT_SHIFT;\n\tBIT_AREA = 2**BIT_LENGTH;\n\n\n\t(this.board = []).length = BOARD_AREA;\n\t(this.moves = []).length = 4*len;\n\tthis.board.fill(0);\n\tthis.bufferSize = 1;\t//how many rows between the pieces' starting location and the nearest phases\n\tthis.init(phaseLayout);\n\t//this.update();\n}\n\n\n\nBoard.prototype.init = function (layout) {\n    let pi=0; //piece Index (ID)\n\t\tconst len = BOARD_SIZE;\n\n\t\tconst calcPhases = (index) => {\n\t\t\tlet k = 0;\n\t\t\twhile(k<phaseLayouts[layout].length) {\n\t\t\t\tif ( (index^phaseLayouts[layout][k]) === 0 ) return 1;\n\t\t\t\tk++;\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\n\t\tfor(let i=0; i<len; i++) {\n\t\t\tthis.board[i] = ( (pi << 5) | this.p1); //00000 0 01 00\n\t\t\tthis.initPiece(pi);\n\t\t\tthis.board[i + (len-1)*len] = ( (pi + 2*BIT_LENGTH << 5) | this.p2); //100000 0 11 00\n\t\t\tthis.initPiece(pi + 2*len);\n\t\t\tpi++;\n\n\t\t\tfor(let j=1+this.bufferSize; j<len-1-this.bufferSize; j++) {\n\t\t\t\tthis.board[i + j*len] |= calcPhases(i+j*len);\n\t\t\t}\n\t\t}\n}\n\nBoard.prototype.initPiece = function (pi) {\n\tthis.moves[pi] = [];\n}\n\nBoard.prototype.getPlayer = function (index) {\n\tlet pid = (this.board[index] & 12);\n\tswitch (pid) {\n\t\tcase 12:\n\t\t\treturn this.p2;\n\t\tcase 4:\n\t\t\treturn this.p1;\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n\t//return ( (this.board[index] & 12) < 12 ) ? this.p1 : this.p2;\n}\n\nBoard.prototype.getCapturedPiece = function (pid, to) {\n\tlet nMoves = this.moves[pid].length;\n\tfor(let i=0; i< nMoves; i++) {\n\t\tlet move = this.moves[pid][i];\n\t\tif( (move & (BIT_AREA - 1)) === to ) return move >> (BIT_LENGTH + 1);\n\t}\n}\n\n// moves[pi] = [0000000 0000000] --> [board index of captured piece + board index of destination cell]\nBoard.prototype.addMove = function (from, to, captured) {\n\tcaptured = captured || 0;\n\tlet pi = (this.board[from] >> 5);\n\tthis.moves[pi].push( (captured << (BIT_LENGTH + 1) ) + to );\n}\n\nBoard.prototype.update = function (newPiece) {\n\tif (newPiece) {\n\t\t//find out which player this piece belongs to then add it within that player's key range (00000)\n\t\tthis.board = this.board.map(row => row.map((cell, j) => {\n\t\t\tif (cell.who != null) { //increment all pi in board after piecesSeparator by one\n\t\t\t\tif (cell.who >= this.piecesSeparator) cell.who++;\n\t\t\t\t//if piece alive, keep on board\n\t\t\t\treturn this.pieces[cell.who].alive ? {who: cell.who, move:false} : {who: null, move:false};\n\t\t\t} else return {who: null, move: false};\n\t\t}));\n\t} else {\n\t\tthis.board = this.board.map(row => row.map((cell, j) =>\n\t\t\t(cell.who != null)\n\t\t\t? (this.pieces[cell.who].alive\n\t\t\t\t? {who: cell.who, move:false}\n\t\t\t\t: {who: null, move:false})\n\t\t\t: {who: null, move: false}\n\t\t));\n\t}\n}\n\n\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tCLONE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\nBoard.prototype.makeClone = function (pi, row, col) {\n\t/*\n\tgetPlayer bit\n\t*/\n\tthis.board[row*BOARD_SIZE + col] |= this.getPlayer(row, col)\n\tthis.updateBoard(true);\n\tthis.board[row][col].who = this.piecesSeparator;\n\treturn true;\n}\n\n\nBoard.prototype.canClone = function (from) {\n\tlet onRow = from/BOARD_SIZE, piece = this.board[from];\n\tlet onBoundaryColumn = (from+1)%BOARD_SIZE < 2;\n\tlet onBoundaryRow = (onRow + 1)%BOARD_SIZE < 2;\n\n\t//To clone: NOT be on boundary column, BE on boundary row, NOT be cloned yet\n\tif(onBoundaryColumn || !onBoundaryRow || (piece ^ 16) ) return false;\n\n\tlet spawnRow = (( (piece >> 5) & 2*BIT_LENGTH ) - 1) / 2;\n\treturn (onRow ^ spawnRow);\n}\n\n//Assumes valid move\nBoard.prototype.isCloneMove = function (to, from) {\n\t//suffice to show if to and from are on opposing boundary rows\n\tlet toRow = to/BOARD_SIZE, fromRow = from/BOARD_SIZE;\n\treturn this.canClone(from) && (toRow ^ fromRow);\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tMOVES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\n// Board.prototype.getPlayer = function (pi) {\n// \treturn this.pieces[pi].player;\n// }\n\nBoard.prototype.canLeap = function (from, adj, isPhase, bypassCondition) {\n\tlet to = this.getInverseIndex(from);\n\tif( isPhase && !(this.getPlayer(to)) ) {\n\t\tlet inv = this.getInverseIndex(adj);\n\t\tlet phaseAdj = this.getPlayer(adj) & 8;\n\t\tlet phaseFar = this.getPlayer(inv) & 8;\n\n\t\tif( (phaseAdj ^ phaseFar) ) {\n\t\t\tif (bypassCondition) return true;\n\t\t\tlet captured = phaseAdj ? adj : inv;\n\t\t\tthis.addMove(from, to, captured);\n\t\t}\n\t}\n\t//if neighbor cell is a phase, leap_cell clear, and (enemy piece on phaseAdj XOR enemy piece on phaseFar)\n}\n\nBoard.prototype.isJump = function (from, adj, direction, bypassCondition) {\n\t//if adj cell occupied, jumpCell in bounds, jumpCell clear, and jumpCell has enemy piece\n\tlet to = adj+direction;\n\tif(this.inBounds(to)) {\n\t\tif (!this.getPlayer(to)) {\n\t\t\tif(bypassCondition%3) return true;\n\t\t\telse this.addMove(from, to, adj);\n\t\t}\n\t}\n}\n\nBoard.prototype.canPhase = function (from, to, bypassCondition) {\n\t//j = 7-row_index + 7-col_index\n\t//let to = ( (len - row) << BIT_SHIFT ) + (len - col);\n\tlet isPhase = (this.board[to] & 1);\n\tlet isDestinationEmpty = (this.board[from] & 3); //1 if player piece\n\tif(isPhase && isDestinationEmpty) {\n\t\tif (bypassCondition%3) return true;\n\t\telse this.addMove(from, to);\n\t}\n}\n\n//reaching this function implies selected piece can be cloned, so piece is on an bounding row\nBoard.prototype.getCloneSpawnCells = function (from, bypassCondition) {\n\tlet spawnRow = ( from/BOARD_SIZE ^ (BIT_LENGTH - 1) );\n\tfor(let col=1; col<7;col++) {\n\t\tlet to = spawnRow + col;\n\t\tlet spawnCell = this.board[to];\n\t\t//if spawnCell doesn't have a player on it\n\t\tif ( spawnCell ^ 4 ) {\n\t\t\tif (bypassCondition%3) return true;\n\t\t\telse this.addMove(from, to);\n\t\t}\n\t}\n}\n\nBoard.prototype.getMovesInDirection = function (from, adj, bypassCondition) {\n\t//check adjacent cells of piece p wrt the boundary\n\tlet direction = adj - from;\n\tlet isPhase = this.board[adj] & 1;\n\n\tif (this.canLeap(from, adj, isPhase, bypassCondition)) return true;\n\n\tif( this.getPlayer(adj) ) {\n\t\tif (this.isJump(from, adj, direction, bypassCondition)) return true;\n\t}\n\telse if (bypassCondition%3%2) return true;\t//adjacent moves\n\telse if (!bypassCondition) this.addMove(from, adj);\n\treturn false;\n}\n\n/* bypassCondition (HIGHLIGHT BYPASS CONDITION):\n\t\tundefined - default (Store all),\n\t\t1 - bypass all,\n\t\t2 - bypass continuable moves,\n\t\t3 - store continuable moves\n*/\nBoard.prototype.getMoves = function (from, bypassCondition, r, c) {\n\tlet row = getRow(from), col = getCol(from);\n\t// move continuation AND has a move in specified direction\n\tif (bypassCondition === 2 && this.getMovesInDirection(from, toIndex(row + r, col + c), bypassCondition) ) return true;\n\t// on a phase\n\tif (this.canPhase(from, this.getInverseIndex(from), bypassCondition)) return true;\n\t// able to clone\n\tif (this.canClone(from) && this.getCloneSpawnCells(from, bypassCondition)) return true;\n\t//step, jump, leap\n\tfor(r=-1;r<2;r++) for(c=-1;c<2; c++) {\n\t\tlet adj = toIndex(row + r, col + c);\n\t\tlet validDirection = ( this.getPlayer(adj) ^ this.getPlayer(from) ) //enemy or empty cell\n\t\t\t&& this.inBounds(adj) && (adj-from);\n\t\tif (validDirection && this.getMovesInDirection(from, adj, bypassCondition)) return true;\n\t}\n\treturn false;\n}\n\n//Performs move. returns true if caught piece in process, else false\n//NOTE: it is impossible to capture a piece at board index 0\nBoard.prototype.doMove = function (from, to) {\n\n\tif(this.isCloneMove(from, to)) {\n\t\tthis.makeClone(to);\n\t\treturn false;\n\t}\n\n\tlet capturedPiece = getCapturedPiece\n\n\tlet p = this.pieces[pi];\n\t//begin move\n\tthis.board[p.row][p.col].who = null;\n\n\tlet destinationCell = this.board[row][col];\n\tlet caught = typeof(destinationCell.move) === \"number\" ? destinationCell.move : false; //caught piece index\n\t// moveDirection is defined if and only if any of the following is true (for moving piece p):\n\tlet moveDirection;\n\t\t// (1) p caught a piece\n\tif (caught) {\n\t\tlet c = this.pieces[caught];\n\t\tc.alive = false;\n\t\tthis.board[c.row][c.col].who = null;\n\t\t//return direction of move\n\t\t//If leap, then c adjacent at start XOR c adjacent at end\n\t\t//Check adjacency of moving piece to captured piece on starting position and ending position\n\t\tlet cellAdjStartPos = Math.abs(c.row - p.row) < 2 && Math.abs(c.col - p.col) < 2;\n\t\tlet cellAdjEndPos = Math.abs(row - c.row) < 2 && Math.abs(col - c.col) < 2;\n\n\t\tmoveDirection = (cellAdjStartPos && cellAdjEndPos)\n\t\t\t? {rowIncr: Math.sign(row-c.row), colIncr: Math.sign(col-c.col)}\t//jump\n\t\t\t: (cellAdjStartPos\n\t\t\t\t? {rowIncr: Math.sign(c.row-p.row), colIncr: Math.sign(c.col-p.row)}\t//leap-> piece adj to capture on start\n\t\t\t\t: {rowIncr: Math.sign(row-c.row), colIncr: Math.sign(col-c.col)});\n\t}\t// (2) p LANDS on a phase cell. That is, this move is not a phase.\n\telse if (!this.samePhase(p,{row: row, col: col}))\tmoveDirection = {rowIncr: 0, colIncr: 0};\n\n\t//end move\n\tthis.board[row][col].who = pi;\n\tp.row = row;\n\tp.col = col;\n\n\t\t// (3) p is able to be cloned\n\tif (this.canClone(pi)) moveDirection = {rowIncr: 0, colIncr:0};\n\tthis.updateBoard();\n\treturn moveDirection;\n}\n\nBoard.prototype.highlightMoves = function (piece) {\n\tlet nMoves = this.moves[piece].length;\n\tfor(let i=0; i<nMoves; i++) {\n\t\tlet destinationIndex = ( this.moves[piece][i] & (BIT_AREA - 1) );\n\t\tthis.board[destinationIndex] |= 2;\n\t}\n}\n\nBoard.prototype.removeHighlight = function () {\n\tfor(let i=0; i<BOARD_AREA; i++) {\n\t\tif(this.board[i] & 2) (this.board[i] = this.board[i] ^ 2);\n\t}\n}\n\n/*==========\t\t\t\t\t\t\t\t\t\t\tINTEGRITY\t\t\t\t\t\t\t\t\t\t\t\t\t==========*/\n\nBoard.prototype.getInverseIndex = function (index) {\n\tlet len = BOARD_SIZE - 1;\n\tlet row = getRow(index), col = getCol(index);\n\treturn toIndex(len - row, len - col);\n}\n\n//Don't need -> can use dest cell shit\nBoard.prototype.samePhase = function (from, to) {\n\tlet isDestinationPhase = cellType(to.row, to.col);\n\treturn isDestinationPhase > 1 && isDestinationPhase === cellType(from.row, from.col);\n}\n\nBoard.prototype.inBounds = function (index) {\n\treturn 0 <= index && index < BOARD_AREA;\n}\n\nBoard.prototype.canContinueMove = function (pi, dir) {\n\treturn dir ? this.getMoves(pi, 2, dir.rowIncr, dir.colIncr) : false;\n}\n\nBoard.prototype.hasMoves = function (pi) {\n\treturn this.getMoves(pi, 1);\n}\n\n//Player has no more moves when (1): all player's pieces are dead (2): every piece has no moves\nBoard.prototype.movesLeft = function (player) {\n\tfor(let pi=0; pi < this.pieces.length; pi++) {\n\t\tlet p = this.pieces[pi];\n\t\tif(p.alive && p.player === player) {\n\t\t\tif(this.hasMoves(pi)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nBoard.prototype.validMove = function (piece, index) {\n\tlet n = this.moves[piece].length;\n\tlet isAvailableMove = 0;\n\tfor(let i=0; i<n; i++) {\n\t\tif ( (this.moves[piece][i] & (BIT_AREA - 1)) === index ) isAvailableMove++;\n\t}\n\treturn !!(isAvailableMove);\n}\n\nexport default Board;\n"]},"metadata":{},"sourceType":"module"}