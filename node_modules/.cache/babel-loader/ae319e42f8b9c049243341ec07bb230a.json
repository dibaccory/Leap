{"ast":null,"code":"import { BOARD_SIZE, BOARD_AREA, BIT_SIZE, BIT_MAX_PI, BIT_INDEX_SHIFT, BIT_AREA } from './board.js';\nconst UCB_COEFFICENT = 1;\n\nfunction Node(player, from, to) {\n  this.visits = 1;\n  this.score = 0;\n  this.children = null;\n  this.to = to;\n  this.from = from;\n  this.player = player;\n} //\n// Node.prototype.opponent = function () {\n//     return this.player ^ 8;\n// }\n\n\nNode.prototype.append = function (child) {\n  if (!this.children) this.children = [child];else this.children.push(child);\n};\n\nNode.prototype.branch = function (state) {\n  state.clearMoves();\n  state.getAllMoves(state.player);\n  const shift = state.player === 12 ? BIT_MAX_PI : 0;\n\n  for (let pi = shift; pi < BIT_MAX_PI + shift; pi++) {\n    const nMoves = state.moves[pi].length;\n    const from = state.board[BOARD_AREA + pi];\n\n    for (let i = 0; i < nMoves; i++) {\n      const to = state.moves[pi][i] & BIT_AREA - 1;\n      let child = new Node(state.player, from, to);\n      this.append(child);\n    }\n  }\n};\n\nNode.prototype.playFor = function (state) {\n  return state.doMove(this.from, this.to);\n};\n\nNode.prototype.ucb = function (c) {\n  const score = this.score / this.visits;\n  return score + UCB_COEFFICENT * Math.sqrt(c / this.visits);\n};\n\nNode.prototype.findBestChild = function () {\n  const coeff = Math.log(this.visits);\n  let bestScore = -Infinity;\n  let bestChild = null;\n\n  for (let i = 0; i < this.children.length; i++) {\n    const child = this.children[i];\n    let score; //Prioritize unexplored nodes\n\n    if (child.visits !== 1) score = child.ucb(coeff);else score = Math.ceil(10000 * (1 + Math.random()));\n\n    if (score > bestScore) {\n      bestScore = score;\n      bestChild = child;\n    }\n  }\n\n  return bestChild;\n};\n\nexport function UCT(startState, maxTime) {\n  this.root = new Node(startState.player);\n  this.startState = startState;\n  this.visitThreshold = 2 * BOARD_SIZE; // Populate the first node.\n\n  this.root.branch(startState);\n  this.history = [this.root];\n  let totalPlayouts = 0;\n  const start = Date.now();\n  let elapsedTime = 0;\n\n  while (elapsedTime < maxTime) {\n    for (var i = 0; i < 500; i++) this.run();\n\n    totalPlayouts += 500;\n    elapsedTime = Date.now() - start;\n  } //Choose best child of root to return next move\n\n\n  let bestChild = null;\n  let bestScore = -Infinity;\n\n  for (let i = 0; i < this.root.children.length; i++) {\n    const child = this.root.children[i];\n\n    if (child.visits > bestScore) {\n      bestChild = child;\n      bestScore = child.visits;\n    }\n  }\n\n  return {\n    elapsed: elapsedTime,\n    playouts: totalPlayouts,\n    from: bestChild.from,\n    to: bestChild.to\n  };\n}\n\nUCT.prototype.playout = function (state) {\n  let nmoves = 0;\n\n  while (++nmoves < 60) {\n    const result = state.randomMove(); //returns if won\n\n    if (result) return result;\n  }\n\n  return state.score();\n};\n\nUCT.prototype.run = function () {\n  const state = this.startState.copy();\n  let node = this.root;\n  let depth = 1;\n  let winner = 0;\n\n  while (true) {\n    if (node.children === null) {\n      //Keeps UCT from branching too quickly\n      if (node.visits >= this.visitThreshold * depth) {\n        node.branch(state); // Leaf node - go directly to update.\n\n        if (node.children === null) {\n          winner = node.opponent();\n          this.history[depth++] = node;\n          break;\n        }\n\n        continue;\n      }\n\n      winner = this.playout(state);\n      break;\n    }\n\n    node = node.findBestChild();\n    this.history[depth++] = node;\n\n    if (node.playFor(state)) {\n      winner = state.player;\n      break;\n    }\n  } //Add scores and\n\n\n  for (let i = 0; i < depth; i++) {\n    node = this.history[i];\n    node.visits++;\n    if (winner === node.player) node.score += 1;else if (!winner) node.score -= 1;\n  }\n};","map":{"version":3,"sources":["/Users/bacchus/git/Leap/src/js/ai.js"],"names":["BOARD_SIZE","BOARD_AREA","BIT_SIZE","BIT_MAX_PI","BIT_INDEX_SHIFT","BIT_AREA","UCB_COEFFICENT","Node","player","from","to","visits","score","children","prototype","append","child","push","branch","state","clearMoves","getAllMoves","shift","pi","nMoves","moves","length","board","i","playFor","doMove","ucb","c","Math","sqrt","findBestChild","coeff","log","bestScore","Infinity","bestChild","ceil","random","UCT","startState","maxTime","root","visitThreshold","history","totalPlayouts","start","Date","now","elapsedTime","run","elapsed","playouts","playout","nmoves","result","randomMove","copy","node","depth","winner","opponent"],"mappings":"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","sourcesContent":["import {BOARD_SIZE, BOARD_AREA, BIT_SIZE, BIT_MAX_PI, BIT_INDEX_SHIFT, BIT_AREA} from './board.js';\n\nconst UCB_COEFFICENT = 1;\n\nfunction Node(player, from, to) {\n    this.visits = 1;\n    this.score = 0;\n    this.children = null;\n    this.to = to;\n    this.from = from;\n    this.player = player;\n}\n//\n// Node.prototype.opponent = function () {\n//     return this.player ^ 8;\n// }\n\nNode.prototype.append = function (child) {\n    if (!this.children) this.children = [child];\n    else this.children.push(child);\n}\n\nNode.prototype.branch = function (state) {\n    state.clearMoves();\n    state.getAllMoves(state.player);\n\n    const shift = (state.player === 12) ? BIT_MAX_PI : 0;\n    for (let pi = shift; pi < BIT_MAX_PI + shift; pi++) {\n      const nMoves = state.moves[pi].length;\n      const from = state.board[BOARD_AREA + pi];\n\n      for (let i = 0; i < nMoves; i++) {\n        const to = ( state.moves[pi][i] & (BIT_AREA - 1) );\n        let child = new Node(state.player, from, to);\n        this.append(child);\n      }\n  }\n}\n\nNode.prototype.playFor = function (state) {\n    return state.doMove(this.from, this.to);\n}\n\nNode.prototype.ucb = function (c) {\n    const score = (this.score / this.visits);\n    return score + UCB_COEFFICENT * Math.sqrt( c / this.visits);\n}\n\nNode.prototype.findBestChild = function () {\n    const coeff = Math.log(this.visits);\n    let bestScore = -Infinity;\n    let bestChild = null;\n    for (let i = 0; i < this.children.length; i++) {\n      const child = this.children[i];\n      let score;\n\n      //Prioritize unexplored nodes\n      if (child.visits !== 1) score = child.ucb(coeff);\n      else score = Math.ceil( 10000*(1 + Math.random()) );\n\n      if (score > bestScore) {\n          bestScore = score;\n          bestChild = child;\n      }\n    }\n    return bestChild;\n}\n\n\n\n\n\nexport function UCT(startState, maxTime) {\n  this.root = new Node(startState.player);\n  this.startState = startState;\n  this.visitThreshold = 2*BOARD_SIZE;\n\n  // Populate the first node.\n  this.root.branch(startState);\n  this.history = [this.root];\n\n  let totalPlayouts = 0;\n  const start = Date.now();\n  let elapsedTime = 0;\n  while (elapsedTime < maxTime) {\n      for (var i = 0; i < 500; i++) this.run();\n      totalPlayouts += 500;\n      elapsedTime = Date.now() - start;\n  }\n\n  //Choose best child of root to return next move\n  let bestChild = null;\n  let bestScore = -Infinity;\n  for (let i = 0; i < this.root.children.length; i++) {\n      const child = this.root.children[i];\n      if (child.visits > bestScore) {\n          bestChild = child;\n          bestScore = child.visits;\n      }\n  }\n\n  return {\n    elapsed: elapsedTime,\n    playouts: totalPlayouts,\n    from: bestChild.from,\n    to: bestChild.to\n  };\n}\n\nUCT.prototype.playout = function (state) {\n    let nmoves = 0;\n\n    while (++nmoves < 60) {\n      const result = state.randomMove(); //returns if won\n      if (result) return result;\n    }\n    return state.score();\n}\n\nUCT.prototype.run = function () {\n    const state = this.startState.copy();\n    let node = this.root;\n    let depth = 1;\n    let winner = 0;\n\n    while (true) {\n      if (node.children === null) {\n        //Keeps UCT from branching too quickly\n        if (node.visits >= this.visitThreshold*depth) {\n          node.branch(state);\n\n          // Leaf node - go directly to update.\n          if (node.children === null) {\n            winner = node.opponent();\n            this.history[depth++] = node;\n            break;\n          }\n          continue;\n        }\n        winner = this.playout(state);\n        break;\n      }\n        node = node.findBestChild();\n        this.history[depth++] = node;\n        if (node.playFor(state)) {\n          winner = state.player;\n          break;\n        }\n    }\n\n    //Add scores and\n    for (let i = 0; i < depth; i++) {\n      node = this.history[i];\n      node.visits++;\n      if (winner === node.player) node.score += 1;\n      else if (!winner) node.score -= 1;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}