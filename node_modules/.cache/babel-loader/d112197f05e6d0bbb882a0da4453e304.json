{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar annotations_1 = require(\"./annotations\");\n\nvar Schema_1 = require(\"./Schema\");\n\nvar ArraySchema_1 = require(\"./types/ArraySchema\");\n\nvar MapSchema_1 = require(\"./types/MapSchema\");\n\nvar reflectionContext = new annotations_1.Context();\n/**\n * Reflection\n */\n\nvar ReflectionField =\n/** @class */\nfunction (_super) {\n  __extends(ReflectionField, _super);\n\n  function ReflectionField() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([annotations_1.type(\"string\", reflectionContext)], ReflectionField.prototype, \"name\", void 0);\n\n  __decorate([annotations_1.type(\"string\", reflectionContext)], ReflectionField.prototype, \"type\", void 0);\n\n  __decorate([annotations_1.type(\"uint8\", reflectionContext)], ReflectionField.prototype, \"referencedType\", void 0);\n\n  return ReflectionField;\n}(Schema_1.Schema);\n\nexports.ReflectionField = ReflectionField;\n\nvar ReflectionType =\n/** @class */\nfunction (_super) {\n  __extends(ReflectionType, _super);\n\n  function ReflectionType() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.fields = new ArraySchema_1.ArraySchema();\n    return _this;\n  }\n\n  __decorate([annotations_1.type(\"uint8\", reflectionContext)], ReflectionType.prototype, \"id\", void 0);\n\n  __decorate([annotations_1.type([ReflectionField], reflectionContext)], ReflectionType.prototype, \"fields\", void 0);\n\n  return ReflectionType;\n}(Schema_1.Schema);\n\nexports.ReflectionType = ReflectionType;\n\nvar Reflection =\n/** @class */\nfunction (_super) {\n  __extends(Reflection, _super);\n\n  function Reflection() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.types = new ArraySchema_1.ArraySchema();\n    return _this;\n  }\n\n  Reflection.encode = function (instance) {\n    var rootSchemaType = instance.constructor;\n    var reflection = new Reflection();\n    reflection.rootType = rootSchemaType._typeid;\n\n    var buildType = function (currentType, schema) {\n      for (var fieldName in schema) {\n        var field = new ReflectionField();\n        field.name = fieldName;\n        var fieldType = void 0;\n\n        if (typeof schema[fieldName] === \"string\") {\n          fieldType = schema[fieldName];\n        } else {\n          var isSchema = typeof schema[fieldName] === \"function\";\n          var isArray = Array.isArray(schema[fieldName]);\n          var isMap = !isArray && schema[fieldName].map;\n          var childTypeSchema = void 0;\n\n          if (isSchema) {\n            fieldType = \"ref\";\n            childTypeSchema = schema[fieldName];\n          } else if (isArray) {\n            fieldType = \"array\";\n\n            if (typeof schema[fieldName][0] === \"string\") {\n              fieldType += \":\" + schema[fieldName][0]; // array:string\n            } else {\n              childTypeSchema = schema[fieldName][0];\n            }\n          } else if (isMap) {\n            fieldType = \"map\";\n\n            if (typeof schema[fieldName].map === \"string\") {\n              fieldType += \":\" + schema[fieldName].map; // array:string\n            } else {\n              childTypeSchema = schema[fieldName].map;\n            }\n          }\n\n          field.referencedType = childTypeSchema ? childTypeSchema._typeid : 255;\n        }\n\n        field.type = fieldType;\n        currentType.fields.push(field);\n      }\n\n      reflection.types.push(currentType);\n    };\n\n    var types = rootSchemaType._context.types;\n\n    for (var typeid in types) {\n      var type_1 = new ReflectionType();\n      type_1.id = Number(typeid);\n      buildType(type_1, types[typeid]._schema);\n    }\n\n    return reflection.encodeAll();\n  };\n\n  Reflection.decode = function (bytes) {\n    var context = new annotations_1.Context();\n    var reflection = new Reflection();\n    reflection.decode(bytes);\n    var schemaTypes = reflection.types.reduce(function (types, reflectionType) {\n      types[reflectionType.id] =\n      /** @class */\n      function (_super) {\n        __extends(_, _super);\n\n        function _() {\n          return _super !== null && _super.apply(this, arguments) || this;\n        }\n\n        return _;\n      }(Schema_1.Schema);\n\n      return types;\n    }, {});\n    reflection.types.forEach(function (reflectionType, i) {\n      reflectionType.fields.forEach(function (field) {\n        var schemaType = schemaTypes[reflectionType.id];\n\n        if (field.referencedType !== undefined) {\n          var refType = schemaTypes[field.referencedType]; // map or array of primitive type (255)\n\n          if (!refType) {\n            refType = field.type.split(\":\")[1];\n          }\n\n          if (field.type.indexOf(\"array\") === 0) {\n            annotations_1.type([refType], context)(schemaType.prototype, field.name);\n          } else if (field.type.indexOf(\"map\") === 0) {\n            annotations_1.type({\n              map: refType\n            }, context)(schemaType.prototype, field.name);\n          } else if (field.type === \"ref\") {\n            annotations_1.type(refType, context)(schemaType.prototype, field.name);\n          }\n        } else {\n          annotations_1.type(field.type, context)(schemaType.prototype, field.name);\n        }\n      });\n    });\n    var rootType = schemaTypes[reflection.rootType];\n    var rootInstance = new rootType();\n    /**\n     * auto-initialize referenced types on root type\n     * to allow registering listeners immediatelly on client-side\n     */\n\n    for (var fieldName in rootType._schema) {\n      var fieldType = rootType._schema[fieldName];\n\n      if (typeof fieldType !== \"string\") {\n        var isSchema = typeof fieldType === \"function\";\n        var isArray = Array.isArray(fieldType);\n        var isMap = !isArray && fieldType.map;\n        rootInstance[fieldName] = isArray ? new ArraySchema_1.ArraySchema() : isMap ? new MapSchema_1.MapSchema() : isSchema ? new fieldType() : undefined;\n      }\n    }\n\n    return rootInstance;\n  };\n\n  __decorate([annotations_1.type([ReflectionType], reflectionContext)], Reflection.prototype, \"types\", void 0);\n\n  __decorate([annotations_1.type(\"uint8\", reflectionContext)], Reflection.prototype, \"rootType\", void 0);\n\n  return Reflection;\n}(Schema_1.Schema);\n\nexports.Reflection = Reflection;","map":{"version":3,"sources":["../src/Reflection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar annotations_1 = require(\"./annotations\");\nvar Schema_1 = require(\"./Schema\");\nvar ArraySchema_1 = require(\"./types/ArraySchema\");\nvar MapSchema_1 = require(\"./types/MapSchema\");\nvar reflectionContext = new annotations_1.Context();\n/**\n * Reflection\n */\nvar ReflectionField = /** @class */ (function (_super) {\n    __extends(ReflectionField, _super);\n    function ReflectionField() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        annotations_1.type(\"string\", reflectionContext)\n    ], ReflectionField.prototype, \"name\", void 0);\n    __decorate([\n        annotations_1.type(\"string\", reflectionContext)\n    ], ReflectionField.prototype, \"type\", void 0);\n    __decorate([\n        annotations_1.type(\"uint8\", reflectionContext)\n    ], ReflectionField.prototype, \"referencedType\", void 0);\n    return ReflectionField;\n}(Schema_1.Schema));\nexports.ReflectionField = ReflectionField;\nvar ReflectionType = /** @class */ (function (_super) {\n    __extends(ReflectionType, _super);\n    function ReflectionType() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.fields = new ArraySchema_1.ArraySchema();\n        return _this;\n    }\n    __decorate([\n        annotations_1.type(\"uint8\", reflectionContext)\n    ], ReflectionType.prototype, \"id\", void 0);\n    __decorate([\n        annotations_1.type([ReflectionField], reflectionContext)\n    ], ReflectionType.prototype, \"fields\", void 0);\n    return ReflectionType;\n}(Schema_1.Schema));\nexports.ReflectionType = ReflectionType;\nvar Reflection = /** @class */ (function (_super) {\n    __extends(Reflection, _super);\n    function Reflection() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.types = new ArraySchema_1.ArraySchema();\n        return _this;\n    }\n    Reflection.encode = function (instance) {\n        var rootSchemaType = instance.constructor;\n        var reflection = new Reflection();\n        reflection.rootType = rootSchemaType._typeid;\n        var buildType = function (currentType, schema) {\n            for (var fieldName in schema) {\n                var field = new ReflectionField();\n                field.name = fieldName;\n                var fieldType = void 0;\n                if (typeof (schema[fieldName]) === \"string\") {\n                    fieldType = schema[fieldName];\n                }\n                else {\n                    var isSchema = typeof (schema[fieldName]) === \"function\";\n                    var isArray = Array.isArray(schema[fieldName]);\n                    var isMap = !isArray && schema[fieldName].map;\n                    var childTypeSchema = void 0;\n                    if (isSchema) {\n                        fieldType = \"ref\";\n                        childTypeSchema = schema[fieldName];\n                    }\n                    else if (isArray) {\n                        fieldType = \"array\";\n                        if (typeof (schema[fieldName][0]) === \"string\") {\n                            fieldType += \":\" + schema[fieldName][0]; // array:string\n                        }\n                        else {\n                            childTypeSchema = schema[fieldName][0];\n                        }\n                    }\n                    else if (isMap) {\n                        fieldType = \"map\";\n                        if (typeof (schema[fieldName].map) === \"string\") {\n                            fieldType += \":\" + schema[fieldName].map; // array:string\n                        }\n                        else {\n                            childTypeSchema = schema[fieldName].map;\n                        }\n                    }\n                    field.referencedType = (childTypeSchema)\n                        ? childTypeSchema._typeid\n                        : 255;\n                }\n                field.type = fieldType;\n                currentType.fields.push(field);\n            }\n            reflection.types.push(currentType);\n        };\n        var types = rootSchemaType._context.types;\n        for (var typeid in types) {\n            var type_1 = new ReflectionType();\n            type_1.id = Number(typeid);\n            buildType(type_1, types[typeid]._schema);\n        }\n        return reflection.encodeAll();\n    };\n    Reflection.decode = function (bytes) {\n        var context = new annotations_1.Context();\n        var reflection = new Reflection();\n        reflection.decode(bytes);\n        var schemaTypes = reflection.types.reduce(function (types, reflectionType) {\n            types[reflectionType.id] = /** @class */ (function (_super) {\n                __extends(_, _super);\n                function _() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                return _;\n            }(Schema_1.Schema));\n            return types;\n        }, {});\n        reflection.types.forEach(function (reflectionType, i) {\n            reflectionType.fields.forEach(function (field) {\n                var schemaType = schemaTypes[reflectionType.id];\n                if (field.referencedType !== undefined) {\n                    var refType = schemaTypes[field.referencedType];\n                    // map or array of primitive type (255)\n                    if (!refType) {\n                        refType = field.type.split(\":\")[1];\n                    }\n                    if (field.type.indexOf(\"array\") === 0) {\n                        annotations_1.type([refType], context)(schemaType.prototype, field.name);\n                    }\n                    else if (field.type.indexOf(\"map\") === 0) {\n                        annotations_1.type({ map: refType }, context)(schemaType.prototype, field.name);\n                    }\n                    else if (field.type === \"ref\") {\n                        annotations_1.type(refType, context)(schemaType.prototype, field.name);\n                    }\n                }\n                else {\n                    annotations_1.type(field.type, context)(schemaType.prototype, field.name);\n                }\n            });\n        });\n        var rootType = schemaTypes[reflection.rootType];\n        var rootInstance = new rootType();\n        /**\n         * auto-initialize referenced types on root type\n         * to allow registering listeners immediatelly on client-side\n         */\n        for (var fieldName in rootType._schema) {\n            var fieldType = rootType._schema[fieldName];\n            if (typeof (fieldType) !== \"string\") {\n                var isSchema = typeof (fieldType) === \"function\";\n                var isArray = Array.isArray(fieldType);\n                var isMap = !isArray && fieldType.map;\n                rootInstance[fieldName] = (isArray)\n                    ? new ArraySchema_1.ArraySchema()\n                    : (isMap)\n                        ? new MapSchema_1.MapSchema()\n                        : (isSchema)\n                            ? new fieldType()\n                            : undefined;\n            }\n        }\n        return rootInstance;\n    };\n    __decorate([\n        annotations_1.type([ReflectionType], reflectionContext)\n    ], Reflection.prototype, \"types\", void 0);\n    __decorate([\n        annotations_1.type(\"uint8\", reflectionContext)\n    ], Reflection.prototype, \"rootType\", void 0);\n    return Reflection;\n}(Schema_1.Schema));\nexports.Reflection = Reflection;\n//# sourceMappingURL=Reflection.js.map"]},"metadata":{},"sourceType":"script"}