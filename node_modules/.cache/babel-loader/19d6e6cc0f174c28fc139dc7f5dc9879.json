{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar createBackoff = require('./backoff').createBackoff;\n\nvar WebSocketImpl = typeof WebSocket !== \"undefined\" ? WebSocket : require('ws');\n\nvar WebSocketClient = function () {\n  /**\n  * @param url DOMString The URL to which to connect; this should be the URL to which the WebSocket server will respond.\n  * @param protocols DOMString|DOMString[] Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols, so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server to be able to handle different types of interactions depending on the specified protocol). If you don't specify a protocol string, an empty string is assumed.\n  */\n  function WebSocketClient(url, protocols) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, WebSocketClient);\n\n    this.url = url;\n    this.protocols = protocols;\n    this.reconnectEnabled = true;\n    this.listeners = {};\n    this.backoff = createBackoff(options.backoff || 'exponential', options);\n    this.backoff.onReady = this.onBackoffReady.bind(this);\n\n    if (typeof options.connect === \"undefined\" || options.connect) {\n      this.open();\n    }\n  }\n\n  _createClass(WebSocketClient, [{\n    key: 'open',\n    value: function open() {\n      var reconnect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.isReconnect = reconnect; // keep binaryType used on previous WebSocket connection\n\n      var binaryType = this.ws && this.ws.binaryType;\n      this.ws = new WebSocketImpl(this.url, this.protocols);\n      this.ws.onclose = this.onCloseCallback.bind(this);\n      this.ws.onerror = this.onErrorCallback.bind(this);\n      this.ws.onmessage = this.onMessageCallback.bind(this);\n      this.ws.onopen = this.onOpenCallback.bind(this);\n\n      if (binaryType) {\n        this.ws.binaryType = binaryType;\n      }\n    }\n    /**\n    * @ignore\n    */\n\n  }, {\n    key: 'onBackoffReady',\n    value: function onBackoffReady(number, delay) {\n      // console.log(\"onBackoffReady\", number + ' ' + delay + 'ms');\n      this.open(true);\n    }\n    /**\n    * @ignore\n    */\n\n  }, {\n    key: 'onCloseCallback',\n    value: function onCloseCallback(e) {\n      if (!this.isReconnect && this.listeners['onclose']) {\n        this.listeners['onclose'].apply(null, arguments);\n      }\n\n      if (this.reconnectEnabled && e.code < 3000) {\n        this.backoff.backoff();\n      }\n    }\n    /**\n    * @ignore\n    */\n\n  }, {\n    key: 'onErrorCallback',\n    value: function onErrorCallback() {\n      if (this.listeners['onerror']) {\n        this.listeners['onerror'].apply(null, arguments);\n      }\n    }\n    /**\n    * @ignore\n    */\n\n  }, {\n    key: 'onMessageCallback',\n    value: function onMessageCallback() {\n      if (this.listeners['onmessage']) {\n        this.listeners['onmessage'].apply(null, arguments);\n      }\n    }\n    /**\n    * @ignore\n    */\n\n  }, {\n    key: 'onOpenCallback',\n    value: function onOpenCallback() {\n      if (this.listeners['onopen']) {\n        this.listeners['onopen'].apply(null, arguments);\n      }\n\n      if (this.isReconnect && this.listeners['onreconnect']) {\n        this.listeners['onreconnect'].apply(null, arguments);\n      }\n\n      this.isReconnect = false;\n    }\n    /**\n    * The number of bytes of data that have been queued using calls to send()\n    * but not yet transmitted to the network. This value does not reset to zero\n    * when the connection is closed; if you keep calling send(), this will\n    * continue to climb.\n    *\n    * @type unsigned long\n    * @readonly\n    */\n\n  }, {\n    key: 'close',\n\n    /**\n    * Closes the WebSocket connection or connection attempt, if any. If the\n    * connection is already CLOSED, this method does nothing.\n    *\n    * @param code A numeric value indicating the status code explaining why the connection is being closed. If this parameter is not specified, a default value of 1000 (indicating a normal \"transaction complete\" closure) is assumed. See the list of status codes on the CloseEvent page for permitted values.\n    * @param reason A human-readable string explaining why the connection is closing. This string must be no longer than 123 bytes of UTF-8 text (not characters).\n    *\n    * @return void\n    */\n    value: function close(code, reason) {\n      if (typeof code == 'undefined') {\n        code = 1000;\n      }\n\n      this.reconnectEnabled = false;\n      this.ws.close(code, reason);\n    }\n    /**\n    * Transmits data to the server over the WebSocket connection.\n    * @param data DOMString|ArrayBuffer|Blob\n    * @return void\n    */\n\n  }, {\n    key: 'send',\n    value: function send(data) {\n      this.ws.send(data);\n    }\n    /**\n    * An event listener to be called when the WebSocket connection's readyState changes to CLOSED. The listener receives a CloseEvent named \"close\".\n    * @param listener EventListener\n    */\n\n  }, {\n    key: 'bufferedAmount',\n    get: function get() {\n      return this.ws.bufferedAmount;\n    }\n    /**\n    * The current state of the connection; this is one of the Ready state constants.\n    * @type unsigned short\n    * @readonly\n    */\n\n  }, {\n    key: 'readyState',\n    get: function get() {\n      return this.ws.readyState;\n    }\n    /**\n    * A string indicating the type of binary data being transmitted by the\n    * connection. This should be either \"blob\" if DOM Blob objects are being\n    * used or \"arraybuffer\" if ArrayBuffer objects are being used.\n    * @type DOMString\n    */\n\n  }, {\n    key: 'binaryType',\n    get: function get() {\n      return this.ws.binaryType;\n    },\n    set: function set(binaryType) {\n      this.ws.binaryType = binaryType;\n    }\n    /**\n    * The extensions selected by the server. This is currently only the empty\n    * string or a list of extensions as negotiated by the connection.\n    * @type DOMString\n    */\n\n  }, {\n    key: 'extensions',\n    get: function get() {\n      return this.ws.extensions;\n    },\n    set: function set(extensions) {\n      this.ws.extensions = extensions;\n    }\n    /**\n    * A string indicating the name of the sub-protocol the server selected;\n    * this will be one of the strings specified in the protocols parameter when\n    * creating the WebSocket object.\n    * @type DOMString\n    */\n\n  }, {\n    key: 'protocol',\n    get: function get() {\n      return this.ws.protocol;\n    },\n    set: function set(protocol) {\n      this.ws.protocol = protocol;\n    }\n  }, {\n    key: 'onclose',\n    set: function set(listener) {\n      this.listeners['onclose'] = listener;\n    },\n    get: function get() {\n      return this.listeners['onclose'];\n    }\n    /**\n    * An event listener to be called when an error occurs. This is a simple event named \"error\".\n    * @param listener EventListener\n    */\n\n  }, {\n    key: 'onerror',\n    set: function set(listener) {\n      this.listeners['onerror'] = listener;\n    },\n    get: function get() {\n      return this.listeners['onerror'];\n    }\n    /**\n    * An event listener to be called when a message is received from the server. The listener receives a MessageEvent named \"message\".\n    * @param listener EventListener\n    */\n\n  }, {\n    key: 'onmessage',\n    set: function set(listener) {\n      this.listeners['onmessage'] = listener;\n    },\n    get: function get() {\n      return this.listeners['onmessage'];\n    }\n    /**\n    * An event listener to be called when the WebSocket connection's readyState changes to OPEN; this indicates that the connection is ready to send and receive data. The event is a simple one with the name \"open\".\n    * @param listener EventListener\n    */\n\n  }, {\n    key: 'onopen',\n    set: function set(listener) {\n      this.listeners['onopen'] = listener;\n    },\n    get: function get() {\n      return this.listeners['onopen'];\n    }\n    /**\n    * @param listener EventListener\n    */\n\n  }, {\n    key: 'onreconnect',\n    set: function set(listener) {\n      this.listeners['onreconnect'] = listener;\n    },\n    get: function get() {\n      return this.listeners['onreconnect'];\n    }\n  }]);\n\n  return WebSocketClient;\n}();\n/**\n* The connection is not yet open.\n*/\n\n\nWebSocketClient.CONNECTING = WebSocketImpl.CONNECTING;\n/**\n* The connection is open and ready to communicate.\n*/\n\nWebSocketClient.OPEN = WebSocketImpl.OPEN;\n/**\n* The connection is in the process of closing.\n*/\n\nWebSocketClient.CLOSING = WebSocketImpl.CLOSING;\n/**\n* The connection is closed or couldn't be opened.\n*/\n\nWebSocketClient.CLOSED = WebSocketImpl.CLOSED;\nexports.default = WebSocketClient;","map":{"version":3,"sources":["/Users/bacchus/git/Leap/node_modules/@gamestdio/websocket/lib/index.js"],"names":["Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","createBackoff","require","WebSocketImpl","WebSocket","WebSocketClient","url","protocols","options","arguments","undefined","reconnectEnabled","listeners","backoff","onReady","onBackoffReady","bind","connect","open","reconnect","isReconnect","binaryType","ws","onclose","onCloseCallback","onerror","onErrorCallback","onmessage","onMessageCallback","onopen","onOpenCallback","number","delay","e","apply","code","close","reason","send","data","get","bufferedAmount","readyState","set","extensions","protocol","listener","CONNECTING","OPEN","CLOSING","CLOSED","default"],"mappings":"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","sourcesContent":["'use strict';Object.defineProperty(exports,\"__esModule\",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}var createBackoff=require('./backoff').createBackoff;var WebSocketImpl=typeof WebSocket!==\"undefined\"?WebSocket:require('ws');var WebSocketClient=function(){/**\n   * @param url DOMString The URL to which to connect; this should be the URL to which the WebSocket server will respond.\n   * @param protocols DOMString|DOMString[] Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols, so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server to be able to handle different types of interactions depending on the specified protocol). If you don't specify a protocol string, an empty string is assumed.\n   */function WebSocketClient(url,protocols){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};_classCallCheck(this,WebSocketClient);this.url=url;this.protocols=protocols;this.reconnectEnabled=true;this.listeners={};this.backoff=createBackoff(options.backoff||'exponential',options);this.backoff.onReady=this.onBackoffReady.bind(this);if(typeof options.connect===\"undefined\"||options.connect){this.open();}}_createClass(WebSocketClient,[{key:'open',value:function open(){var reconnect=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;this.isReconnect=reconnect;// keep binaryType used on previous WebSocket connection\nvar binaryType=this.ws&&this.ws.binaryType;this.ws=new WebSocketImpl(this.url,this.protocols);this.ws.onclose=this.onCloseCallback.bind(this);this.ws.onerror=this.onErrorCallback.bind(this);this.ws.onmessage=this.onMessageCallback.bind(this);this.ws.onopen=this.onOpenCallback.bind(this);if(binaryType){this.ws.binaryType=binaryType;}}/**\n   * @ignore\n   */},{key:'onBackoffReady',value:function onBackoffReady(number,delay){// console.log(\"onBackoffReady\", number + ' ' + delay + 'ms');\nthis.open(true);}/**\n   * @ignore\n   */},{key:'onCloseCallback',value:function onCloseCallback(e){if(!this.isReconnect&&this.listeners['onclose']){this.listeners['onclose'].apply(null,arguments);}if(this.reconnectEnabled&&e.code<3000){this.backoff.backoff();}}/**\n   * @ignore\n   */},{key:'onErrorCallback',value:function onErrorCallback(){if(this.listeners['onerror']){this.listeners['onerror'].apply(null,arguments);}}/**\n   * @ignore\n   */},{key:'onMessageCallback',value:function onMessageCallback(){if(this.listeners['onmessage']){this.listeners['onmessage'].apply(null,arguments);}}/**\n   * @ignore\n   */},{key:'onOpenCallback',value:function onOpenCallback(){if(this.listeners['onopen']){this.listeners['onopen'].apply(null,arguments);}if(this.isReconnect&&this.listeners['onreconnect']){this.listeners['onreconnect'].apply(null,arguments);}this.isReconnect=false;}/**\n   * The number of bytes of data that have been queued using calls to send()\n   * but not yet transmitted to the network. This value does not reset to zero\n   * when the connection is closed; if you keep calling send(), this will\n   * continue to climb.\n   *\n   * @type unsigned long\n   * @readonly\n   */},{key:'close',/**\n   * Closes the WebSocket connection or connection attempt, if any. If the\n   * connection is already CLOSED, this method does nothing.\n   *\n   * @param code A numeric value indicating the status code explaining why the connection is being closed. If this parameter is not specified, a default value of 1000 (indicating a normal \"transaction complete\" closure) is assumed. See the list of status codes on the CloseEvent page for permitted values.\n   * @param reason A human-readable string explaining why the connection is closing. This string must be no longer than 123 bytes of UTF-8 text (not characters).\n   *\n   * @return void\n   */value:function close(code,reason){if(typeof code=='undefined'){code=1000;}this.reconnectEnabled=false;this.ws.close(code,reason);}/**\n   * Transmits data to the server over the WebSocket connection.\n   * @param data DOMString|ArrayBuffer|Blob\n   * @return void\n   */},{key:'send',value:function send(data){this.ws.send(data);}/**\n   * An event listener to be called when the WebSocket connection's readyState changes to CLOSED. The listener receives a CloseEvent named \"close\".\n   * @param listener EventListener\n   */},{key:'bufferedAmount',get:function get(){return this.ws.bufferedAmount;}/**\n   * The current state of the connection; this is one of the Ready state constants.\n   * @type unsigned short\n   * @readonly\n   */},{key:'readyState',get:function get(){return this.ws.readyState;}/**\n   * A string indicating the type of binary data being transmitted by the\n   * connection. This should be either \"blob\" if DOM Blob objects are being\n   * used or \"arraybuffer\" if ArrayBuffer objects are being used.\n   * @type DOMString\n   */},{key:'binaryType',get:function get(){return this.ws.binaryType;},set:function set(binaryType){this.ws.binaryType=binaryType;}/**\n   * The extensions selected by the server. This is currently only the empty\n   * string or a list of extensions as negotiated by the connection.\n   * @type DOMString\n   */},{key:'extensions',get:function get(){return this.ws.extensions;},set:function set(extensions){this.ws.extensions=extensions;}/**\n   * A string indicating the name of the sub-protocol the server selected;\n   * this will be one of the strings specified in the protocols parameter when\n   * creating the WebSocket object.\n   * @type DOMString\n   */},{key:'protocol',get:function get(){return this.ws.protocol;},set:function set(protocol){this.ws.protocol=protocol;}},{key:'onclose',set:function set(listener){this.listeners['onclose']=listener;},get:function get(){return this.listeners['onclose'];}/**\n   * An event listener to be called when an error occurs. This is a simple event named \"error\".\n   * @param listener EventListener\n   */},{key:'onerror',set:function set(listener){this.listeners['onerror']=listener;},get:function get(){return this.listeners['onerror'];}/**\n   * An event listener to be called when a message is received from the server. The listener receives a MessageEvent named \"message\".\n   * @param listener EventListener\n   */},{key:'onmessage',set:function set(listener){this.listeners['onmessage']=listener;},get:function get(){return this.listeners['onmessage'];}/**\n   * An event listener to be called when the WebSocket connection's readyState changes to OPEN; this indicates that the connection is ready to send and receive data. The event is a simple one with the name \"open\".\n   * @param listener EventListener\n   */},{key:'onopen',set:function set(listener){this.listeners['onopen']=listener;},get:function get(){return this.listeners['onopen'];}/**\n   * @param listener EventListener\n   */},{key:'onreconnect',set:function set(listener){this.listeners['onreconnect']=listener;},get:function get(){return this.listeners['onreconnect'];}}]);return WebSocketClient;}();/**\n * The connection is not yet open.\n */WebSocketClient.CONNECTING=WebSocketImpl.CONNECTING;/**\n * The connection is open and ready to communicate.\n */WebSocketClient.OPEN=WebSocketImpl.OPEN;/**\n * The connection is in the process of closing.\n */WebSocketClient.CLOSING=WebSocketImpl.CLOSING;/**\n * The connection is closed or couldn't be opened.\n */WebSocketClient.CLOSED=WebSocketImpl.CLOSED;exports.default=WebSocketClient;"]},"metadata":{},"sourceType":"script"}