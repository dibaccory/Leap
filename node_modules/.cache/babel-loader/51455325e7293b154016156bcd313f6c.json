{"ast":null,"code":"var _jsxFileName = \"/Users/bacchus/git/Leap/src/js/main.js\";\n//cell is passed a single item in a row, and renders it out, it also calls it's grand-parent's swapper function on click\nvar Popup = React.createClass({\n  displayName: \"Popup\",\n  render: function () {\n    if (this.props.shown) {\n      return React.createElement(\"div\", {\n        className: \"pop\",\n        onClick: this.props.close,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 6\n        },\n        __self: this\n      }, React.createElement(\"div\", {\n        className: \"internal\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 7\n        },\n        __self: this\n      }, this.props.copy, React.createElement(\"button\", {\n        onClick: this.props.close,\n        className: \"close\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 9\n        },\n        __self: this\n      }, \"x\")));\n    } else {\n      return React.createElement(\"div\", {\n        style: {\n          display: 'none'\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 16\n        },\n        __self: this\n      });\n    }\n  }\n}); //game board calls row for each item in the board array\n\nvar GameBoard = React.createClass({\n  displayName: \"GameBoard\",\n  getInitialState: function () {\n    return {\n      board: [['b', '-', 'b', '-', 'b', '-', 'b', '-'], ['-', 'b', '-', 'b', '-', 'b', '-', 'b'], ['b', '-', 'b', '-', 'b', '-', 'b', '-'], ['-', '-', '-', '-', '-', '-', '-', '-'], ['-', '-', '-', '-', '-', '-', '-', '-'], ['-', 'r', '-', 'r', '-', 'r', '-', 'r'], ['r', '-', 'r', '-', 'r', '-', 'r', '-'], ['-', 'r', '-', 'r', '-', 'r', '-', 'r']],\n      activePlayer: 'r',\n      aiDepthCutoff: 3,\n      count: 0,\n      popShown: false\n    };\n  },\n  render: function () {\n    var rowIndex;\n    return React.createElement(\"div\", {\n      className: \"container\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 45\n      },\n      __self: this\n    }, React.createElement(\"div\", {\n      className: 'board ' + this.state.activePlayer,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 46\n      },\n      __self: this\n    }, this.state.board.map(function (row, index) {\n      return React.createElement(Row, {\n        rowArr: row,\n        handlePieceClick: this.handlePieceClick.bind(this),\n        rowIndex: index,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 49\n        },\n        __self: this\n      });\n    }, this)), React.createElement(\"div\", {\n      className: \"clear\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 53\n      },\n      __self: this\n    }), React.createElement(\"button\", {\n      onClick: this.reset,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 54\n      },\n      __self: this\n    }, \"Reset\"), React.createElement(\"button\", {\n      onClick: this.aboutPopOpen,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 55\n      },\n      __self: this\n    }, \"About\"), React.createElement(Statistics, {\n      board: this.state.board,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 56\n      },\n      __self: this\n    }), React.createElement(Popup, {\n      shown: this.state.popShown,\n      close: this.aboutPopClose,\n      copy: \" Hey! Thanks for checking out my checkers game. I know that the title says 'React Checkers', but there isn't a ton of React in use here, it's only handling the display (that's its job, huh?). Essentially React displays our board array, and most of the moving and detection are just accessing that array. The AI is built out using a limited version of the minimax algorithm (see http://neverstopbuilding.com/minimax for a nice explanation of what that means), simply it means that the program forecasts futures, assumes you'll play as if you were doing the same, and picks the route that it thinks will result in the best for itself if you also play 'perfeclty', and I use that word loosely because this AI currently only looks 3 turns in to the future. It uses a point system to determine 'good' and 'bad' stuff that could happen, for example, if it can win in the next 3 turns, thats a 100 point outcome. If it will lose in the next 3 turns, thats worth -100 points, losing a king or killing an enemy king are worth -25 or 25 points respectively, and killing/losing regular pieces are worth +-10 points. Lastly, classifies making a new king of it's own as worth 15 points, so slightly better than killing 1 opponent. The bot looks through something like 1000-1500 possible futures before each move. \",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 57\n      },\n      __self: this\n    }));\n  },\n  aboutPopOpen: function (e) {\n    this.setState({\n      popShown: true\n    });\n  },\n  aboutPopClose: function (e) {\n    this.setState({\n      popShown: false\n    });\n  },\n  handlePieceClick: function (e) {\n    var rowIndex = parseInt(e.target.attributes['data-row'].nodeValue);\n    var cellIndex = parseInt(e.target.attributes['data-cell'].nodeValue);\n\n    if (this.state.board[rowIndex][cellIndex].indexOf(this.state.activePlayer) > -1) {\n      //this is triggered if the piece that was clicked on is one of the player's own pieces, it activates it and highlights possible moves\n      this.state.board = this.state.board.map(function (row) {\n        return row.map(function (cell) {\n          return cell.replace('a', '');\n        });\n      }); //un-activate any previously activated pieces\n\n      this.state.board[rowIndex][cellIndex] = 'a' + this.state.board[rowIndex][cellIndex];\n      this.highlightPossibleMoves(rowIndex, cellIndex);\n    } else if (this.state.board[rowIndex][cellIndex].indexOf('h') > -1) {\n      //this is activated if the piece clicked is a highlighted square, it moves the active piece to that spot.\n      this.state.board = this.executeMove(rowIndex, cellIndex, this.state.board, this.state.activePlayer); //is the game over? if not, swap active player\n\n      this.setState(this.state);\n\n      if (this.winDetection(this.state.board, this.state.activePlayer)) {\n        console.log(this.state.activePlayer + ' won the game!');\n      } else {\n        this.state.activePlayer = this.state.activePlayer == 'r' ? 'b' : 'r';\n\n        if (this.state.activePlayer == 'b') {\n          setTimeout(function () {\n            this.ai();\n          }.bind(this), 50);\n        }\n      }\n    }\n\n    this.setState(this.state);\n  },\n  executeMove: function (rowIndex, cellIndex, board, activePlayer) {\n    var activePiece;\n\n    for (var i = 0; i < board.length; i++) {\n      //for each row\n      for (var j = 0; j < board[i].length; j++) {\n        if (board[i][j].indexOf('a') > -1) {\n          activePiece = board[i][j];\n        }\n      }\n    } //make any jump deletions\n\n\n    var deletions = board[rowIndex][cellIndex].match(/d\\d\\d/g);\n\n    if (typeof deletions !== undefined && deletions !== null && deletions.length > 0) {\n      for (var k = 0; k < deletions.length; k++) {\n        var deleteCoords = deletions[k].replace('d', '').split('');\n        board[deleteCoords[0]][deleteCoords[1]] = '-';\n      }\n    } //remove active piece from it's place\n\n\n    board = board.map(function (row) {\n      return row.map(function (cell) {\n        return cell.replace(activePiece, '-');\n      });\n    }); //unhighlight\n\n    board = board.map(function (row) {\n      return row.map(function (cell) {\n        return cell.replace('h', '-').replace(/d\\d\\d/g, '').trim();\n      });\n    }); //place active piece, now unactive, in it's new place\n\n    board[rowIndex][cellIndex] = activePiece.replace('a', '');\n\n    if (activePlayer == 'b' && rowIndex == 7 || activePlayer == 'r' && rowIndex == 0) {\n      board[rowIndex][cellIndex] += ' k';\n    }\n\n    return board;\n  },\n  highlightPossibleMoves: function (rowIndex, cellIndex) {\n    //unhighlight any previously highlighted cells\n    this.state.board = this.state.board.map(function (row) {\n      return row.map(function (cell) {\n        return cell.replace('h', '-').replace(/d\\d\\d/g, '').trim();\n      });\n    });\n    var possibleMoves = this.findAllPossibleMoves(rowIndex, cellIndex, this.state.board, this.state.activePlayer); //actually highlight the possible moves on the board\n    //the 'highlightTag' inserts the information in to a cell that specifies\n\n    for (var j = 0; j < possibleMoves.length; j++) {\n      var buildHighlightTag = 'h ';\n\n      for (var k = 0; k < possibleMoves[j].wouldDelete.length; k++) {\n        buildHighlightTag += 'd' + String(possibleMoves[j].wouldDelete[k].targetRow) + String(possibleMoves[j].wouldDelete[k].targetCell) + ' ';\n      }\n\n      this.state.board[possibleMoves[j].targetRow][possibleMoves[j].targetCell] = buildHighlightTag;\n    }\n\n    this.setState(this.state);\n  },\n  findAllPossibleMoves: function (rowIndex, cellIndex, board, activePlayer) {\n    var possibleMoves = [];\n    var directionOfMotion = [];\n    var leftOrRight = [1, -1];\n    var isKing = board[rowIndex][cellIndex].indexOf('k') > -1;\n\n    if (activePlayer == 'b') {\n      directionOfMotion.push(1);\n    } else {\n      directionOfMotion.push(-1);\n    } //if it's a king, we allow it to both go forward and backward, otherwise it can only move in it's color's normal direction\n    //the move loop below runs through every direction of motion allowed, so if there are two it will hit them both\n\n\n    if (isKing) {\n      directionOfMotion.push(directionOfMotion[0] * -1);\n    } //normal move detection happens here (ie. non jumps)\n    //for each direction of motion allowed to the piece it loops (forward for normal pieces, both for kings)\n    //inside of that loop, it checks in that direction of motion for both left and right (checkers move diagonally)\n    //any moves found are pushed in to the possible moves array\n\n\n    for (var j = 0; j < directionOfMotion.length; j++) {\n      for (var i = 0; i < leftOrRight.length; i++) {\n        if (typeof board[rowIndex + directionOfMotion[j]] !== 'undefined' && typeof board[rowIndex + directionOfMotion[j]][cellIndex + leftOrRight[i]] !== 'undefined' && board[rowIndex + directionOfMotion[j]][cellIndex + leftOrRight[i]] == '-') {\n          if (possibleMoves.map(function (move) {\n            return String(move.targetRow) + String(move.targetCell);\n          }).indexOf(String(rowIndex + directionOfMotion[j]) + String(cellIndex + leftOrRight[i])) < 0) {\n            possibleMoves.push({\n              targetRow: rowIndex + directionOfMotion[j],\n              targetCell: cellIndex + leftOrRight[i],\n              wouldDelete: []\n            });\n          }\n        }\n      }\n    } //get jumps\n\n\n    var jumps = this.findAllJumps(rowIndex, cellIndex, board, directionOfMotion[0], [], [], isKing, activePlayer); //loop and push all jumps in to possibleMoves\n\n    for (var i = 0; i < jumps.length; i++) {\n      possibleMoves.push(jumps[i]);\n    }\n\n    return possibleMoves;\n  },\n  findAllJumps: function (sourceRowIndex, sourceCellIndex, board, directionOfMotion, possibleJumps, wouldDelete, isKing, activePlayer) {\n    //jump moves\n    var thisIterationDidSomething = false;\n    var directions = [directionOfMotion];\n    var leftOrRight = [1, -1];\n\n    if (isKing) {\n      //if it's a king, we'll also look at moving backwards\n      directions.push(directions[0] * -1);\n    } //here we detect any jump possible moves\n    //for each direction available to the piece (based on if it's a king or not)\n    //and for each diag (left or right) we look 2 diag spaces away to see if it's open and if we'd jump an enemy to get there.\n\n\n    for (var k = 0; k < directions.length; k++) {\n      for (var l = 0; l < leftOrRight.length; l++) {\n        leftOrRight[l];\n\n        if (typeof board[sourceRowIndex + directions[k]] !== 'undefined' && typeof board[sourceRowIndex + directions[k]][sourceCellIndex + leftOrRight[l]] !== 'undefined' && typeof board[sourceRowIndex + directions[k] * 2] !== 'undefined' && typeof board[sourceRowIndex + directions[k] * 2][sourceCellIndex + leftOrRight[l] * 2] !== 'undefined' && board[sourceRowIndex + directions[k]][sourceCellIndex + leftOrRight[l]].indexOf(activePlayer == 'r' ? 'b' : 'r') > -1 && board[sourceRowIndex + directions[k] * 2][sourceCellIndex + leftOrRight[l] * 2] == '-') {\n          if (possibleJumps.map(function (move) {\n            return String(move.targetRow) + String(move.targetCell);\n          }).indexOf(String(sourceRowIndex + directions[k] * 2) + String(sourceCellIndex + leftOrRight[l] * 2)) < 0) {\n            //this eventual jump target did not already exist in the list\n            var tempJumpObject = {\n              targetRow: sourceRowIndex + directions[k] * 2,\n              targetCell: sourceCellIndex + leftOrRight[l] * 2,\n              wouldDelete: [{\n                targetRow: sourceRowIndex + directions[k],\n                targetCell: sourceCellIndex + leftOrRight[l]\n              }]\n            };\n\n            for (var i = 0; i < wouldDelete.length; i++) {\n              tempJumpObject.wouldDelete.push(wouldDelete[i]);\n            }\n\n            possibleJumps.push(tempJumpObject);\n            thisIterationDidSomething = true;\n          }\n        }\n      }\n    } //if a jump was found, thisIterationDidSomething is set to true and this function calls itself again from that source point, this is how we recurse to find multi jumps\n\n\n    if (thisIterationDidSomething) {\n      for (var i = 0; i < possibleJumps.length; i++) {\n        var coords = [possibleJumps[i].targetRow, possibleJumps[i].targetCell];\n        var children = this.findAllJumps(coords[0], coords[1], board, directionOfMotion, possibleJumps, possibleJumps[i].wouldDelete, isKing, activePlayer);\n\n        for (var j = 0; j < children.length; j++) {\n          if (possibleJumps.indexOf(children[j]) < 0) {\n            possibleJumps.push(children[j]);\n          }\n        }\n      }\n    }\n\n    return possibleJumps;\n  },\n  reset: function () {\n    this.setState({\n      board: [['b', '-', 'b', '-', 'b', '-', 'b', '-'], ['-', 'b', '-', 'b', '-', 'b', '-', 'b'], ['b', '-', 'b', '-', 'b', '-', 'b', '-'], ['-', '-', '-', '-', '-', '-', '-', '-'], ['-', '-', '-', '-', '-', '-', '-', '-'], ['-', 'r', '-', 'r', '-', 'r', '-', 'r'], ['r', '-', 'r', '-', 'r', '-', 'r', '-'], ['-', 'r', '-', 'r', '-', 'r', '-', 'r']],\n      activePlayer: 'r'\n    });\n  },\n  winDetection: function (board, activePlayer) {\n    var enemyPlayer = activePlayer == 'r' ? 'b' : 'r';\n    var result = true;\n\n    for (var i = 0; i < board.length; i++) {\n      for (var j = 0; j < board[i].length; j++) {\n        if (board[i][j].indexOf(enemyPlayer) > -1) {\n          result = false;\n        }\n      }\n    }\n\n    return result;\n  },\n  cloneBoard: function (board) {\n    var output = [];\n\n    for (var i = 0; i < board.length; i++) output.push(board[i].slice(0));\n\n    return output;\n  },\n  ai: function () {\n    //prep a branching future prediction\n    this.count = 0;\n    console.time('decisionTree');\n    var decisionTree = this.aiBranch(this.state.board, this.state.activePlayer, 1);\n    console.timeEnd('decisionTree');\n    console.log(this.count); //execute the most favorable move\n\n    if (decisionTree.length > 0) {\n      console.log(decisionTree[0]);\n      setTimeout(function () {\n        this.handlePieceClick({\n          target: {\n            attributes: {\n              'data-row': {\n                nodeValue: decisionTree[0].piece.targetRow\n              },\n              'data-cell': {\n                nodeValue: decisionTree[0].piece.targetCell\n              }\n            }\n          }\n        });\n        setTimeout(function () {\n          this.handlePieceClick({\n            target: {\n              attributes: {\n                'data-row': {\n                  nodeValue: decisionTree[0].move.targetRow\n                },\n                'data-cell': {\n                  nodeValue: decisionTree[0].move.targetCell\n                }\n              }\n            }\n          });\n        }.bind(this), 1000);\n      }.bind(this), 750);\n    } else {\n      alert('no moves, you win!');\n    }\n  },\n  aiBranch: function (hypotheticalBoard, activePlayer, depth) {\n    this.count++;\n    var output = [];\n\n    for (var i = 0; i < hypotheticalBoard.length; i++) {\n      for (var j = 0; j < hypotheticalBoard[i].length; j++) {\n        if (hypotheticalBoard[i][j].indexOf(activePlayer) > -1) {\n          var possibleMoves = this.findAllPossibleMoves(i, j, hypotheticalBoard, activePlayer);\n\n          for (var k = 0; k < possibleMoves.length; k++) {\n            var tempBoard = this.cloneBoard(hypotheticalBoard);\n            tempBoard[i][j] = 'a' + tempBoard[i][j];\n            var buildHighlightTag = 'h ';\n\n            for (var m = 0; m < possibleMoves[k].wouldDelete.length; m++) {\n              buildHighlightTag += 'd' + String(possibleMoves[k].wouldDelete[m].targetRow) + String(possibleMoves[k].wouldDelete[m].targetCell) + ' ';\n            }\n\n            tempBoard[possibleMoves[k].targetRow][possibleMoves[k].targetCell] = buildHighlightTag;\n            var buildingObject = {\n              piece: {\n                targetRow: i,\n                targetCell: j\n              },\n              move: possibleMoves[k],\n              board: this.executeMove(possibleMoves[k].targetRow, possibleMoves[k].targetCell, tempBoard, activePlayer),\n              terminal: null,\n              children: [],\n              score: 0,\n              activePlayer: activePlayer,\n              depth: depth //does that move win the game?\n\n            };\n            buildingObject.terminal = this.winDetection(buildingObject.board, activePlayer);\n\n            if (buildingObject.terminal) {\n              //console.log('a terminal move was found');\n              //if terminal, score is easy, just depends on who won\n              if (activePlayer == this.state.activePlayer) {\n                buildingObject.score = 100 - depth;\n              } else {\n                buildingObject.score = -100 - depth;\n              }\n            } else if (depth > this.state.aiDepthCutoff) {\n              //don't want to blow up the call stack boiiiiii\n              buildingObject.score = 0;\n            } else {\n              buildingObject.children = this.aiBranch(buildingObject.board, activePlayer == 'r' ? 'b' : 'r', depth + 1); //if not terminal, we want the best score from this route (or worst depending on who won)\n\n              var scoreHolder = [];\n\n              for (var l = 0; l < buildingObject.children.length; l++) {\n                if (typeof buildingObject.children[l].score !== 'undefined') {\n                  scoreHolder.push(buildingObject.children[l].score);\n                }\n              }\n\n              scoreHolder.sort(function (a, b) {\n                if (a > b) return -1;\n                if (a < b) return 1;\n                return 0;\n              });\n\n              if (scoreHolder.length > 0) {\n                if (activePlayer == this.state.activePlayer) {\n                  buildingObject.score = scoreHolder[scoreHolder.length - 1];\n                } else {\n                  buildingObject.score = scoreHolder[0];\n                }\n              } else {\n                if (activePlayer == this.state.activePlayer) {\n                  buildingObject.score = 100 - depth;\n                } else {\n                  buildingObject.score = -100 - depth;\n                }\n              }\n            }\n\n            if (activePlayer == this.state.activePlayer) {\n              for (var n = 0; n < buildingObject.move.wouldDelete.length; n++) {\n                if (hypotheticalBoard[buildingObject.move.wouldDelete[n].targetRow][buildingObject.move.wouldDelete[n].targetCell].indexOf('k') > -1) {\n                  buildingObject.score += 25 - depth;\n                } else {\n                  buildingObject.score += 10 - depth;\n                }\n              }\n\n              if ((JSON.stringify(hypotheticalBoard).match(/k/g) || []).length < (JSON.stringify(buildingObject.board).match(/k/g) || []).length) {\n                //new king made after this move\n                buildingObject.score += 15 - depth;\n              }\n            } else {\n              for (var n = 0; n < buildingObject.move.wouldDelete.length; n++) {\n                if (hypotheticalBoard[buildingObject.move.wouldDelete[n].targetRow][buildingObject.move.wouldDelete[n].targetCell].indexOf('k') > -1) {\n                  buildingObject.score -= 25 - depth;\n                } else {\n                  buildingObject.score -= 10 - depth;\n                }\n              }\n\n              if ((JSON.stringify(hypotheticalBoard).match(/k/g) || []).length < (JSON.stringify(buildingObject.board).match(/k/g) || []).length) {\n                //new king made after this move\n                buildingObject.score -= 15 - depth;\n              }\n            }\n\n            buildingObject.score += buildingObject.move.wouldDelete.length;\n            output.push(buildingObject);\n          }\n        }\n      }\n    }\n\n    output = output.sort(function (a, b) {\n      if (a.score > b.score) return -1;\n      if (a.score < b.score) return 1;\n      return 0;\n    });\n    return output;\n  }\n}); //render the gameboard on the board element\n\nReactDOM.render(React.createElement(GameBoard, {\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 438\n  },\n  __self: this\n}), document.getElementById('board'));","map":{"version":3,"sources":["/Users/bacchus/git/Leap/src/js/main.js"],"names":["Popup","React","createClass","render","props","shown","close","copy","display","GameBoard","getInitialState","board","activePlayer","aiDepthCutoff","count","popShown","rowIndex","state","map","row","index","handlePieceClick","bind","reset","aboutPopOpen","aboutPopClose","e","setState","parseInt","target","attributes","nodeValue","cellIndex","indexOf","cell","replace","highlightPossibleMoves","executeMove","winDetection","console","log","setTimeout","ai","activePiece","i","length","j","deletions","match","undefined","k","deleteCoords","split","trim","possibleMoves","findAllPossibleMoves","buildHighlightTag","wouldDelete","String","targetRow","targetCell","directionOfMotion","leftOrRight","isKing","push","move","jumps","findAllJumps","sourceRowIndex","sourceCellIndex","possibleJumps","thisIterationDidSomething","directions","l","tempJumpObject","coords","children","enemyPlayer","result","cloneBoard","output","slice","time","decisionTree","aiBranch","timeEnd","piece","alert","hypotheticalBoard","depth","tempBoard","m","buildingObject","terminal","score","scoreHolder","sort","a","b","n","JSON","stringify","ReactDOM","document","getElementById"],"mappings":"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","sourcesContent":["//cell is passed a single item in a row, and renders it out, it also calls it's grand-parent's swapper function on click\nvar Popup = React.createClass({\n\trender: function() {\n\t\tif (this.props.shown) {\n\t\t\treturn(\n\t\t\t\t<div className=\"pop\" onClick={this.props.close} >\n\t\t\t\t\t<div className=\"internal\" >\n\t\t\t\t\t\t{this.props.copy}\n\t\t\t\t\t\t<button onClick={this.props.close} className=\"close\">x</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t)\n\t\t}\n\t\telse {\n\t\t\treturn(\n\t\t\t\t<div style={{display: 'none'}}></div>\n\t\t\t)\n\t\t}\n\t}\n});\n\n//game board calls row for each item in the board array\nvar GameBoard = React.createClass({\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\tboard: [\n\t\t\t\t['b','-','b','-','b','-','b','-'],\n\t\t\t\t['-','b','-','b','-','b','-','b'],\n\t\t\t\t['b','-','b','-','b','-','b','-'],\n\t\t\t\t['-','-','-','-','-','-','-','-'],\n\t\t\t\t['-','-','-','-','-','-','-','-'],\n\t\t\t\t['-','r','-','r','-','r','-','r'],\n\t\t\t\t['r','-','r','-','r','-','r','-'],\n\t\t\t\t['-','r','-','r','-','r','-','r']\n\t\t\t],\n\t\t\tactivePlayer: 'r',\n\t\t\taiDepthCutoff: 3,\n\t\t\tcount: 0,\n\t\t\tpopShown: false\n\t\t}\n\t},\n\trender: function() {\n\t\tvar rowIndex;\n\t\treturn (\n\t\t\t<div className=\"container\">\n\t\t\t\t<div className={'board '+this.state.activePlayer}>\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.state.board.map(function(row, index) {\n\t\t\t\t\t\t\treturn (<Row rowArr={row} handlePieceClick={this.handlePieceClick.bind(this)} rowIndex={index}/>)\n\t\t\t\t\t\t},this)\n\t\t\t\t\t}\n\t\t\t\t</div>\n\t\t\t\t<div className=\"clear\"></div>\n\t\t\t\t<button onClick={this.reset}>Reset</button>\n\t\t\t\t<button onClick={this.aboutPopOpen}>About</button>\n\t\t\t\t<Statistics board={this.state.board}/>\n\t\t\t\t<Popup shown={this.state.popShown} close={this.aboutPopClose} copy=\"\n\t\t\t\t\tHey! Thanks for checking out my checkers game. I know that the title says 'React Checkers', but there isn't a ton of React in use here, it's only handling the display (that's its job, huh?). Essentially React displays our board array, and most of the moving and detection are just accessing that array. The AI is built out using a limited version of the minimax algorithm (see http://neverstopbuilding.com/minimax for a nice explanation of what that means), simply it means that the program forecasts futures, assumes you'll play as if you were doing the same, and picks the route that it thinks will result in the best for itself if you also play 'perfeclty', and I use that word loosely because this AI currently only looks 3 turns in to the future. It uses a point system to determine 'good' and 'bad' stuff that could happen, for example, if it can win in the next 3 turns, thats a 100 point outcome. If it will lose in the next 3 turns, thats worth -100 points, losing a king or killing an enemy king are worth -25 or 25 points respectively, and killing/losing regular pieces are worth +-10 points. Lastly, classifies making a new king of it's own as worth 15 points, so slightly better than killing 1 opponent. The bot looks through something like 1000-1500 possible futures before each move.\n\t\t\t\t\"/>\n\t\t\t</div>\n\t\t);\n\t},\n\taboutPopOpen: function(e) {\n\t\tthis.setState({popShown: true});\n\t},\n\taboutPopClose: function(e) {\n\t\tthis.setState({popShown: false});\n\t},\n\thandlePieceClick: function(e) {\n\t\tvar rowIndex = parseInt(e.target.attributes['data-row'].nodeValue);\n\t\tvar cellIndex = parseInt(e.target.attributes['data-cell'].nodeValue);\n\t\tif (this.state.board[rowIndex][cellIndex].indexOf(this.state.activePlayer) > -1) {\n\t\t\t//this is triggered if the piece that was clicked on is one of the player's own pieces, it activates it and highlights possible moves\n\t\t\tthis.state.board = this.state.board.map(function(row){return row.map(function(cell){return cell.replace('a', '')});}); //un-activate any previously activated pieces\n\t\t\tthis.state.board[rowIndex][cellIndex] = 'a'+this.state.board[rowIndex][cellIndex];\n\t\t\tthis.highlightPossibleMoves(rowIndex, cellIndex);\n\t\t}\n\t\telse if(this.state.board[rowIndex][cellIndex].indexOf('h') > -1) {\n\t\t\t//this is activated if the piece clicked is a highlighted square, it moves the active piece to that spot.\n\t\t\tthis.state.board = this.executeMove(rowIndex, cellIndex, this.state.board, this.state.activePlayer);\n\t\t\t//is the game over? if not, swap active player\n\t\t\tthis.setState(this.state);\n\t\t\tif (this.winDetection(this.state.board, this.state.activePlayer)) {\n\t\t\t\tconsole.log(this.state.activePlayer+ ' won the game!');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.state.activePlayer = (this.state.activePlayer == 'r' ? 'b' : 'r');\n\t\t\t\tif (this.state.activePlayer == 'b') {\n\t\t\t\t\tsetTimeout(function() {this.ai();}.bind(this), 50);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.setState(this.state);\n\t},\n\texecuteMove: function(rowIndex, cellIndex, board, activePlayer) {\n\t\tvar activePiece;\n\t\tfor (var i = 0; i < board.length; i++) {\n\t\t\t//for each row\n\t\t\tfor (var j = 0; j < board[i].length; j++) {\n\t\t\t\tif (board[i][j].indexOf('a')>-1) {\n\t\t\t\t\tactivePiece = board[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//make any jump deletions\n\t\tvar deletions = board[rowIndex][cellIndex].match(/d\\d\\d/g);\n\t\tif (typeof deletions !== undefined && deletions !== null && deletions.length > 0) {\n\t\t\tfor (var k = 0; k < deletions.length; k++) {\n\t\t\t\tvar deleteCoords = deletions[k].replace('d', '').split('');\n\t\t\t\tboard[deleteCoords[0]][deleteCoords[1]] = '-';\n\t\t\t}\n\t\t}\n\t\t//remove active piece from it's place\n\t\tboard = board.map(function(row){return row.map(function(cell){return cell.replace(activePiece, '-')});});\n\t\t//unhighlight\n\t\tboard = board.map(function(row){return row.map(function(cell){return cell.replace('h', '-').replace(/d\\d\\d/g, '').trim()});});\n\t\t//place active piece, now unactive, in it's new place\n\t\tboard[rowIndex][cellIndex] = activePiece.replace('a', '');\n\t\tif ( (activePlayer == 'b' && rowIndex == 7) || (activePlayer == 'r' && rowIndex == 0) ) {\n\t\t\tboard[rowIndex][cellIndex]+= ' k';\n\t\t}\n\t\treturn board;\n\t},\n\thighlightPossibleMoves: function(rowIndex, cellIndex) {\n\t\t//unhighlight any previously highlighted cells\n\t\tthis.state.board = this.state.board.map(function(row){return row.map(function(cell){return cell.replace('h', '-').replace(/d\\d\\d/g, '').trim()});});\n\n\t\tvar possibleMoves = this.findAllPossibleMoves(rowIndex, cellIndex, this.state.board, this.state.activePlayer);\n\n\t\t//actually highlight the possible moves on the board\n\t\t//the 'highlightTag' inserts the information in to a cell that specifies\n\t\tfor (var j = 0; j < possibleMoves.length; j++) {\n\t\t\tvar buildHighlightTag = 'h ';\n\t\t\tfor (var k = 0; k < possibleMoves[j].wouldDelete.length; k++) {\n\t\t\t\tbuildHighlightTag += 'd'+String(possibleMoves[j].wouldDelete[k].targetRow) + String(possibleMoves[j].wouldDelete[k].targetCell)+' ';\n\t\t\t}\n\t\t\tthis.state.board[possibleMoves[j].targetRow][possibleMoves[j].targetCell] = buildHighlightTag;\n\t\t}\n\n\t\tthis.setState(this.state);\n\t},\n\tfindAllPossibleMoves: function(rowIndex, cellIndex, board, activePlayer) {\n\t\tvar possibleMoves = [];\n\t\tvar directionOfMotion = [];\n\t\tvar leftOrRight = [1,-1];\n\t\tvar isKing = board[rowIndex][cellIndex].indexOf('k') > -1;\n\t\tif (activePlayer == 'b') {\n\t\t\tdirectionOfMotion.push(1);\n\t\t}\n\t\telse {\n\t\t\tdirectionOfMotion.push(-1);\n\t\t}\n\n\t\t//if it's a king, we allow it to both go forward and backward, otherwise it can only move in it's color's normal direction\n\t\t//the move loop below runs through every direction of motion allowed, so if there are two it will hit them both\n\t\tif (isKing) {\n\t\t\tdirectionOfMotion.push(directionOfMotion[0]*-1);\n\t\t}\n\n\t\t//normal move detection happens here (ie. non jumps)\n\t\t//for each direction of motion allowed to the piece it loops (forward for normal pieces, both for kings)\n\t\t//inside of that loop, it checks in that direction of motion for both left and right (checkers move diagonally)\n\t\t//any moves found are pushed in to the possible moves array\n\t\tfor (var j = 0; j < directionOfMotion.length; j++) {\n\t\t\tfor (var i = 0; i < leftOrRight.length; i++) {\n\t\t\t\tif (\n\t\t\t\t\ttypeof board[rowIndex+directionOfMotion[j]] !== 'undefined' &&\n\t\t\t\t\ttypeof board[rowIndex+directionOfMotion[j]][cellIndex + leftOrRight[i]] !== 'undefined' &&\n\t\t\t\t\tboard[rowIndex+directionOfMotion[j]][cellIndex + leftOrRight[i]] == '-'\n\t\t\t\t){\n\t\t\t\t\tif (possibleMoves.map(function(move){return String(move.targetRow)+String(move.targetCell);}).indexOf(String(rowIndex+directionOfMotion[j])+String(cellIndex+leftOrRight[i])) < 0) {\n\t\t\t\t\t\tpossibleMoves.push({targetRow: rowIndex+directionOfMotion[j], targetCell: cellIndex+leftOrRight[i], wouldDelete:[]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//get jumps\n\t\tvar jumps = this.findAllJumps(rowIndex, cellIndex, board, directionOfMotion[0], [], [], isKing, activePlayer);\n\n\t\t//loop and push all jumps in to possibleMoves\n\t\tfor (var i = 0; i < jumps.length; i++) {\n\t\t\tpossibleMoves.push(jumps[i]);\n\t\t}\n\t\treturn possibleMoves;\n\t},\n\tfindAllJumps: function(sourceRowIndex, sourceCellIndex, board, directionOfMotion, possibleJumps, wouldDelete, isKing, activePlayer) {\n\t\t//jump moves\n\t\tvar thisIterationDidSomething = false;\n\t\tvar directions = [directionOfMotion];\n\t\tvar leftOrRight = [1, -1];\n\t\tif (isKing) {\n\t\t\t//if it's a king, we'll also look at moving backwards\n\t\t\tdirections.push(directions[0]*-1);\n\t\t}\n\t\t//here we detect any jump possible moves\n\t\t//for each direction available to the piece (based on if it's a king or not)\n\t\t//and for each diag (left or right) we look 2 diag spaces away to see if it's open and if we'd jump an enemy to get there.\n\t\tfor (var k = 0; k < directions.length; k++) {\n\t\t\tfor (var l = 0; l < leftOrRight.length; l++) {\n\t\t\t\tleftOrRight[l]\n\t\t\t\tif (\n\t\t\t\t\ttypeof board[sourceRowIndex+directions[k]] !== 'undefined' &&\n\t\t\t\t\ttypeof board[sourceRowIndex+directions[k]][sourceCellIndex+leftOrRight[l]] !== 'undefined' &&\n\t\t\t\t\ttypeof board[sourceRowIndex+(directions[k]*2)] !== 'undefined' &&\n\t\t\t\t\ttypeof board[sourceRowIndex+(directions[k]*2)][sourceCellIndex+(leftOrRight[l]*2)] !== 'undefined' &&\n\t\t\t\t\tboard[sourceRowIndex+directions[k]][sourceCellIndex+leftOrRight[l]].indexOf((activePlayer == 'r' ? 'b' : 'r')) > -1 &&\n\t\t\t\t\tboard[sourceRowIndex+(directions[k]*2)][sourceCellIndex+(leftOrRight[l]*2)] == '-'\n\t\t\t\t){\n\t\t\t\t\tif (possibleJumps.map(function(move){return String(move.targetRow)+String(move.targetCell);}).indexOf(String(sourceRowIndex+(directions[k]*2))+String(sourceCellIndex+(leftOrRight[l]*2))) < 0) {\n\t\t\t\t\t\t//this eventual jump target did not already exist in the list\n\t\t\t\t\t\tvar tempJumpObject = {\n\t\t\t\t\t\t\ttargetRow: sourceRowIndex+(directions[k]*2),\n\t\t\t\t\t\t\ttargetCell: sourceCellIndex+(leftOrRight[l]*2),\n\t\t\t\t\t\t\twouldDelete:[\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttargetRow:sourceRowIndex+directions[k],\n\t\t\t\t\t\t\t\t\ttargetCell:sourceCellIndex+leftOrRight[l]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (var i = 0; i < wouldDelete.length; i++) {\n\t\t\t\t\t\t\ttempJumpObject.wouldDelete.push(wouldDelete[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpossibleJumps.push(tempJumpObject);\n\t\t\t\t\t\tthisIterationDidSomething = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//if a jump was found, thisIterationDidSomething is set to true and this function calls itself again from that source point, this is how we recurse to find multi jumps\n\t\tif(thisIterationDidSomething) {\n\t\t\tfor (var i = 0; i < possibleJumps.length; i++) {\n\t\t\t\tvar coords = [possibleJumps[i].targetRow, possibleJumps[i].targetCell];\n\t\t\t\tvar children = this.findAllJumps(coords[0], coords[1], board, directionOfMotion, possibleJumps, possibleJumps[i].wouldDelete, isKing, activePlayer);\n\t\t\t\tfor (var j = 0; j < children.length; j++) {\n\t\t\t\t\tif (possibleJumps.indexOf(children[j]) < 0) {\n\t\t\t\t\t\tpossibleJumps.push(children[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleJumps;\n\t},\n\treset: function() {\n\t\tthis.setState({\n\t\t\tboard: [\n\t\t\t\t['b','-','b','-','b','-','b','-'],\n\t\t\t\t['-','b','-','b','-','b','-','b'],\n\t\t\t\t['b','-','b','-','b','-','b','-'],\n\t\t\t\t['-','-','-','-','-','-','-','-'],\n\t\t\t\t['-','-','-','-','-','-','-','-'],\n\t\t\t\t['-','r','-','r','-','r','-','r'],\n\t\t\t\t['r','-','r','-','r','-','r','-'],\n\t\t\t\t['-','r','-','r','-','r','-','r']\n\t\t\t],\n\t\t\tactivePlayer: 'r'\n\t\t});\n\t},\n\twinDetection: function(board, activePlayer) {\n\t\tvar enemyPlayer = (activePlayer == 'r' ? 'b' : 'r');\n\t\tvar result = true;\n\t\tfor (var i = 0; i < board.length; i++) {\n\t\t\tfor (var j = 0; j < board[i].length; j++) {\n\t\t\t\tif (board[i][j].indexOf(enemyPlayer) > -1) {\n\t\t\t\t\tresult = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t},\n\tcloneBoard : function(board) {\n        var output = [];\n        for (var i = 0; i < board.length; i++) output.push(board[i].slice(0));\n        return output;\n    },\n\tai: function() {\n\t\t//prep a branching future prediction\n\t\tthis.count = 0;\n\t\tconsole.time('decisionTree');\n\t\tvar decisionTree = this.aiBranch(this.state.board, this.state.activePlayer, 1);\n\t\tconsole.timeEnd('decisionTree');\n\t\tconsole.log(this.count);\n\t\t//execute the most favorable move\n\t\tif (decisionTree.length > 0) {\n\t\t\tconsole.log(decisionTree[0]);\n\t\t\tsetTimeout(function() {\n\t\t\t\tthis.handlePieceClick({\n\t\t\t\t\ttarget:{\n\t\t\t\t\t\tattributes:{\n\t\t\t\t\t\t\t'data-row':{\n\t\t\t\t\t\t\t\tnodeValue:decisionTree[0].piece.targetRow\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t'data-cell':{\n\t\t\t\t\t\t\t\tnodeValue:decisionTree[0].piece.targetCell\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tthis.handlePieceClick({\n\t\t\t\t\t\ttarget:{\n\t\t\t\t\t\t\tattributes:{\n\t\t\t\t\t\t\t\t'data-row':{\n\t\t\t\t\t\t\t\t\tnodeValue:decisionTree[0].move.targetRow\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t'data-cell':{\n\t\t\t\t\t\t\t\t\tnodeValue:decisionTree[0].move.targetCell\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}.bind(this), 1000);\n\t\t\t}.bind(this), 750);\n\t\t}\n\t\telse {\n\t\t\talert('no moves, you win!');\n\t\t}\n\t},\n\taiBranch: function(hypotheticalBoard, activePlayer, depth) {\n\t\tthis.count++;\n\t\tvar output = [];\n\t\tfor (var i = 0; i < hypotheticalBoard.length; i++) {\n\t\t\tfor (var j = 0; j < hypotheticalBoard[i].length; j++) {\n\t\t\t\tif (hypotheticalBoard[i][j].indexOf(activePlayer) > -1) {\n\t\t\t\t\tvar possibleMoves = this.findAllPossibleMoves(i, j, hypotheticalBoard, activePlayer);\n\t\t\t\t\tfor (var k = 0; k < possibleMoves.length; k++) {\n\t\t\t\t\t\tvar tempBoard = this.cloneBoard(hypotheticalBoard);\n                    \ttempBoard[i][j] = 'a'+tempBoard[i][j];\n\n\t\t\t\t\t\tvar buildHighlightTag = 'h ';\n\t\t\t\t\t\tfor (var m = 0; m < possibleMoves[k].wouldDelete.length; m++) {\n\t\t\t\t\t\t\tbuildHighlightTag += 'd'+String(possibleMoves[k].wouldDelete[m].targetRow) + String(possibleMoves[k].wouldDelete[m].targetCell)+' ';\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttempBoard[possibleMoves[k].targetRow][possibleMoves[k].targetCell] = buildHighlightTag;\n\n\t\t\t\t\t\tvar buildingObject = {\n\t\t\t\t\t\t\tpiece: {targetRow: i, targetCell: j},\n\t\t\t\t\t\t\tmove:possibleMoves[k],\n\t\t\t\t\t\t\tboard:this.executeMove(possibleMoves[k].targetRow, possibleMoves[k].targetCell, tempBoard, activePlayer),\n\t\t\t\t\t\t\tterminal: null,\n\t\t\t\t\t\t\tchildren:[],\n\t\t\t\t\t\t\tscore:0,\n\t\t\t\t\t\t\tactivePlayer: activePlayer,\n\t\t\t\t\t\t\tdepth: depth,\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//does that move win the game?\n\t\t\t\t\t\tbuildingObject.terminal = this.winDetection(buildingObject.board, activePlayer);\n\n\t\t\t\t\t\tif (buildingObject.terminal) {\n\t\t\t\t\t\t\t//console.log('a terminal move was found');\n\t\t\t\t\t\t\t//if terminal, score is easy, just depends on who won\n\t\t\t\t\t\t\tif (activePlayer == this.state.activePlayer) {\n\t\t\t\t\t\t\t\tbuildingObject.score = 100-depth;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tbuildingObject.score = -100-depth;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(depth > this.state.aiDepthCutoff) {\n\t\t\t\t\t\t\t//don't want to blow up the call stack boiiiiii\n\t\t\t\t\t\t\tbuildingObject.score = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuildingObject.children = this.aiBranch(buildingObject.board, (activePlayer == 'r' ? 'b' : 'r'), depth+1);\n\t\t\t\t\t\t\t//if not terminal, we want the best score from this route (or worst depending on who won)\n\t\t\t\t\t\t\tvar scoreHolder = [];\n\n\t\t\t\t\t        for (var l = 0; l < buildingObject.children.length; l++) {\n\t\t\t\t\t        \tif (typeof buildingObject.children[l].score !== 'undefined'){\n\t\t\t\t\t        \t\tscoreHolder.push(buildingObject.children[l].score);\n\t\t\t\t\t        \t}\n\t\t\t\t\t        }\n\n\t\t\t\t\t        scoreHolder.sort(function(a,b){ if (a > b) return -1; if (a < b) return 1; return 0; });\n\n\t\t\t\t\t        if (scoreHolder.length > 0) {\n\t\t\t\t\t\t        if (activePlayer == this.state.activePlayer) {\n\t\t\t\t\t\t\t\t\tbuildingObject.score = scoreHolder[scoreHolder.length-1];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tbuildingObject.score = scoreHolder[0];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (activePlayer == this.state.activePlayer) {\n\t\t\t\t\t\t\t\t\tbuildingObject.score = 100-depth;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tbuildingObject.score = -100-depth;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (activePlayer == this.state.activePlayer) {\n\t\t\t\t\t\t\tfor (var n = 0; n < buildingObject.move.wouldDelete.length; n++) {\n\t\t\t\t\t\t\t\tif (hypotheticalBoard[buildingObject.move.wouldDelete[n].targetRow][buildingObject.move.wouldDelete[n].targetCell].indexOf('k') > -1) {\n\t\t\t\t\t\t\t\t\tbuildingObject.score+=(25-depth);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tbuildingObject.score+=(10-depth);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((JSON.stringify(hypotheticalBoard).match(/k/g) || []).length < (JSON.stringify(buildingObject.board).match(/k/g) || []).length) {\n\t\t\t\t\t\t\t\t//new king made after this move\n\t\t\t\t\t\t\t\tbuildingObject.score+=(15-depth);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfor (var n = 0; n < buildingObject.move.wouldDelete.length; n++) {\n\t\t\t\t\t\t\t\tif (hypotheticalBoard[buildingObject.move.wouldDelete[n].targetRow][buildingObject.move.wouldDelete[n].targetCell].indexOf('k') > -1) {\n\t\t\t\t\t\t\t\t\tbuildingObject.score-=(25-depth);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tbuildingObject.score-=(10-depth);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((JSON.stringify(hypotheticalBoard).match(/k/g) || []).length < (JSON.stringify(buildingObject.board).match(/k/g) || []).length) {\n\t\t\t\t\t\t\t\t//new king made after this move\n\t\t\t\t\t\t\t\tbuildingObject.score-=(15-depth);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbuildingObject.score+=buildingObject.move.wouldDelete.length;\n\t\t\t\t\t\toutput.push(buildingObject);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\toutput = output.sort(function(a,b){ if (a.score > b.score) return -1; if (a.score < b.score) return 1; return 0; });\n\t\treturn output;\n\t}\n});\n\n\n//render the gameboard on the board element\nReactDOM.render(<GameBoard />, document.getElementById('board'));\n"]},"metadata":{},"sourceType":"module"}